<html>
<head>
<title>Help about dix_help
</title>
<body>
<a name="top_0">
<center>
<h1>dix_help</h1>
</center>
<a name="1">
<h3 Align=center><a href="dix_help_idx_1.html#0" target="index">DIX </a> </h3>
<pre>
  DIX[/qualifiers] filename [/qualifiers]

  This is a program to dump/display/edit records in all types of files.

  -You can select records by keyvalue and number(indexed files) or 
     recordnumber (sequential files or relative files).
  -You can display the record-data in raw format (like OpenVMS DUMP) or
     interpreted format. For the interpreted mode you need a description.
     See the help about [DIX/help] record format for descriptions.
  -You can use views to combine multiple records from multiple files
     to one "record" (See the help about "views")
  -You can dump/display/edit the record data in four modes.
   1. Screen oriented (using SMG)        (See help about "modes screen_mode").
   2. Screen oriented (using DECWindows) (See help about "modes DECW_mode").
   3. Dump records to a file             (See help about "modes file_mode").
   4. Interactive mode with a powerful scripting language.
                                    (See help about "modes interactive_mode").
  The program supports INDEXED, RELATIVE, DIRECT ACCESS and SEQUENTIAL files.

  The program can open multiple files and multiple descriptions per file.
  A fieldname in a record can contain a pointer to (a key in) another file, 
  and you can follow that link to the other file.
 
  Files are opened READ-ONLY, unless you specify /MODIFY or /WRITE. 
  Files can also be opened bypassing RMS (via the /FAST qualifier).
  You may even open modules in a .tlb or .mlb library 

</pre>
<a name="2">
<h3 Align=center><a href="dix_help_idx_2.html#1" target="index">DIX PARAMETERS </a> </h3>
<pre>

  The first parameter is filename to be "DIX"ed. 
  The filename can contain a list of wildcards. If
  you specify /MULTI_FILE DIX will open all files.
  If you do not specify /MULTI_FILE and more than one files matches
  the ilename(s), you will be prompted to select one file.

  Parameter 2..8 are optional and contain the optional 
  record-search parameters. See the help about "Record_searches"

  The filename can also be specified as a file-id.
  Format: [device:](n1,n2,n3).

  The default for Device: is sys$disk:

  So $DIX (10,20,0)          Will open the file with fileid (10,20,0) on the
                             disk specified by sys$disk
     $DIX mydisk:(10,20,0)   Will open the file with fileid (10,20,0) on
                             disk "mydisk"

  DIX will translate the disk/fileid to a filename, and that filename is used
  for the determination of the description.

  If you specify the filename as module@[library] or as [library](module), 
  DIX will read the module "module" from the (.tlb or .mlb) file "library".
  Both module and library may contain wildcards.
  If no library is specified, DIX will search SYS$LIBRARY:STARLET.MLB
   and SYS$LIBRARY:FORSYSDEF.TLB (if present) by default .

  There are 2 special names for the library name 
     DIX_SYS  : The dix_des.tlb file
     DIX_USER : The dix_des_user.tlb file (if present)

</pre>
<a name="3">
<h3 Align=center><a href="dix_help_idx_2.html#2" target="index">DIX SETUP </a> </h3>
<pre>

  The following symbols may be handy. 'arch' must be vax, alpha or ia64
     and dev:[dir] the place where the image of dix can be found

   DIX:==$dev:[dir]dix_'arch'	               !default dix startup in smg mode
   DXW:==$dev:[dir]dix_'arch'/decw             !dix startup in decwindows  mode
   DXI:==$dev:[dir]dix_'arch'/inter            !dix startup in interactive mode
   DXC:==$dev:[dir]dix_'arch'/command          !dix startup for one line command
   DXP:==$dev:[dir]dix_'arch'/plot             !dix startup for t4 plotting
   DXD:==$dev:[dir]dix_'arch'/command dir/fast !dix startup fast directory search (like dfu)

   DIX also supports a number of symbols, that are checked on startup

   DIX_DEBUG     : Y : All debug classes enabled at level 0 to the file DIX_DEBUG.DBG
                   0..9 : The same as above, but the level is set to 0..9
                   Any other value will be parsed, and debug classes, 
                      level and output will be set.
                    See the help about INTERACTIVE SET DEBUG
            
   DIX_STATISTICS: If defined as Y, DIX will print a line on exit with the
                          elapsed, cpu, bufio,dirio, faults (like ^T)
   DIX_ENABLE_P2 : If defined as Y, DIX will make use of P2 data (Alpha,ia64).
                     This is still experimental, so you must enable it.

   DIX_FAKE_ARCH : OVerride the current architecture (VAX/Alpha/IA64)

   Dix supports a number of logicals

   DIX_HELP       : May point to the dix_help.hlb file
                      The default plase is the same directory as the image
   DIX_PLOT_SETUP : May point to the dix_plot_setup file.
                      The defaultname is DIX_PLOT_SETUP and the default
                        SYS$LOGIN:.SETUP
   DIX_DES        : May point to the systemwide description file.
                      The defaultname is DIX_DES and the default is
                        same_dir_as_image:.TLB
   DIX_DES_USER   : May point to the user defined description file.
                      The defaultname is DIX_DES_USER and the default is
                        SYS$LOGIN:.TLB

</pre>
<a name="4">
<h3 Align=center><a href="dix_help_idx_2.html#3" target="index">DIX MODES </a> </h3>
<pre>

  DIX can operate in 9 modes, 3 are interactive, they let you change the
  records (if you specified /modify)

  The interactive modes

   /SCREEN_ORIENTED : DIX will display data full screen via the SMG routines
                      and lets you look at the record and possibly modify it.
   /DECW_ORIENTED   : DIX will display data full screen via the DECWindows routines
                      and lets you look at the record and possibly modify it.
   /INTERACTIVE     : DIX enter interactive (line) mode. This mode has a powerful
                      scripting language, and can also be used in BATCH.

  The non-interactive commands

   /FILE_ORIENTED : DIX will behave like DUMP, no interaction possible
   /INFO          : DIX will display information about the file.
   /VERIFY        : DIX will verify an indexed file
   /ANALYZE       : DIX will analyze an indexed file with lots of info
   /COMMAND       : DIX will take the argument and process it
   /PLOT          : DIX will take the argument and process it as PLOT/T4 'arg'

  The qualifiers /SCREEN, /DECWINDOW, /FILE,    /INTERACTIVE, /INFO
                 /PlOT    /VERIFY,    /ANALYZE, /COMMAND   

   must be entered just after the DIX verb.

  Three more major-qualifiers qualifiers can be given

   /HELP    : display help
   /DEMO    : Display demo pages
   /VERSION : Display the version, link date of DIX (/ALL for all modules)


</pre>
<a name="5">
<h3 Align=center><a href="dix_help_idx_3.html#4" target="index">DIX MODES ANALYZE </a> </h3>
<pre>
  DIX/ANALYZE [/DISPLAY=(option,option..)] [/VERBOSE=level]


  option can be

   KEY=n           : Analyze only key
   LEVEL=n         : Analyze only key level 'n'
   LEVEL="+n"      : Analyze only the top 'n' key levels
   LEVEL=-n        : Analyze only the lowest '-n' levels
   [NO]DATA        : Analyze the data buckets too. Since this can take a lot
                     of time, this is not the default.
   [NO]SIDR        : Display the SIDR records, this is default
   [NO]KEYBUCKETS  : Display the buckets in the key tree, this is default
   OUTPUT=filename : If verbose is &GT;0, the extra output can be redirected
                     to another file. The normal output will be in the file
                     specified with /OUTPUT=filename
   START=n         : Start analysis at bucket 'n' in chain, default=0
                      (n may be negative, last but 'n' bucket of the chain)
   END=n           : End analysis at bucket 'n' in chain, default is whole chain
                      (n may be negative, last but 'n' bucket of the chain)

   /VERBOSE=level

  The verbose qualifier defines the amount of output

  VERBOSE=0    : Just the normal output, see below
  VERBOSE=1    : Print out the buckets read
  VERBOSE=2    : detail 1 and the bucket header info
  VERBOSE=3    : detail 2 and SIDR records and the data records
  VERBOSE=4    : detail 3 and the SIDR pointers
  If VERBOSE&GT;0, the output of the detail option can de redirected to another 
                 file. See the OUTPUT= option
  Examples

  $DIX/ANA=DATA DUPKEY.IDX
  Analysis of key 1                             !analysis info for key 1
   Type STG, flags %X05:Duplicate,Nullkey=%X30
   Idx area 2, Level1 area 2, bucketsize 1, Fill 512, Level 1, rootvbn 18
   Data area 2, bucketsize 1, Fill 512, VBN 17
   Keysize 4, number of keysegments 1, minimum recordsize 9
    Segment 1, Position     5, size   4
   Level 1                                      !level 1 (toplevel) for key 1
    Start vbn            : 18, #records = 1, #buckets 1(1 blocks), 100% contiguous
     Bytes in            : Overhead: 17, Keyvalues: 4, Pointers: 2, Bucket fill: 5%
     Bytes in keys       : 4(compressed), 4(uncompressed) = 100%
   Analysis of SIDR buckets
    Start vbn            : 17, #buckets 1(1 blocks), 100% contiguous
     Bytes in            : Overhead: 14, Keyvalues: 12, Pointers: 43, Bucket fill: 16%
     Bytes in keys       : 12(compressed), 12(uncompressed) = 100%
     Records             : Keyvalues: 3, RFA's: 7, Deleted: 0
     Maximum SIDR length : 3, average 2 ,max SIDR length for key value:2222
     Average key length  : 4, Average data length 14
  Analysis of key 0                             !analysis for key 0
   Type STG, flags %X81:Duplicate,Data compress
   Idx area 1, Level1 area 1, bucketsize 1, Fill 512, Level 1, rootvbn 13
   Data area 0, bucketsize 1, Fill 512, VBN 4
   Keysize 4, number of keysegments 2, minimum recordsize 4
    Segment 1, Position     2, size   2
    Segment 2, Position     0, size   2
   Level 1                                      !level 1 (toplevel) for key 0
    Start vbn            : 13, #records = 1, #buckets 1(1 blocks), 100% contiguous
     Bytes in            : Overhead: 17, Keyvalues: 4, Pointers: 2, Bucket fill: 5%
     Bytes in keys       : 4(compressed), 4(uncompressed) = 100%
   Analysis of DATA buckets
    Start vbn            : 4, #buckets 1(1 blocks), 100% contiguous
     Bytes in            : Overhead: 14, Keyvalues: 44, Data: 178, Bucket fill: 70%
     Bytes in keys       : 44(compressed), 44(uncompressed) = 100%
     Bytes in datarecords: compressed 178, Uncompressed 145, = 123% (without primary key)
     Datarecords         : Valid 11, #Deleted 0, #RRV 0
     Max data length     : 18, Average = 17
     Maximum DUP keylen  : 1

  The contiguousness of the areas are not very significant except for the 
  SIDR and data area. They are determined in the following way.

  If the next bucket of a bucket is adjacent to the current buffer , 5 is added
  If the next bucket lies within a bucketsize next to the current buffer, 4 is added 
  If the next bucket lies within 2 bucketsizes next to the current buffer, 3 is added
  If the next bucket lies within 3 bucketsizes next to the current buffer, 2 is added
  If the next bucket lies within 4 bucketsizes next to the current buffer, 1 is added
  If the next bucket lies before the current bucket, 0 is added
  The total is multiplied by 100 and divided by the 5*(bucketcount-1). This gives a 
  number between 0 and 100.
 
  If all buckets are adjacent in ascending order we get 100%.
</pre>
<a name="6">
<h3 Align=center><a href="dix_help_idx_3.html#5" target="index">DIX MODES COMMAND </a> </h3>
<pre>

  DIX/COMMAND dix_command
 
  Take the command line and execute it. This is a one-line interactive mode
  Command may be a list of commands via the ;comm;command construct

  Eech ; must be preceeded by a space, or it could be part of a filename
</pre>
<a name="7">
<h3 Align=center><a href="dix_help_idx_3.html#6" target="index">DIX MODES DECW_MODE </a> </h3>
<pre>

  If you specify /DECWINDOW, the program will work full screen
  using DECWindows, and you can look at the data, and possibly
  modify it (see /MODIFY qualifier).

  If you have a description present
   1. You can modify fields (if in modify mode) by entering a right arrow, 
      Enter, or any printable character. You are in fieldmodifying mode until 
      you enter an Enter. After you type Enter DIX checks if the typed data 
      is valid for that field(-type) and restores the original value if not.
      The record will not be updated until you type the DO key.

   2. For fields that contain field-names, you can also enter a key_getfields
      key (default PF1-G) and modify/enter the fieldvalue.

   3. If you type a key_contdis (default F8) DIX will open a popup-display 
      containing information about the description of the current line, and
      update it when you move between lines. If you type key_contdis again
      DIX will remove the display.


   And lots more, see the help (Default PF2 or Help)

  on the command line you may set some settings for the decwindows displays
  See the help in /attributes.

 Syntax
  DIX/DECWINDOW filespec[/qualifiers] [searchparameter] [searchparameter] ..

  The searchparameter is optional, see the help about [DIX/help] record_search
  Up to 7 (search) parameters are supported. DCL allows 8 parameters, and
  the first one is the filename.


</pre>
<a name="8">
<h3 Align=center><a href="dix_help_idx_3.html#7" target="index">DIX MODES DEMO </a> </h3>
<pre>

  DIX will enter demo mode, You will be show (some of) the capabilities
  of DIX.

</pre>
<a name="9">
<h3 Align=center><a href="dix_help_idx_3.html#8" target="index">DIX MODES FILE_MODE </a> </h3>
<pre>

  If you specify /FILE the program will dump the data to a file or the 
  terminal (see /OUTPUT qualifier) in either interpreted or raw dump mode.

 Syntax
  DIX/FILE filespec[/qualifiers] [searchparameter] [searchparameter]


  The searchparameter is optional, see the help about [DIX/help] record_search
  Up to 7 (search) parameters are supported. DCL allows 8 parameters, and
  the first one is the filename.

</pre>
<a name="10">
<h3 Align=center><a href="dix_help_idx_3.html#9" target="index">DIX MODES HELP </a> </h3>
<pre>

  Display the DIX help, you are doing it now
  You can specify arguments for the help. If the first argument is a
  qualifier you must use "'s around the help text, otherwise DCL will get
  confused.
  The following qualifiers are supported for the HELP command, and must
  be entered directly after the HELP command

   /DCL       : Display the help in SYS$HELP:HELPLIB.HLB instead of the DIX help
   /DECWINDOW : Display the help in  a decwindow window. This requires the
                availability of DECWINDOWS and a freeware package FSHELP
                (see below) 

  Examples

  DIX/HELP modes             give help about the mode
  DIX/HELP modes info        give help about the modes info subtopic
  DIX/HELP "/DISPLAY"        give help about the /DISPLAY qualifier. You need
                               the quotes here
  DIX/HELP record_sear/exist give help about the /exist subtopic in record_sear
  DIX/HELP/DCL copy          Give help about the COPY command in 
                             SYS$HELP:HELPLIB.HLB
  DIX/HELP/DECW modes        Give the help about modes in a decwindows display
                             (if fshelp is installed)
  
  DIX will use the LBR$OUTPUT_HELP routine. If you also have the 
  FSHELP freeware package installed (available on the same website), 
  DIX will use the FSHELP_SHR inclusive a DECWINDINDOWS interface.

</pre>
<a name="11">
<h3 Align=center><a href="dix_help_idx_3.html#10" target="index">DIX MODES INFO </a> </h3>
<pre>

  The /INFO qualifier will display information about the file(s), including
  information about the keys of an indexed file.
  This information includes name,position,size and type of keys.
  The /INFO qualifier must be the first on the command line.

  If you specify the /FDL qualifier also, DIX will output the info in
  an fdl file. This should give the same output as ana/rms/fdl, 
  but is does not analyze the data, so it is a lot faster for large files
  (but cannot be used for optimizing)


  Example:
  $DIX/INFO SYSUAF
 Information about file KXSYS_DISK:[VMS_COMMON.SYSEXE]SYSUAF.DAT;2
 File
  Opened for       : Normal IO,Fast IO(default)
   Fast Blocksize  : 1024
   Fast Multibuffer: 4
  Organization     : Indexed
  Lock mode        : Normal
  Record format    : Variable
  Creation   date  : 25-NOV-2003 17:01:26.28
  Expiration date  :  5-FEB-2007 08:15:44.15
  Backup     date  : &LT;No backup recorded&GT;
  Revision   date  :  9-AUG-2006 08:15:44.15
  File id          : (66004,27,0)
  File owner       : [SYSTEM] = [1,4]
  File protection  : S:RWED, O:RWED, G:RE, W:
  Globalbuffercount:          0
 Record
  Record attribute : NONE
  Max record size  :       1412
  Longest record   :          0
 Allocation
  EOF block        :         72 (FFB =    0)
  Allocated blocks :         72
  Bucketsize       :          3
 Areas
  Area Allocation bucketsize  extension
     0         72          3         10
 Keyinformation
            D C I K D  N               ..INDEX. ..DATA..
   Nr Type  u h c c c  u Lvl   Pos Siz Area Bkt Area Bkt Field
            p g p p p  l                 Nr siz   Nr siz
    0 STG   N N Y Y Y NO   1     4  32    0   3    0   3 UAF$T_USERNAME
    1 BIN4  Y Y N N N NO   1    36   4    0   3    0   3 UAF$W_MEM,UAF$W_GRP,UAF
                                                         $L_UIC
    2 BIN8  Y Y N N N NO   1    36   8    0   3    0   3 UAF$W_MEM,UAF$W_GRP,UAF
                                                         $L_UIC,UAF$L_SUB_ID
    3 BIN8  Y Y N N N NO   1    44   8    0   3    0   3 UAF$Q_PARENT_ID(1),UAF$
                                                         Q_PARENT_ID(2)
 * means the current file
 
  The tags in the keyinformation are
    Nr  : the key number
    Type: the key type (Descending keys have D in front)
    Dup : This key allows duplicate
    Chg : This key is changeable
    Icp : Key values are compressed in index buckets
    Kcp : Key values are compressed in data buckets
    Dcp : Data values are compressed (in data buckets)
    Nul : The null-key value(in HEX) for this key or NO
    Lvl : The tree depth for index buckets
    Pos : the starting position of the key (multiple lines if more segments)
    Siz : the size of the key (multiple lines if more segments)
    Index:
     Area_nr : The area for the index buckets
     Bktsize : the bucket size for the index buckets
    Data:
     Area_nr : The area for the data buckets
     Bktsize : the bucket size for the data buckets

  If DIX has a description for this file (as above) DIX will also 
   display the fields that are part of this key

    An example of an fdl command
 
    $DIX/info/fdl/out=test.fdl test.dat
</pre>
<a name="12">
<h3 Align=center><a href="dix_help_idx_3.html#11" target="index">DIX MODES INTERACTIVE_MODE </a> </h3>
<pre>

  If you specify /INTERACTIVE, DIX will enter interactive mode
  and lets you display/modify fields. This mode works in BATCH too,
  so you can create command-files and use DIX to display/modify fields.
  See also the /INTERACTIVE qualifier.

![Interactive mode]DIX /INTERACTIVE

  Syntax
   DIX/INTER [filespec] [/qualifiers] [searchparameter] ..


  Filespec is optional. If you do not specify a filespec DIX will start
  without any file open. You can then later open/close files with the 
  interactive commands OPEN and CLOSE.

  Example:

  DIX/INTER SYSUAF/MODIFY /script=mycommands

  Will execute the commands in mycommands[.DIX] and exit.

  The searchparameter is optional, see the help about [DIX/help] record_search
  Up to 7 (search) parameters are supported. DCL allows 8 parameters, and
  the first one is the filename.


</pre>
<a name="13">
<h3 Align=center><a href="dix_help_idx_3.html#12" target="index">DIX MODES RESTORE_MODE </a> </h3>
<pre>

  If you specify DIX/RESTORE  DIX will continue from the point you 
  exited DIX the last time(at least if you had auto mode enabled then).

  It will open all files you had open, and select the record(s) you
  were processing at that time.
  It will also restore your recall buffer, key definitions for the 
  interactive mode, display settings and so on.
  
  See the SET AUTO, SHOW AUTO, EXIT/[NO]AUTO command in interactive mode.
</pre>
<a name="14">
<h3 Align=center><a href="dix_help_idx_3.html#13" target="index">DIX MODES PIPE </a> </h3>
<pre>

  pipe command [;command [;command]]

  Make a sequence of commands. You can use loops in this statement f.e.
   DIX&GT; pipe for k=1,10 ; show symb k ; end for
   DIX&GT; pipe k=1 ; lp:show symb k ; k=k+1 ; if k &LT;= 10 then goto lp

   the ; must be preceeded by a space or it could be part of a filename

</pre>
<a name="15">
<h3 Align=center><a href="dix_help_idx_3.html#14" target="index">DIX MODES PLOT </a> </h3>
<pre>

  DIX/PLOT filemask/qualifiers
 
   DIX will execute the PLOT/T4 'filemask/qualifiers'. For more help
   see the INTERACTIVE_MODE PLOT command.
   You can also use the DIX/PLOT/CSV and the DIX/PLOT/PIE command.
   

</pre>
<a name="16">
<h3 Align=center><a href="dix_help_idx_3.html#15" target="index">DIX MODES SCREEN_MODE </a> </h3>
<pre>

  If you specify /SCREEN (default), DIX will work in full screen mode
  using the SMG routines, and you can look at the data, and possibly
  modify it (see /MODIFY qualifier).

  If you have a description present
   1. You can modify fields (if in modify mode) by entering a right arrow, 
      Enter, or any printable character. You are in fieldmodifying mode until 
      you enter an Enter. After you type Enter DIX checks if the typed data 
      is valid for that field(-type) and restores the original value if not.
      The record will not be updated until you type the DO key.

   2. For fields that contain field-names, you can also enter a key_getfields
      key (default PF1-G) and modify/enter the fieldvalue through a SMG-menu.

   3. If you type a key_contdis (default F8) DIX will open a popup-display 
      containing information about the description of the current line, and
      update it when you move between lines. If you type key_contdis again
      DIX will remove the display.


   And lots more, see the help (Default PF2 or Help)

 Syntax
  DIX[/SCREEN] filespec[/qualifiers] [searchparameter] [searchparameter] ..

  The searchparameter is optional, see the help about [DIX/help] record_search
  Up to 7 (search) parameters are supported. DCL allows 8 parameters, and
  the first one is the filename.


</pre>
<a name="17">
<h3 Align=center><a href="dix_help_idx_3.html#16" target="index">DIX MODES VERIFY </a> </h3>
<pre>
  DIX/verify indexedfile [qualifiers]

  Check all buckets of an indexed file for corruption.

  Supported qualifiers are
   /verbose=n       : n=0..4 Output more info during the check  
   /output=filename : Print errors to file

  DIX can be used to detect and repair corrupt indexed files
  See the deeper help
 
  BE VERY CAREFUL. 
  ===============
  Always make a copy of the corrupt file and edit the copied file. 
 
</pre>
<a name="18">
<h3 Align=center><a href="dix_help_idx_4.html#17" target="index">DIX MODES VERIFY Repairing_corrupt </a> </h3>
<pre>

  If a file has a corrupt bucket, You may use DIX to repair the file
  or get as many records out of it as possible.

  If the bucket is not a databucket, DIX using fastio can read all records
  and copy them to a new file. 
 
  Example
  We have a file with a corrupt index bucket (it was patched)

  $DIX/info/verif sysu.dat/verbos=3
  Information about file USER50:[STUBBF.PROGRAMS.DIX.TEST]SYSU.DAT;2
  ...
   Reading Prologue block 1
   Checking area 0
    Reading area admin offset 0 in block 3
    Checking area fields 0
   Checking key 0
    Reading key admin block offset 0 in block 1
    Checking key fields for key 0
    Checking key tree for key 0
  %DIX_RMS-W,Bucket 7 level 1 Check bytes different, first 0A, last 0E, previous bucket 0
   Checking key 1
    Reading key admin block offset 0 in block 2
    Checking key fields for key 1
    Checking key tree for key 1
   Checking key 2
    Reading key admin block offset 102 in block 2
    Checking key fields for key 2
    Checking key tree for key 2
   Checking key 3
    Reading key admin block offset 204 in block 2
    Checking key fields for key 3
    Checking key tree for key 3

  This tells us that a bucket is corrupt in the primary key chain at level 1.
  Since this is NOT a data bucket we can use DIX to get all records from this
  file and copy it to a new file using

   $DIX/interac sysu.dat
    %RMS-F-CHK, bucket format check failed for VBN = 7
    %DIX-I-USINGFIL, Using file USER50:[STUBBF.PROGRAMS.DIX.TEST]SYSU.DAT;2/NOMOD

   DIX (RMS) is telling us that the file has a corrupt bucket (the root bucket
   for the primary key. RMS cannot process this file, so we try again using
   fastio

   $DIX/interac sysu.dat/fastio
   %DIX-I-USINGFIL, Using file USER50:[STUBBF.PROGRAMS.DIX]SYSU.DAT;2/NOMOD
   DIX&GT;WRITE/ALL/LOG new_file.dat
   %DIX-I-RECAPP, 62 records written to NEW_FILE.DAT

   So now we have a copy of the file with all record. Now use convert to
   make the file indexed again, and we have all records back

  If the corrupt bucket IS a data bucket you have two options.

  1. Use DIX to repair the corrupt bucket.
  2. Use DIX to skip the data bucket.


</pre>
<a name="19">
<h3 Align=center><a href="dix_help_idx_5.html#18" target="index">DIX MODES VERIFY Repairing_corrupt Repairing_bucket </a> </h3>
<pre>

   Now suppose the corrupt bucket is the in one of the data buckets.
   RMS as well as FASTIO will follow the chain of the data-buckets and
   will find the corrupt bucket, so we cannot use the previous method. 
   Below is the technique to repair a DATA-bucket (if not too heavily damaged)

   $DIX/int [.test]sysu.dat
   %DIX-I-USINGFIL, Using file USER50:[STUBBF.PROGRAMS.DIX]SYSU.DAT;2/NOMOD
   DIX&GT;ne
   DIX&GT;ne
   %RMS-F-CHK, bucket format check failed for VBN = 55
   %RMS-F-CHK, bucket format check failed for VBN = 0

   This tells us we have a corrupt bucket at bucket 55. We need to know the 
   bucketsize of the data-buckets
    $DIX/info sysu.dat  !show key info of the file
    Keyinformation
     .....
             D C I K D  N               ..INDEX. ..DATA..
    Nr Type  u h c c c  u Lvl   Pos Siz Area Bkt Area Bkt
             p g p p p  l                 Nr siz   Nr siz
     0 STG   N N Y Y Y NO   1     4  32    0   3    0   3 &LT;== this 3 is the 
                                                              data bucketsize
   ...
   Enter DIX in block mode for this bucket (using the built-in $BUCKET 
        description)

   $DIX/INT/MODIFY /BLOCK=3/record=55/descr=$bucket SYSU.DAT
   %DIX-I-USINGFIL, Using file USER50:[STUBBF.PROGRAMS.DIX]SYSU.DAT;2/MOD
   %DIX-I-MESSAGE, "Data bucket"
   %DIX-I-MESSAGE, "Check and Check1 not equal, corrupt bucket"
   %DIX-I-USINGDES, Using description DSA50:[STUBBF.PROGRAMS.DIX]DIX_DES.TLB;135($BUCKET)
   DIX&GT;   !DIX tells us the bucket is corrupt (the check and check1 are unequal)
   DIX&GT; examin *CHECK*
      0.0|CHECK    |19
      2.0|CHECK_VBN|55
   1535.0|CHECK1   |17

   And indeed : check and check1 are not equal. We can patch them to be equal

   DIX&GT;DEPOSIT CHECK=17
   %DIX-I-MESSAGE, "Data bucket"	!DIX tells us it is data bucket
   DIX&GT;UPDATE

   If this was the only problem, the bucket is now correct.
   You may test to see if the rest of the buckets looks OK 
   DIX&GT; EXAMI

   If this looks fine, all is done. If not we need to skip this databucket
   from the data-bucket chain, so see the other help (skipping bucket)

</pre>
<a name="20">
<h3 Align=center><a href="dix_help_idx_5.html#19" target="index">DIX MODES VERIFY Repairing_corrupt Skipping_bucket </a> </h3>
<pre>

   Now the bucket is very corrupt and does not contain any valid data.
   We can use DIX to skip the bucket from the data-chain. This means
   we use a bucketful of records, not perfect but better than nothing at all.

    $DIX/info/verif sysu.dat
    Information about file USER50:[STUBBF.PROGRAMS.DIX.TEST]SYSU.DAT;2
    %DIX-E-VERIFY, Bucket 55, level 0 Check bytes different, first 13, last 11,
            previous bucket 4
    %DIX-E-VERIFY, Data bucket 55 points to bucket 33,but the upper key bucket
            points to 34
    %DIX-S-VERIFY, Using pointer from index bucket 7 to bucket 34
    %DIX-E-ERRSEEN, Error seen during verify
    $

   So bucket 55 has two problems
    1. The check bytes do not match
    2. The next_bucket pointer (33) is probably incorrect, since the above 
       lying index buckets points to bucket 34, and this index bucket seems
       to be valid.
   The previous bucket of 55 is 4, so now we need to patch bucket 4 to point 
   to bucket 34, effectively skipping bucket 55.
   We still know the bucket size for data=3

   $DIX/INT/MODIFY /BLOCK=3/record=4/descr=$bucket SYSU.DAT
   %DIX-I-USINGFIL, Using file USER50:[STUBBF.PROGRAMS.DIX.TEST]SYSU.DAT;2/MOD
   %DIX-I-MESSAGE, "Data bucket"
   %DIX-I-USINGDES, Using description DSA50:[STUBBF.PROGRAMS.DIX]DIX_DES.TLB;135($BUCKET)
   DIX&GT;exa next_bucket
      8.0|NEXT_BUCKET&GT;|55

   Indeed bucket 4 points to bucket 55, we now set its forward to bucket 34

   DIX&GT;deposit next_bucket=34
   DIX&GT;UPDATE
   DIX&GT;REWIND
   DIX&GT;WRITE/ALL/LOG x.x
   %DIX-I-RECAPP, 58 records written to x.x

   Now we have copied all (58 and not 62) records to x.x, and recovered most of
   the records

</pre>
<a name="21">
<h3 Align=center><a href="dix_help_idx_3.html#17" target="index">DIX MODES VERSION </a> </h3>
<pre>

   DIX/VERSION [/ALL][/SYMBOL] [/OUTPUT=file]

   Display the version and link date of DIX.

   If /ALL is specified, versions and creation dates of all DIX modules
          will be displayed.

   If /SYMBOL is specified DIX will define the following symbols
      DIX_VERSION   : containing the version e.g. "7.1" 
      DIX_LINK_DATE : Containing the link date e.g. "23-AUG-2008 10:12.19.45"
      If /ALL is also specified, DIX will also define the following symbols
      DIX_MODULE_COUNT    : Count of modules
      DIX_MODULE_NAME_'n' : The name of the module 'n'
      DIX_MODULE_DATE_'n' : The creation date of the module 'n'

       with n=1..dix_module_count


</pre>
<a name="22">
<h3 Align=center><a href="dix_help_idx_2.html#4" target="index">DIX FILETYPE_SUPPORT </a> </h3>
<pre>

  The following file types are supported.

</pre>
<a name="23">
<h3 Align=center><a href="dix_help_idx_3.html#19" target="index">DIX FILETYPE_SUPPORT SEQUENTIAL </a> </h3>
<pre>
  
  For SEQUENTIAL or RELATIVE files the record selection is based on 
  the /RECORD qualifier. If the start record is nn, the first nn-1 
  records will be skipped, this may take some time. 
  If the record format is fixed, DIX can read the record directly without
  skipping the previous records. 

</pre>
<a name="24">
<h3 Align=center><a href="dix_help_idx_4.html#21" target="index">DIX FILETYPE_SUPPORT SEQUENTIAL /RECORD </a> </h3>
<pre>
  /RECORD=nr
  
  You can specify the starting record number. For indexed files you can
  also use the /key to go to the 'n'th record on key 'key'.
  If not specified the program starts at the first record.

</pre>
<a name="25">
<h3 Align=center><a href="dix_help_idx_3.html#20" target="index">DIX FILETYPE_SUPPORT RELATIVE_FILES </a> </h3>
<pre>
  
  You can specify a record number. DIX will rewind the file and skip
  'recordnumber'-1 records.
  You can also specify a Cell number with the /EQ, /GE, /GT 
  In this case the access will be direct.
</pre>
<a name="26">
<h3 Align=center><a href="dix_help_idx_4.html#23" target="index">DIX FILETYPE_SUPPORT RELATIVE_FILES /RECORD </a> </h3>
<pre>
  /RECORD=nr
  
  You can specify the starting record number.

</pre>
<a name="27">
<h3 Align=center><a href="dix_help_idx_4.html#24" target="index">DIX FILETYPE_SUPPORT RELATIVE_FILES /EQ </a> </h3>
<pre>
  /EQ=value

  Look for a record with CELLnumber EQ the specified value.
  The values will be converted by DCL to Uppercase, unless enclosed in
  quotes.   See also the help about keyvalues.
  If DIX is in case_sensitive mode, DIX will not upcase the value.
  See the help about "set case "
</pre>
<a name="28">
<h3 Align=center><a href="dix_help_idx_4.html#25" target="index">DIX FILETYPE_SUPPORT RELATIVE_FILES /GE </a> </h3>
<pre>
  /GE=value

  Look for a record with CELLnumber GE the specified value.
  The values will be converted by DCL to Uppercase, unless enclosed in
  quotes. See also the help about keyvalues.
  If DIX is in case_sensitive mode, DIX will not upcase the value.
  See the help about "set case "
</pre>
<a name="29">
<h3 Align=center><a href="dix_help_idx_4.html#26" target="index">DIX FILETYPE_SUPPORT RELATIVE_FILES /GT </a> </h3>
<pre>
  /GT=value

  Look for a record with CELLnumber GT the specified value.
  The values will be converted by DCL to Uppercase, unless enclosed in
  quotes. See also the help about keyvalues.
  If DIX is in case_sensitive mode, DIX will not upcase the value.
  See the help about "set case "

</pre>
<a name="30">
<h3 Align=center><a href="dix_help_idx_4.html#27" target="index">DIX FILETYPE_SUPPORT RELATIVE_FILES Keyvalues </a> </h3>
<pre>

  When specifying a recordnumber or a cell number with the  
  /record,/eq,/ge,/gt DIX will convert the text to a number.

</pre>
<a name="31">
<h3 Align=center><a href="dix_help_idx_3.html#21" target="index">DIX FILETYPE_SUPPORT INDEXED_FILES </a> </h3>
<pre>

  For INDEXED files the record selection is based on the 
  /EQ or /GE or /GT or /LE or /LT and the /KEY qualifier.
  If the key has Ascending attributes, the /EQ, /GE or /GT qualifiers 
  must be used, and if the key is descending, the /EQ, /LE or /LT qualifiers.
  Information about the keytypes can be obtained via the /INFO qualifier.

</pre>
<a name="32">
<h3 Align=center><a href="dix_help_idx_4.html#29" target="index">DIX FILETYPE_SUPPORT INDEXED_FILES /RECORD </a> </h3>
<pre>
  /RECORD=nr
  
  You can specify the starting record number. You can also use the /key 
  to go to the 'n'th record on key 'key'.

</pre>
<a name="33">
<h3 Align=center><a href="dix_help_idx_4.html#30" target="index">DIX FILETYPE_SUPPORT INDEXED_FILES /KEY </a> </h3>
<pre>
  /KEY=nr

  Look for the keyvalue on the specified key. Default is the
  primary key (0).
  If none of the LT,LE,EQ,GE,GT options is specified, the program
  will start with the first record on the specified key.

</pre>
<a name="34">
<h3 Align=center><a href="dix_help_idx_4.html#31" target="index">DIX FILETYPE_SUPPORT INDEXED_FILES /LT </a> </h3>
<pre>
  /LT=value

  Look for a record with keyvalue LT the specified value.
  Information about the keytypes can be obtained via the /INFO qualifier.
  The values will be converted by DCL to Uppercase, unless enclosed in
  quotes. See also the help about keyvalues.
  If DIX is in case_sensitive mode, DIX will not upcase the value.
  See the help about "set case "

</pre>
<a name="35">
<h3 Align=center><a href="dix_help_idx_4.html#32" target="index">DIX FILETYPE_SUPPORT INDEXED_FILES /LE </a> </h3>
<pre>
  /LE=value

  Look for a record with keyvalue LE the specified value.
  Information about the keytypes can be obtained via the /INFO qualifier.
  The values will be converted by DCL to Uppercase, unless enclosed in
  quotes. See also the help about keyvalues.
  If DIX is in case_sensitive mode, DIX will not upcase the value.
  See the help about "set case "

</pre>
<a name="36">
<h3 Align=center><a href="dix_help_idx_4.html#33" target="index">DIX FILETYPE_SUPPORT INDEXED_FILES /EQ </a> </h3>
<pre>
  /EQ=value

  Look for a record with keyvalue EQ the specified value.
  The values will be converted by DCL to Uppercase, unless enclosed in
  quotes.   See also the help about keyvalues.
  If DIX is in case_sensitive mode, DIX will not upcase the value.
  See the help about "set case "
</pre>
<a name="37">
<h3 Align=center><a href="dix_help_idx_4.html#34" target="index">DIX FILETYPE_SUPPORT INDEXED_FILES /GE </a> </h3>
<pre>
  /GE=value

  Look for a record with keyvalue GE the specified value.
  Information about the keytypes can be obtained via the /INFO qualifier.
  The values will be converted by DCL to Uppercase, unless enclosed in
  quotes. See also the help about keyvalues.
  If DIX is in case_sensitive mode, DIX will not upcase the value.
  See the help about "set case "
</pre>
<a name="38">
<h3 Align=center><a href="dix_help_idx_4.html#35" target="index">DIX FILETYPE_SUPPORT INDEXED_FILES /GT </a> </h3>
<pre>
  /GT=value

  Look for a record with keyvalue GT the specified value.
  Information about the keytypes can be obtained via the /INFO qualifier.
  The values will be converted by DCL to Uppercase, unless enclosed in
  quotes. See also the help about keyvalues.
  If DIX is in case_sensitive mode, DIX will not upcase the value.
  See the help about "set case "

</pre>
<a name="39">
<h3 Align=center><a href="dix_help_idx_4.html#36" target="index">DIX FILETYPE_SUPPORT INDEXED_FILES Keyvalues </a> </h3>
<pre>

  When specifying a keyvalue with /lt,/le,/eq,/ge,/gt the program
  will check for the keytype (in the file). For binary keytypes
  the program will convert the data from ASCII to binary.
  For string types you can enter binary values via the %DD syntax
  where DD are hexadecimal digits (%% will enter one %).
  See the conversion options below
</pre>
<a name="40">
<h3 Align=center><a href="dix_help_idx_5.html#39" target="index">DIX FILETYPE_SUPPORT INDEXED_FILES Keyvalues INT2_conversion </a> </h3>
<pre>

  INT2 values can only be specified as integers.

</pre>
<a name="41">
<h3 Align=center><a href="dix_help_idx_5.html#40" target="index">DIX FILETYPE_SUPPORT INDEXED_FILES Keyvalues INT4_conversion </a> </h3>
<pre>

  INT4 values can be specified in 3 ways
   1. A normal integer.
   2. A number with another radix in two formats 
          'DDDD'F with F : X (headecimal), O(Octal), D(decimal), B(inary) or Rn[n]
       or %Fddddd with F:  X (headecimal), O(Octal), D(decimal) or B(inary) 
   3. A Date which will be converted to DATE*4 format.
   4. A OpenVMS Identifier
   5. A UIC e.g. [SYSTEM]
   6. An Ascii string "ABCD"
</pre>
<a name="42">
<h3 Align=center><a href="dix_help_idx_5.html#41" target="index">DIX FILETYPE_SUPPORT INDEXED_FILES Keyvalues INT8_conversion </a> </h3>
<pre>

  INT8 keyvalues can be specified in 3 ways
   1. One big integer up to 18 characters
   2. Two INT4 values separated by a . (e.g. 10.20, see INT4 conversion)
      (e.g. SYSTEM.1-jan-1991)
   3. A date string( e.g. 1-apr-1991).

</pre>
<a name="43">
<h3 Align=center><a href="dix_help_idx_3.html#22" target="index">DIX FILETYPE_SUPPORT VFC_FILES </a> </h3>
<pre>

  A VFC file is a sequential file with a fixed prefix. You will normally
  see this type of file from the DCL OPEN statement. This will generate
  a VFC file with a 2 byte header, that is used for carriagecontrol.
  But you can also create your own VFC file with other sizes (up to 255)
  for other meanings.

  DIX will display the data from the normal record  in one window, 
  and the VFC data in another (in screen mode), or lets you
  display the data via EXAMINE/VFC (in interactive mode).
  The filemode can also display the data when you specify
  /DISPLAY=(all) or /DISPLAY=VFC (see the help about [DIX/help] "/DISPLAY")

  The DEPOSIT/VFC will change data in VFC buffer (in interactive mode)
  and the PF1-Y command switches from normal data to VFC data in screen mode.

</pre>
<a name="44">
<h3 Align=center><a href="dix_help_idx_2.html#5" target="index">DIX DISPLAY_MODES </a> </h3>
<pre>

  DIX can work either in RAW dump format or INTERPRETED 
  (see the /DESCRIPTION qualifier).

</pre>
<a name="45">
<h3 Align=center><a href="dix_help_idx_3.html#24" target="index">DIX DISPLAY_MODES RAW_DUMP </a> </h3>
<pre>
 
  In the RAW dump mode the dump is equal to the OpenVMS DUMP format. 
  It is used if no description file can be found, or if the /RAW
  qualifier is specified.

  The display is split into two parts. 
  The left part is the data (byte,word,longword) in decimal or hexadecimal. 
  The right part is the data in ASCII (if printable).
  
  In RAW dump mode the following qualifiers can be used.

</pre>
<a name="46">
<h3 Align=center><a href="dix_help_idx_4.html#40" target="index">DIX DISPLAY_MODES RAW_DUMP /BYTE </a> </h3>
<pre>
  The data will be dumped in bytes. See also the /WORD and /LONG and /UNSIGNED.

</pre>
<a name="47">
<h3 Align=center><a href="dix_help_idx_4.html#41" target="index">DIX DISPLAY_MODES RAW_DUMP /WORD </a> </h3>
<pre>
  The data will be dumped in words. See also the /BYTE and /LONG and /UNSIGNED.

</pre>
<a name="48">
<h3 Align=center><a href="dix_help_idx_4.html#42" target="index">DIX DISPLAY_MODES RAW_DUMP /LONG </a> </h3>
<pre>
  The data will be dumped in longwords. See also the /BYTE and /WORD and /UNSIGNED.
  This is the default.

</pre>
<a name="49">
<h3 Align=center><a href="dix_help_idx_4.html#43" target="index">DIX DISPLAY_MODES RAW_DUMP /UNSIGNED </a> </h3>
<pre>
  The data (if not in HEX mode) will be interpreted as unsigned.

</pre>
<a name="50">
<h3 Align=center><a href="dix_help_idx_4.html#44" target="index">DIX DISPLAY_MODES RAW_DUMP /HEX </a> </h3>
<pre>

  Display the data in HEXadecimal (default).
  See also the /HEX,/BINARY,/OCTAL,/DECIMAL qualifier.
</pre>
<a name="51">
<h3 Align=center><a href="dix_help_idx_4.html#45" target="index">DIX DISPLAY_MODES RAW_DUMP /DECIMAL </a> </h3>
<pre>
  
  Display the data in DECIMAL
  See also the /HEX,/BINARY,/OCTAL qualifier.

</pre>
<a name="52">
<h3 Align=center><a href="dix_help_idx_4.html#46" target="index">DIX DISPLAY_MODES RAW_DUMP /OCTAL </a> </h3>
<pre>
  Display the data in OCTAL.
  See also the /HEX,/BINARY,/DECIMAL qualifier.
</pre>
<a name="53">
<h3 Align=center><a href="dix_help_idx_4.html#47" target="index">DIX DISPLAY_MODES RAW_DUMP /BINARY </a> </h3>
<pre>
  Display the data in BINARY. 
  See also the /HEX,/OCTAL,/DECIMAL qualifier.

</pre>
<a name="54">
<h3 Align=center><a href="dix_help_idx_3.html#25" target="index">DIX DISPLAY_MODES INTERPRETED_DUMP </a> </h3>
<pre>
  
  In the interpreted mode, the program will try to display the fields
  of a record. This mode requires a description file (see the /DESCRIPTION)
  This is the default if a description can be found.
  Descriptions can be in files (default 'filename'.DES) or a text library.

  DIX will look for a description file in the same directory as the data file
  DIX will look for a file in the current directory.
  DIX will look for a module in the DIX_DES .TLB file (system_library)
     (see the help for the [DIX/help] "/SYSTEM_LIBRARY" qualifier)
  DIX will look for a module in the DIX_DES_USER .TLB file(user_library)
     (see the help for the [DIX/help] "/USER_LIBRARY" qualifier)
  For details see /DESCRIPTION.

  If no description can be found (at you did not specify /NODES) , 
   DIX will load a default description
	union
	  map
	    bytearr*(32765) $bytes
	  end map
	  map
	    character*32765 $line
	  end map
	  map
	    character $chars(32765)
	  end map
	end union
   You can reference (part of) these fields, but DIX will not display 
    the fields with the examine command or screen mode display
    DIX&GT;say Examine      Will display in raw mode
    DIX&GT;Say $line        Will display the field $line
    DIX&GT;say $line{10:20} Will display elements 10:20 of $line   
</pre>
<a name="55">
<h3 Align=center><a href="dix_help_idx_4.html#49" target="index">DIX DISPLAY_MODES INTERPRETED_DUMP /ALL </a> </h3>
<pre>
   
   If the /ALL is given, all matching descriptions will be used.
   If /ALL is not given, only the first match will be used.

   The search order is
   1. The .DES file in the same directory as the datafile
   2. The .DES file in the current directory
   3. Entries in USERlibrary (if present)
   4. Entries in SYSTEMlibrary (if present)


</pre>
<a name="56">
<h3 Align=center><a href="dix_help_idx_4.html#50" target="index">DIX DISPLAY_MODES INTERPRETED_DUMP /DESCRIPTION </a> </h3>
<pre>
  /DESCRIPTION[=name[,name]]

  Give the name of a record description file(s) or module. 
  The format of description file/module is described in the RECORD_FORMAT help.
  If the /DESCRIPTION qualifier is given without the filename, the program will 
  look for a file with a filename as the input file, but with the extension 
  .DES. DIX also searches the Text library DIX_DES (with default file 
  "IMAGE_DIRECTORY".TLB), so the textlibrary will be searched
  in the same directory as the DIX image (but you can redefine the 
  logical name DIX_DES to any textlibrary) for a module with the name that
  matches the filename of the datafile. A match can be on device, directory,
  name and extension. This key may define multiple fields separated by a |.
  If there are multiple field, any field may match.
  DIX also supports a userdefined library. DIX searches for the file
  DIX_DES_USER  with default SYS$LOGIN:.TLB.

  Normally DIX will stop as soon as a match is found, but if /ALL is given
  all matching descriptions will be used.

  Example:
  DIX MYDEV:[MYDIR]MYDATA.MYEXTENSION [/DES] 
  1.  DIX searches in the current directory for the file MYDATA.DES
  2.  DIX searches for a description file MYDEV:[MYDIR]MYDATA.DES
  3.  DIX searches DIX_DES_USER.TLB for a module that matches the name 
      mydev:[mydir]mydate.myextension. Empty parts of the module name match.
      So a module with the name *MY* , .MYEXTENSION, *:[*]*.* will all match.
  4.  DIX searches DIX_DES.TLB for a module that matches the name 
      mydev:[mydir]mydate.myextension. Empty parts of the module name match.
      So a module with the name *MY* , .MYEXTENSION, *:[*]*.* will all match.
  
  The first or all (/ALL specified) matches will be loaded and can be used.
 
   Example for multiple fields

   Suppose the key is ".BCK|.SAV". This description will match files
   *.BCK and *.SAV.
   
   To insert a module in one of the text libraries you can f.e. use :

   $LIBRARY/REPLACE DIX_DES.TLB backupdes.txt/MODULE=".BCK|.SAV"
</pre>
<a name="57">
<h3 Align=center><a href="dix_help_idx_2.html#6" target="index">DIX Views </a> </h3>
<pre>

 DIX can use Views. A View is a way to connect multiple records in 
  multiple files to a single entity. With DIX you can display
  and modify the accumulated data as one record.

  A view is a module in the DIX_des.tlb file (or a text file) that contains
  instructions to build the record from the various records in various files.
  The name of the module is "VIEW#view_name". The syntax of "view_name" is
  the same as that of the description records. In the examples is a view
  for a directory entry. The description has the module name ".DIR" and the
  view has the module name "VIEW#.DIR"
  If you use a file, the default file type is ".VIEW".

 You can open a file with a view. Is this view you can select fields from
  this (first) file (FIELD statement) , and you can ask DIX to follow links 
  to other records in the same or other files (the FOLLOW/BACK statement).

 In order to use a file in a view, it should have a description, since views
  reference fieldnames via the FIELD statement, but if you do not have
  a description you can still use the RANGE command.

 If you start DIX, you may specify the /VIEW[=namemask] after the file you
  want to "DIX". You can also use the /follow qualifier to create a 
  simple "follow all" view. See the help about /follow

 DIX does support modification of views, but only in a limited way.
  The fields that may be modified must have all of the following
    a. Be fixed AND
    b. Not change the link to another file/record

  This restriction may be lifted in a future release.

</pre>
<a name="58">
<h3 Align=center><a href="dix_help_idx_3.html#27" target="index">DIX Views examples </a> </h3>
<pre>

  Below are some examples of views.

</pre>
<a name="59">
<h3 Align=center><a href="dix_help_idx_4.html#53" target="index">DIX Views examples example_dir </a> </h3>
<pre>

  The following example is the view for a directory entry, and all of the
  fileheaders up to the [000000] directory. The view will only display the
  name fields in the fileheaders. 

        field verslim			!examine the version limit
        field name			!examine the name 
        follow v(1).fileid  		!follow the link to the fileheader 
					!of the file
        loop				!loop
          field *_filename		!examine the name in ods_5 part
          field fnam 			!and in ods-2 part
	test (file_id &LT;&GT; backl_fid)	!stop if fid=backl_fid
          follow backl_fid              !follow link to parent
        end loop			!end of loop

   The fileheader for the 000000.dir directory has a fid of (4,4,0) and
   a back_link (to its parent directory) of (4,4,0) too.
   We assume the VIEW#.DIR module in the DIX_des.tlb file exists and
    contains the above lines.

   $DIX/FILE/COUNT=1 ALPHA.dir/view
   %Info:Recordnumber = 1 , Recordsize = 84 , RFA = (1,0)
     0|VERSLIM|none                     !from the directory entry
     2|NAME   |DIX_AUTOSAVE_LIBRARY.OBJ	!from the directory entry
    27|FNAM   |DIX_AUTOSAVE_LIBRARY     !file header of the .obj file
    47|FNAM   |ALPHA.DIR;1              !file header of its directory
    67|FNAM   |DIX.DIR;1                !"  "    "      "
    87|FNAM   |PROGRAMS.DIR;1           !"  "    "      "
   107|FNAM   |STUBBF.DIR;1             !"  "    "      "
   127|FNAM   |000000.DIR;1             !File header of the 000000.dir file

</pre>
<a name="60">
<h3 Align=center><a href="dix_help_idx_4.html#54" target="index">DIX Views examples example_cross </a> </h3>
<pre>

   An example for a set of three files that make a simple cross_ref
   system.

  The first file (CROSS_REF.CRF_FILE_NAMES) has the following description
  (.CRF_FILE_NAMES in the system or user textlibrary)
          integer*2    file_nr                          !primary key
          character*60 file_name

  The second file (CROSS_REF.CRF_MOD_NAMES) has the following description
  (.CRF_MOD_NAMES in the system or user textlibrary)
          integer*2    mod_nr                           !primary key
          character*32 mod_name
          integer*2    file_nr/file=.crf_file_names	!link to the filename

  The third file (CROSS_REF.CRF_CROSS) has the following description
  (.CRF_CROSS in the system or user textlibrary)
          integer*2    caller_nr /file=.crf_mod_names   !link to modulename
          integer*2    called_nr /file=.crf_mod_names   !link to modulename

  We can define a view for the .CRF_CROSS file (either in f.e. the 
   cross_ref.view file or in the VIEW#.CRF_CROSS module in DIX_def.tlb)
   (We assume that above named descriptions are in the DIX_des.tlb file)
   $DIX/file/count=1 cross_rec.crf_cross/view

    field caller_nr		!examine the value of caller_nr
    follow caller_nr            !follow the link to .crf_mod_names
    gosub do_common             !common code for caller_nr and called_nr
    field called_nr		!examine called_nr
    follow called_nr            !follow the link
    gosub do_common             !common code
    exit                        !all done

    do_common:
      field mod_name		!examine the name of the module
      follow file_nr            !follow the link to the filename in .crf_file
      field file_name             !examine the filename
      back                      !pop back to the .crf_mod_names
      back                      !pop back to the .crf_cross
    return

   The result will be something like

   %Info:Recordnumber = 1 , Recordsize = 4 , RFA = (4,1)
     0|CALLER_NR|1              !from the cross.crf_cross file
     2|MOD_NAME |DIX            !from the .mod_names file
    34|FILE_NAME|DIX_MAIN.FOR   !from the .file_names file
    94|CALLED_NR|2              !from the .cross.crf_cross file
    96|MOD_NAME |DIX_MAIN       !from the .mod_names file
   128|FILE_NAME|DIX_MAIN.FOR   !from the .file_names file
 
  Another example for the command line /follow qualifier

   $DIX/file/count=1 cross_rec.crf_cross/follow=(end,skip)
   %Info:Recordnumber = 1 , Recordsize = 4 , RFA = (4,1)
     0|CALLER_NR|1
     2|CALLED_NR|2
     4|MOD_NAME |DIX
    36|FILE_NR  |1
    38|FILE_NAME|DIX_MAIN.FOR
    98|MOD_NAME_|DIX_MAIN
   130|FILE_NR_1|1
   132|FILE_NAME|DIX_MAIN.FOR

  the /follow=(end,skip) means :
    First display all fields of the record and then follow all 
     links in a record and skip key fields

    So the display is created as:
     1: display the fields in .crf_cross (CALLER_NR and CALLED_NR)
       2: Follow the link in CALLER_NR to the .crf_mod_names file
         3: display the fields in .crf_mod_name record with mod_nr=1
          (we do not display the MOD_NR field since the skipkey is given)
           4: Follow the link in FILE_NR to the .crf_file_names
           5: Display the fields in .crf_file_names record with FILE_NR=1
            (we do not display the FILE_NR field since the skipkey is given)
       7: Follow the link in CALLED_NR to the .crf_mod_names file
         8: display the fields in .crf_mod_name record with mod_nr=1
            (we do not display the MOD_NR field since the skipkey is given)
           9: Follow the link in FILE_NR to the .crf_file_names
          10: Display the fields in .crf_file_names record with FILE_NR=1
            (we do not display the FILE_NR field since the skipkey is given)
                         
</pre>
<a name="61">
<h3 Align=center><a href="dix_help_idx_3.html#28" target="index">DIX Views Syntax_for_view </a> </h3>
<pre>

  A view file/module is a text file.
   It may contain the following statements

   - All the control command from interactive mode
          (if/loop/while/case...) including the gosub/return 
           but not the @ or CALL statements.
   - FOLLOW   statement to follow the link to another file 
   - BACK     statement to return to the previous file(level)
   - FIELD    to include fields.
   - RANGE    To include a range of bytes(can be useful if you have no description)
   - OPEN     To open files used to follow the fields. The open is only
              needed if you need to specify file open options others than
              the default options from the follow command (f.e. the description)
   - ECHO     To display comments to the terminal while expanding
   - EXIT     statement
   - symbol assignments

   For all the statements (except the FIELD and RANGE ) the help can be 
   found in the help about interactive mode.
   See also the examples

</pre>
<a name="62">
<h3 Align=center><a href="dix_help_idx_4.html#56" target="index">DIX Views Syntax_for_view FIELD_SYNTAX </a> </h3>
<pre>

  If you want to use the FIELD command, the file must have a description
  
  FIELD[/follow=follow_type][/skipkey][/readonly][/new_name=name] -
          [/quiet] fieldnamemask

  The qualifiers have the following meaning
   /readonly     : Declares the field readonly(if the field is not yet readonly). 
   /follow=type  : Let DIX automatically follow all link fields
                   type can be 
                      begin : first display the follow fields (and follow them)
                              and then the normal fields
                      end   : first display the normal fields and then
                              the follow fields (and folow them)
                      field : Display the follow fields and follow the
                              link immediately.
   /skipkey      : If /follow is used, this will suppress the keyfields
                    of the followed field, since they will already be
                    displayed in the current field
   /new_name=name: You may override the original name.
                    If the new_name ends with a . ,the original name is
                    appended to the  new_name
   /quiet          If mask does not match any field, DIX will signal a message
                    If you specify /quiet, DIX will not complain

   For an example see the help for the /follow qualifier

   The qualifiers must be specified before the fieldnamemask.
   Fieldnamemask is a wildcard mask to select fields of the current description

</pre>
<a name="63">
<h3 Align=center><a href="dix_help_idx_4.html#57" target="index">DIX Views Syntax_for_view RANGE_SYNTAX </a> </h3>
<pre>

  The RANGE command may be used whether or not the file has a description

   RANGE[/READONLY][/quiet][/name=name]  bpos:[epos]              !epos is default equal to bpos

   /readonly       : Set the field to readonly(if the file is not yet readonly).
   /quiet          : If mask does not match any field, DIX will signal a message
                      If you specify /quiet, DIX will not complain
   /name=name      : Set the name (default=B_'BPOS'_'EPOS')
   /type=fieldtype : Set the fieldtype (default is BYTEARR)
                  
   Include bytes bpos up to and including epos
   If you do not specify epos, DIX will take the default size for the 
    selected fieldtype. If you do specify epos, the size (epos-bpos+1)
    must be valid for the selected type
    so  "RANGE /type=integer 0:9" will be invalid, since INTEGER*10 is not
    supported.
    and "RANGE /TYPE=INTEGER 12" will insert an INTEGER*4 (the default)

</pre>
<a name="64">
<h3 Align=center><a href="dix_help_idx_2.html#7" target="index">DIX Contents_of_dix_des.tlb </a> </h3>
<pre>

  Originally DIX_DES.TLB and DIX_DES_USER.TLB were designed to store 
  record definitions (descriptions). In a later phase VIEWS were added.
  To discriminate between views and normal definitions the modulenames of the 
  views (in the .TLB) files are preceeded by VIEW#. So a view with a name 
  .DIR is stored in de .TLB file with a key VIEW#.DIR and the record definition
  for the same file with key .DIR.

  Later the same technique was used to store DEMO files (DEMO#...)
  Since DIX 8.3 DIX can lookup a lot of things in .TLB files so this concept
  has been enhanced. Now the following types of data can be stored in .TLBs
 
  Supose the name of the object is MYNAME

  Prefix  Type

  None    The normal record definitions 
  VIEW#   The view descriptions to be used via the /VIEW=MYNAME
  DEMO#   The DEMO files to be called in the dix/demo mode
  FUNC#   Function definitions  to be used via the LOAD/FUNC MYNAME
  PARM#   Parameter definitions to be used via LOAD /MODULE=MYNAME
  PROC#   Command scripts       to be called like @MYNAME@ 
  STRU#   Structure definitions to be used via load/structure MYNAME

  You can store the definitions yourself via the (example for parameter file)

  $LIBRARY/INSERT DIX_DES_USER.TLB myparam.txt/module="PARM#MYPARAMS"

  and then use if via the 

  DIX&GT; LOAD /modu=MYPARAMS    !Dix will search SYS$LIBRARY:STARLET.MLB
                              !and SYS$LIBRARY:FORSYSDEF.TLB (if is exists)
                              ! for the module MYNAME
                              !and DIX_DES_USER (the user des file, if it exists)
                              !and DIX_DES , the normal description file
                              ! for the module PARM#MYNAME

</pre>
<a name="65">
<h3 Align=center><a href="dix_help_idx_2.html#8" target="index">DIX RECORD_FORMAT_FOR_DESCRIPTIONS </a> </h3>
<pre>

  The description records are in normal ASCII, and can be edited with
  a normal editor. Lines starting with C,c or * are skipped 
  (fortran comment lines) and data after the ! (comment) is skipped. 
  Continuation lines are not like the normal FORTRAN syntax but use the 
  DCL syntax (- at the end of the line)
  Spaces are ignored, except within names and types and between the type
  and its qualifier.
  Single lines can be up to 255 chars, and the total line length (including
  continuation lines) can be up to 4096 chars.
     
  There are 6 types of lines
  
  -Parameter,value &AMP;type  definitions
  -Conditional statements
  -Extra statements
  -Field Declarations.
  -Control Statements
  -Macro definitions  

  During the reading of the description, DIX may use symbol substitution.
  See the "INTERACT SET SUBST" help topic.

</pre>
<a name="66">
<h3 Align=center><a href="dix_help_idx_3.html#31" target="index">DIX RECORD_FORMAT_FOR_DESCRIPTIONS Macros </a> </h3>
<pre>
  DIX supports macros. A macro starts with the 
   #MACRO NAME [PARAM1 [PARAM2] ...] statement and ends with a
   #ENDMACRO statement

  Macros can be used to repeat a number of lines.
  Inside the macro you specify param1 and param2 by
  'param1' and 'param2'. 

  Upto 16 parameters are supported, and macro calls can
  be nested to a depth of 64

  Example
   A definition of an ACMS file

  ....

  integer*2   menu_offs
  ubyte       menu_leng 
  range      (menu_offs: menu_offs+menu_leng)
   character*(menu_leng) menu
  end range

  integer*2   mdb_offs
  ubyte       mdb_leng 
  range      (mdb_offs: mdb_offs+mdb_leng)
   character*(mdb_leng) mdb
  end range

  integer*2   init_appl_offs
  ubyte       init_appl_leng 
  range      (init_appl_offs: init_appl_offs+init_appl_leng)
   character*(init_appl_leng) init_appl
  end range

  .....

  Above description contains a lot of simular statements. 
  They can be replaced by
  ....
 #macro item name			!define a macro first
  integer*2   'name'_offs		!it contains one parameter
  ubyte       'name'_leng               !name. During expansion 
  range      ('name'_offs: 'name'_offs+'name'_leng)
    character*('name'_leng) 'name'      !'name' will be replaced by
  end range                             !the actual argument
 #endmacro                              !(it may be empty)

  item menu  	  	!call the macro and replace 'name' by menu
  item mdb	  	!call the macro and replace 'name' by mdb
  item init_appl	!call the macro and replace 'name' by init_appl

 ....

</pre>
<a name="67">
<h3 Align=center><a href="dix_help_idx_3.html#32" target="index">DIX RECORD_FORMAT_FOR_DESCRIPTIONS PARAMETER|VALUE|TYPE_DEFINITIONS </a> </h3>
<pre>

  With the parameter definition, you can define parameter values,
  that can be used later in other parameter definitions, or in
  field declarations.
  Syntax: 
 
     PARAMETER [(]name=expression[,name=expression] [)]
     VALUE     [(]name=expression[,name=expression] [)]
     TYPE      name=expression

  PARAMETER's may only be defined once in a description,
  VALUE's may occur multiple times in a description 
  TYPE'S may be used for fieldnames. See below


  All can be referenced, but none can be updated in interactive mode.

   The expression is first evaluated at read time. If this fails
   (f.e. because of dependencies on field data), DIX will retry the
   evaluation at expand time (when the record data is present)
   You may not redefine a parameter within a description, but you
   may redefine a value

  examples :
  
   PARAMETER VALUE1 = 121           Will be evaluated at read time
   PARAMETER VALUE2 = (VALUE1*4+12) Will be evaluated at read time
   INTEGER*2 Test_field
   PARAMETER (p1=10)                Will be evaluated at read time
   PARAMETER (p2=test_field*10)     Will be evaluated at expand time
   PARAMETER (p3=F$FILE("RECORDL")) Will be evaluated at read time


  The value is evaluated as an expression.
  in the help about "interactive_commands expressions"

![Expressions]DIX INTERACTIVE_COMMAND expressions

  Parameters may also be defined globally. See the interactive command
  ADD PARAMETER. ADD VALUE, ADD TYPE and LOAD

  Example for types
   Suppose you want to have a text name for two specific values
   You could specify

     INTEGER*4 MYNUMBER [0=zero,5=five]

   But if the string is used more often you can also use

    TYPE nice_name ="0=zero,5=five"  !declare a type
    INTEGER*4 MYNUMBER [#nice_name]  !use a name starting with a #

  These types can be refenced in an  expression by
   #[\filetag[\descriptiontag]]typename"fieldname"

  Suppose the definition is in a description tith tag MYDES and a file MYFILE
  All of the below will return the value (integer) 5

   #nice_name"five"  
   #myfile\nice_name"five"  
   #myfile\mydes\nice_name"five"  

</pre>
<a name="68">
<h3 Align=center><a href="dix_help_idx_3.html#33" target="index">DIX RECORD_FORMAT_FOR_DESCRIPTIONS Conditional_statements </a> </h3>
<pre>

  You can use the symbol table to conditionally use parts of the
  description. The #IF(DEF), #ELSE, #ELSEIF and #ENDIF are available to
  dis/enable parts of the description.

  The syntax is

  #IF Logical-statement
  #IFDEF symbolname
  #ELSEIF Logical-statement
  #ELSE
  #ENDIF

  The Logical-statement is evaluated using the available DIX-symbols and
  field variables.
  You can define the symbols in interactive mode via the normal 
  assignments and in other modes via the /DEFINE=symbol qualifier

  Example (the indentation is just for visibility)

   #IF F$EXISTS("LANGUAGE")
     #IF LANGUAGE="DUTCH"
       CHARACTER*20 DUTCH_NAME
       #MESSAGE "The dutch version"
     #ELSEIF LANGUAGE="GERMAN"
       CHARACTER*20 GERMAN_NAME
       #MESSAGE "The german version"
     #ELSE
       CHARACTER*20 DEFAULT_NAME
       #MESSAGE "The default version"
     #ENDIF
   #ELSE
     CHARACTER*20 DEFAULT_NAME
     #MESSAGE "The default version"
   #ENDIF

   If you change a symbol that would affect the #IF/#ELSEIF clauses,
   you need to force DIX to re-evaluate the description.
   You can do that via EXAMINE/EXPAND 

</pre>
<a name="69">
<h3 Align=center><a href="dix_help_idx_3.html#34" target="index">DIX RECORD_FORMAT_FOR_DESCRIPTIONS Extra_statements </a> </h3>
<pre>

   #MESSAGE text     Display message during expansion
     
   #COMMENT text     Display text in the fields display

   INCLUDE 'filename[(module)]'

   LOAD file[/module]

   #INSERT NAME [expression]

     Add fieldnames with values computed from other fields. THis fields
     will be displayed with offset "blank" , and cannot be modified.
     The expression can contain fields,parameters,values from the description, 
     but not symbols, global values/parameters.

    Example:
     In the indexf description, the ODS2 filename is split in two parts.
     at offset 82 are the first 20 character of the filaname (field FNAM)
     and at offset 134 the last 66 characters (field REST_FNAM)
     You could specify:
      #INSERT TOTAL_FILENAME [FNAM+REST_FNAM]
     
      And DIX would add a field with the name TOTAL_FILENAME and as contents
       the total filename (all 86 characters). THis fieldname can be used
       and displayed in expressions.
       If you f.e. specified #INSERT TOTAL_FILENAME [F$TRIM(FNAM+REST_FNAM)]
        DIX would trim the trailing blanks

</pre>
<a name="70">
<h3 Align=center><a href="dix_help_idx_4.html#64" target="index">DIX RECORD_FORMAT_FOR_DESCRIPTIONS Extra_statements INCLUDE </a> </h3>
<pre>
  
  This allows you to include a file (or a module in a file)
  Since this is a typical fortran statement, fortran defaults are used

  formats

   INCLUDE 'filename'        Include a file, default filename = sys$disk:[].for
   INCLUDE '(module)'        Include a module from a file, default library
                             is SYS$LIBRARY:FORSYSDEF.TLB
   INCLUDE 'library(module)' Include a module from a file, in .tlb file library

   Form this file /module ONLY the parameters will be loaded
    See also the help about interactive mode LOAD

</pre>
<a name="71">
<h3 Align=center><a href="dix_help_idx_4.html#65" target="index">DIX RECORD_FORMAT_FOR_DESCRIPTIONS Extra_statements LOAD </a> </h3>
<pre>

   LOAD file                  Include a file, default filename = sys$disk:[].txt
   LOAD library/module=modnam Include module from a library. the library
                              will be searched witrh a default name of
                                SYS$LIBRARY:STARLET.MLB and it that fails
                                SYS$LIBRARY:FORSYSDEF.TLB 

   Form this file /module ONLY the parameters will be loaded
    See also the help about interactive mode LOAD

</pre>
<a name="72">
<h3 Align=center><a href="dix_help_idx_4.html#66" target="index">DIX RECORD_FORMAT_FOR_DESCRIPTIONS Extra_statements #MESSAGE </a> </h3>
<pre>
  You can include the #MESSAGE statement in the description

  #MESSAGE text

  The text will be displayed via a message when the expander finds
  this statement. This can be useful with the #IF constructs 
  see example below.
 
  declaration statement
  declaration statement
  ...
  #IF F$EXISTS("_DEBUG")
   #MESSAGE Debug variant
   integer*4 temp
  #ELSE
   integer*4 temp /nodisplay
  #ENDIF

  IF the symbol debug is defined the value of temp will be displayed
  and during the expansion of the descriptions the message "Debug variant"
  will be displayed on the terminal
  If the symbol debug is not defined, the value of temp will NOT be 
  displayed and no message will occur.

</pre>
<a name="73">
<h3 Align=center><a href="dix_help_idx_3.html#35" target="index">DIX RECORD_FORMAT_FOR_DESCRIPTIONS #COMMENT </a> </h3>
<pre>
  #COMMENT text

   This statement can be used in a description or a view

   The text will be displayed with the examine command
   You can use this to separate parts of the description or 
     in a view parts from different files

  Example (for a view)

        field verslim			!examine the version limit
        field name			!examine the name 
        #comment ============To fileheader:=============
        follow v(1).fileid  		!follow the link to the fileheader 
        loop				!loop
          field *_filename		!examine the name in ods_5 part
          field fnam 			!and in ods-2 part
	test (file_id &LT;&GT; backl_fid)	!stop if fid=backl_fid
          #comment ============Backlink:=============
          follow backl_fid              !follow link to parent
        end loop			!end of loop



</pre>
<a name="74">
<h3 Align=center><a href="dix_help_idx_3.html#36" target="index">DIX RECORD_FORMAT_FOR_DESCRIPTIONS Field_declaration </a> </h3>
<pre>

  You can use any normal fortran declaration, with some extensions

  General format

  TYPE*(SIZE)[/qualifiers] fieldname[(dim1[,dim2[,dim3]])]

  The qualifiers must be specified BEFORE the fieldname.

  The following types are supported
   The {*n} means an implied size. You may specify the size, but if you
   do not, this size is assumed. You cannot specify a different size.

  REAL_F{*4},REAL_D{*8},REAL_G{*8},REAL_H{*16}   
                     The data types are the VAX realtypes

  REAL_S{*4}, REAL_T{*8},REAL_X{*16}
                     The data types are the IEEE realtypes

  REAL*4,REAL*8,REAL*16
                     These are aliases, the actual datatype depends on
                     the size and the architecture. The default size = 4.

                     Replacement according to the following table
                               Size
                        Arch   4         8     16
                        Vax    REAL_F REAL_D REAL_H
                        Alpha  REAL_F REAL_G REAL_X
                        IA64   REAL_S REAL_T REAL_X

  COMPLEX*8, COMPLEX*16
                     The complex datatype (real,imaginary).
                      the complex*8  contains 2 real*4 values
                      the complex*16 contains 2 real*8 values
                      
  LOGICAL*nn (nn=1..128 in bitfieldmode , 1..16 in normal mode)
                     The date types are the logical data types
                      Default size = 4(bytes) in normal mode, 
                                     8(bits) in BITFIELDMODE
  RLOGICAL*nn (nn=1..128 in bitfieldmode, 1..16 in normal mode)
                     The date types are the logical data types, only the
                     value is reversed
                      Default size = 4(bytes) in normal mode, 
                                     8(bits) in BITFIELDMODE

  CHARACTER*NN or CHARACTER*(NN)
                     The data types are the character datatypes
                      Default size = 1 (byte)

  [U]INTEGER*nn (nn=1..64 in bitfieldmode, 1..8 in normal mode)
                     The data type is [un]signed integer
                      Default size = 4(bytes) in normal mode, 
                                     8(bits) in BITFIELDMODE
                      [U]BYTE     is accepted as alias for [U]INTEGER*1
                      [U]WORD     is accepted as alias for [U]INTEGER*2
                      [U]LONGWORD is accepted as alias for [U]INTEGER*4
                      [U]QUADWORD is accepted as alias for [U]INTEGER*8

  BITS*NN (nn=1..128 in bitfieldmode, 1..16 in normal mode)
                     The data structure is a bit stream, nn&LT;=8 Bytes
                      Default size = 4(bytes) in normal mode, 
                                     8(bits) in BITFIELDMODE

  RBITS*NN (nn=1..128 in bitfieldmode, 1..16 in normal mode)
                     The data structure is a bit stream, nn&LT;=8 Bytes
                      This is the same as BITS, but the meaning of each
                      bit is reversed (0 means active).
                      Default size = 4(bytes) in normal mode, 
                                     8(bits) in BITFIELDMODE

  For the integer and bits fields, you may add a list of names to make
  the display more readable, see the name_syntax help below

  DATE*4             The date structure is an internal date format =
                       #minutes since 1857 e.g. VMSdate/(10*1000*1000*60)
                       No seconds or ticks(hundredths) are allowed

  DATE*8             The date structure is a OpenVMS date format. This is
                       the default date data type.

  UDATE{*4}          The date structure is a Unix time 
                       (#seconds since 1-JAN-1970). 
                       No ticks(hundredths) are allowed

  UIC{*4}            The data structure is a UIC

  CPUTIME{*4}        The data is a 32 bits integer containing cputicks. 
                       This will be displayed as a deltatime.

  RAD50{*2}          The data is a 16 bit integer containt 3 rad50 chars

  IDENTIFIER{*4}     The data structure is an OpenVMS-identifier

  RFA{*6}            The normal RFA strecture. It contains a 2-byte 
                     record-id/byte offset and a 4 byte blocknumber. 
                     The display is (block,recid)

  BKTRFA*NN (nn=4,5,6) The datastucture is an RFA as found in the indexed
                     file buckets. It contains a 2-byte record-id/byte offset
                     and a 2-4 byte blocknumber. The display is (block,recid)

  PROTECTION{*2}     The data structure is a Protection mask.

  RINTEGER{*4}       The data is a INTEGER*4 with low and high 16 bits 
                           swapped (PDP-11 compatible format)
  FILEID{*6}         The data is a Fileid (filenr,revnr,volnr) 

  PRIVILEGE*nn       The data is a privilege mask
                     The size may be 4 or 8, the default=8
                     If the size is 8, the value is a normal OpenVMS privilege mask 
                     If the size is 4, the value is a privilege mask used for
                     functions like $chkpro (the $chpdef priv mask)
                     This type has a build-in fieldname list.

  DISKMAP            The data is an ODS-2/5 storage description found in fileheaders
                      There are 4 formats. 
                      P:dd dd   placement map
                      T:1 begin-end  8 bits count and 22 bits blocknumber(4 bytes)
                      T:2 begin-end 14 bits count and 32 bits blocknumber(6 bytes)
                      T:3 begin-end 30 bits count and 32 bits blocknumber(8 bytes)
                      If you do not specify the t:n when converting from text to
                      binary DIX will take the shortest format

  ACE                The data is the binary ACE description
                      The text must include the leading and trailing () 

  VFC{*1}            The data is interpreted as a carriagecontrol byte
                     in a DCL VFC file. See the OpenVMS docs about the layout.

  BYTEARRAY*(SIZE)   The data is a list of bytes, and the display is a
                     line with the byte values separated by a space
  String types

   STRING [*NN]      The data is a counted ascii string (count=byte)
   WSTRING[*NN]      The data is a counted ascii string (count=word)
   LSTRING[*NN]      The data is a counted ascii string (count=longword)
   ZSTRING[*NN]      The data is zero terminated string
   HSTRING[*NN]      The data is terminated by any char &GT;127 (bit 7 =1)

     If *NN is specified, the strings are variable in a fixed allocation size.
       The total allocation is NN  (HSTRING)
                               NN+1(STRING,ZSTRING) 
                               NN+2(WSTRING)  
                               NN+4(LSTRING)

     If *NN is not specified the allocation is variable also. 
     DIX can handle display and modification of variable fields, but only if
     the recordlength can be changed(indexed or relative files and not fixed)

   DECIMAL strings
   [U]DECIMAL        The data is an (unsigned) decimal string. Depending on 
                     some qualifiers the allowed data is 0..9,".",E,+,-
                     0..9 are always allowed. 
                     If the type is UDECIMAL  the + and -  are not allowed.
                     If the type specifies /fraction, the . is allowed
                     If the type specifies /exponent, the E is allowed

     For this datatype there are some extra qualifiers defined

      /ZERO_FILL       The field is filled with leading zeros. All spaces
                        will be replaced by 0.
      /FRACTION        Allow the string to contain a decimal fraction.
                        This qualifier adds the "." character to the allowed
                        character set.
      /EXPONENT        Allow the string to contain an exponent.
                        This qualifier adds the E/e and the +/- for the
                        exponent (E+12 or e-12) characters to the allowed
                        character set.
      /LEFT_JUST       IF the /ZERO_FILL is not specified, this qualifier
                        decides if a short string must be left or right 
                        justified.

  Fieldnames are strings up to 32 characters. They must start with a 
  letter (a-z), and the following character may contain a letter (a-z),
  a digit (0-9) , a $ or an _.

  Field names starting with a % and PAD fields are not displayed (fillers).
  These fields cannot be used for field-dependent computation.
  The display can also be disabled with the /NODISPLAY option, and these
  fields CAN be used.
 


 Qualifiers can be

  /HEXADECIMAL           Always display data in hexadecimal format
  /BINARY                Always display data in binary format
  /OCTAL                 Always display data in octal format
  /RADIX=nn              Always display the data in radixnn format
                         This can only be used for [u]integer fields
  /RANGE=min_val:max_val For integer values, limit the range of the value
  /NODISPLAY             Do not display data (can be referenced)
  /USER                  The type is a user defined type. See the help about
                         [DIX/help] record_for field usertypes.
  /UPPERCASE             Force conversion to uppercase on field modification
  /LOWERCASE             Force conversion to lowercase on field modification
  /LIMIT=value           If the value is reached, the repeat loop is terminated
  /LIMIT=&GT;value           If the field has a repeat, this will terminate, else
  /LIMIT=&LT;value           DIX will terminate the next structure repeat
                          See example 
  /VFC                   This field is in the VFC area (if present) of the record
  /RELATIVE              Qualifier for POSITION (see there)
  /READONLY              This field is read-only. DIX cannot modify it.
  /EBCDIC                This field contains EBCDIC data. 
                         DIX will convert to and from ASCII. This will only
                         work correctly for characters that are in
                         both character sets. 
                         You can also open the file in EBCIC mode. This
                         will automatically append a /EBCDIC to all fields
                         This conversion only takes place in char/string
                         and decimal fields.
  /DEPENDENCY            If this field changes, DIX must reexpand the description
                         since there is a dependency somewhere on this value.
  DIX allows you to mark a field as an index into another file
  To do this you need to specify at least one of the following qualifiers
  The value of the file will be used as a value for a
  key/rfa/recnr/byteoffset in the target file.
  /KEY, /RECORD, /RFA, and /BYTEOFFSET are mutually exclusive.

  /FILE=filename         Specifies that this field is a key into file 
  or                     'filename'. Default is the same file.
                         The filename can also be a fileid. See the help
                         about [DIX/help] record_format parameters.
  /FILE="expression"     If you specify the name in "", it will be 
                         interpreted as a string to be evaluated. In this
                         way you can compute the name.
  /DESCRIPTION="descr"   The explicit description used for this file.
  /KEY=keynumber         Specifies the keynumber (default=0)
  /RECORD                Specifies that the value is a recordnumber into
                         'filename'. If used on an indexed file, it will
                         read record 'computestring' on the primary key.
  /RFA                   Specifies that the value is an RFA into the target
                         file.
  /BYTEOFFSET            Specifies that the value is a byte-index into the 
                         target file (value 0 = byte 0 in block 1)
  /MATCH=LT,LE,EQ,GE,GT  Keymatch, Default is EQ search.
  /COMPUTE="compstring"  Allows you to do computation on the fieldcontents
                         the compute string must be a valid expression that
                         delivers an integer or character value to be used
                         as key(for indexed files) or record number.
  /IF="ifstring"         If specified the IFstring expression must be TRUE
                         to take this link.

  During the evaluation of the IF, COMPUTE and FILE string the normal
  symbol substitution is active, and also the special symbols
      $FILE          (the current file)
      $DESCRIPTION   (The current description)
      $FIELD         (The contents of the current field converted to text)
      $FLD           (the current field, may be any type)

  can be used (as any other symbol/function/parameter)

  See the examples for this
  See also the radix_override help below

  Any variable can be followed by a dimension description up to 3 dimensions.
  Dimension are specified as 
   high          (low=1, incr=1) or
   Low:high      (incr=1) or 
   low:high:incr incr may be negative, but then low must be &GT;= high

    The sizes and dimensions can be expressions with numbers, parameters or 
    other fieldnames in the description. If fieldnames are used, they must 
    appear before the line in which they are referenced.
    see the help about expressions

![expressions]DIX INTERACT expressions

</pre>
<a name="75">
<h3 Align=center><a href="dix_help_idx_4.html#69" target="index">DIX RECORD_FORMAT_FOR_DESCRIPTIONS Field_declaration Name_syntax </a> </h3>
<pre>

  With the (R)BITS*(*),(U)INTEGER*(*),LOGICAL*(*) and the (u)DATE*(*) 
   declarations you can append a list of names to the description to
   give a readable interpretation of the values

     There are two formats

     1. [field,field,,field...] A list of fields numbered from 0 up to nn
                                Fields may be omitted, but comma's are
                                significant. Mostly used for bits. A #
                                means do never display this bit even if set.

     2. [idx=name,idx=name,...] A list of numbered names, the indexes
                                do not have to be in order. Mostly used
                                for integers. The idx's are integer*4 only,
                                if the values are 8 bytes wide, DIX will check
                                if the high longword is a sign extension of the
                                low longword. 

     The text can also be stored in a parameter.
      if you specify [#type_name], the actual text will be searched
       in type "type_name". It must be defined earlier via the ADD TYPE command
      This can be useful if the same strings happens more than once
  
   The names (field or name) can have aliases. They are specified as
     name1;name2;name3...
   All (alias-)names can be used for text to binary translation, but only the 
    first alias will be used for binary to text translation. See example below

  Example for case 1 (the privileges in SYSUAF)

     BITS*8       UAF$Q_DEFPRIV -
         [CMKRNL,CMEXEC,SYSNAM,GRPNAM,ALLSPOOL,IMPERSONATE,DIAGNOSE,-
          LOG_IO,GROUP,NOACNT,PRMCEB,PRMMBX,PSWAPM,SETPRI,SETPRV,TMPMBX,-
          WORLD,MOUNT,OPER,EXQUOTA,NETMBX,VOLPRO,-
          PHY_IO,BUGCHK,PRMGBL,SYSGBL,PFNMAP,SHMEM,SYSPRV,BYPASS,-
          SYSLCK,SHARE,UPGRADE,DOWNGRADE,GRPPRV,READALL,-
          IMPORT,AUDIT,SECURITY]
 
      bit(0) = CMKRNL, bit(1)= CMEXEC ...

      Bits are named in order, but bits may be skipped.
      If the non-named bits are in the mask they will be displayed with
      the text "BITnn". If any bit has the name # it will not be 
      displayed (see below)
      
      A more complicated example for the bits in the file characteristics      
       in the file-header in the indexf.sys
       The longword has a lot of bits defined, but also a 2-bit field that
       contains the setting for the caching options

       First we define all normal bits, and the 2-bit field is defined
        with #, so they will not be displayed (and cannot be modified using
        the bitnames). Then we skip 24 bits back and define a 2-bit
        integer with 4 possible values, and then we skip 22 bits forward again
        Also notice the ,, after the #, this signifies an unused bit.

        BITS*4          FILE_CHAR -
                [Wascontig,Nobackup,Writeback,Readcheck,Writecheck,-
                 Contigb,Locked,Contig,#,#,,Badacl,-
                 Spool,Directory,Badblock,Markdel,Nocharge,Erase,alm_aip,-
                 shelved,scratch,nomove,noshelvable,shelv_res]

        bitfield	!start in bits mode, the next 2 bits define the caching
          position/relative (-24)     !skip back 24 bits, the /relative 
                                      !is optional since the value is negative
          integer*2 caching [writethrough,writeback,flush_on_clos,no_cache]
	  position /relative (22)     !skip the next 22 bits(in total 3 bytes)
        end bitfield	!back to non field mode again

      
  Example for case 2

     INTEGER*2 type [1=special,4=normal,10=fatal] 

      Field values 1,4,10 will be by displayed as a name, all others in
      numeric 


  Example for specification via a TYPE

   TYPE (user_type = "1=special,4=normal,10=fatal") !must be a string
   ....                                                         !scalar type

   INTEGER*2 type [#user_type]	  !reference to parameter user_type.


  Example for name aliases. 

   In the sysuaf description is the UAF$L_FLAGS field. One of the bits 
   defines if the user is allowed to login. This bit has two different names
   1. In AUTHORIZE this bit is referenced by the /[NO]DISUSER name.
   2. In the $uaidef include file this bit is called uai$m_disacnt

   So the names for UAF$L_FLAGS contains an alias for this bit
   BITS*4       UAF$L_FLAGS -
   [DISCTLY,DEFCLI,LOCKPWD,RESTRICTED,DISUSER;DISACNT,DISWELCOME,DISMAIL,NOMAIL,
    GENPWD,PWD_EXPIRED,PWD2_EXPIRED,AUDIT,DISREPORT,DISRECONNECT,AUTOLOGIN,-
    DISFORCE_PWD_CHANGE,CAPTIVE,DISIMAGE,DISPWDDIC,DISPWDHIS,DEFCLSVAL,EXTAUTH,
    MIGRATEPWD,VMSAUTH,DISPWDSYNCH,PWDMIX]

   The bit has the name DISUSER;DISACNT.
    On text to binary you may use either name (DISUSER or DISACNT).
    On binary to text DIX will use the first name (DISUSER)

</pre>
<a name="76">
<h3 Align=center><a href="dix_help_idx_4.html#70" target="index">DIX RECORD_FORMAT_FOR_DESCRIPTIONS Field_declaration SUBFIELDS </a> </h3>
<pre>

  For all fieldtypes or normal values containing multiple data, 
    RBITS,BITS,CHARACTER,xSTRING,(U)INTEGER,BYTEARRAY,COMPLEX,
    UIC,(U)DATE,DELTATIME,CPU,PROTECTION,FILEID,RFA,BKTRFA,RAD50
    
  DIX will normally display all data on one line, and 
  lets you examine/modify the whole structure in one time.

  Sometimes it may be useful to specify a specific subfield of the whole
  structure. Below is a table of transformation
  
  Subfields can be used  with the 
    a. examine command (fieldnames)
        This will display a multiple line display with each subfield
        on a separate line.
   b. Evaluation of fieldnames/symbols.
        This will deliver a table containing the subfield values
    

  For the following type you can only specify a bit/bytenumber

   CHARACTER,xSTRING  byte-size character 1..len(string)
   BYTEARRAY          byte-size byte      1..len(bytearray)
   (U)INTEGER         one-bit integer     0..#bits-1
   RAD50              byte-size character 1..3
  
  For the following types you can specify a list of bit values via the
  fieldnames construct [name1,name2,name1]

   RBITS              LOGICAL
   BITS               LOGICAL

  The following fields have predefined subfields

   U(DATE)            Integer  YEAR,MONTH,DAY,HOUR,MINUTE,SECOND,HUNDREDTH
   DELTATIME,CPU      Integer  DAY,HOUR,MINUTE,SECOND,HUNDREDTH 
   PROTECTION         Integer  SYSTEM,GROUP,OWNER,WORLD
   FILEID             Integer  FILENR,REVISION,VOLUME
   RFA                Integer  BLOCK,OFFSET
   BKTRFA             Integer  RECID,BUCKET
   PRIVILEGE[*8]      Logical  The normal 39 privilege names
   PRIVILEGE[*4]      Logical  The 12 privileges in the audit log
   COMPLEX            Real     REAL,IMAG

   You may specify a list of either
     a. subfield name masks (between "")
        If the name mask does not contain a wildcard (* or %), DIX will
         match the beginning of the keyword, this may match more than one name. 
        If the name mask does contain a wildcard, DIX will select all names
         matching the wildcard.
   or
     a. element numbers
     b. ranges like 1:4
     c. ranges with stride like 1:5:2 or 5:1:-2
   
   Suppose you have define the following fields

   RBITS*7 UAF$B_PRIMEDAYS -    !value=[t,t,t,t,t,f,f]
          [MONDAY,TUESDAY,WEDNEDSAY,THURSDAY,FRIDAY,SATURDAY,SUNDAY]
   CHARACTER*32 UAF$T_ACCOUNT	!value=TACV

   You can now specify

   UAF$B_PRIMEDAYS{"*T*"} to reference the three one-rlog values 
      514.1|UAF$B_PRIMEDAYS{TUESDAY} |True
      514.3|UAF$B_PRIMEDAYS{THURSDAY}|True
      514.5|UAF$B_PRIMEDAYS{SATURDAY}|False

   UAF$T_ACCOUNT{3:5,1}
      54.0|UAF$T_ACCOUNT{3}|C
      55.0|UAF$T_ACCOUNT{4}|V
      56.0|UAF$T_ACCOUNT{5}|
      54.0|UAF$T_ACCOUNT{1}|T

  But also "TEST"{*} will deliver a table of 4 characters
      and  10{*} will deliver a table of 32 bits (if integersize=4)
    
  The syntax between the {} is
    "*XYZ*": a mask. This only works on fields with fieldnames defined
    "AB"   : Match all names beginning with AB
    "*"    : All elements with a fieldname
    *      : All elements
    4-5    : Element 4..5   
    4-*    : element 4..end_of_field
    *-4    : element begin_of_field..4
    12     : Element 12 only
    1:5:2  : Element 1,3 and 5.
    5:1:-2 : Element 5,3 and 1

  Subfields can be used on fields (you may use the fieldvalue names)  
  or normal symbol values 
  
</pre>
<a name="77">
<h3 Align=center><a href="dix_help_idx_5.html#76" target="index">DIX RECORD_FORMAT_FOR_DESCRIPTIONS Field_declaration SUBFIELDS examples_examine </a> </h3>
<pre>
 
   a byte wide integer

   DIX&GT;exa UAF$B_RTYPE
     0.0|UAF$B_RTYPE|1
   DIX&GT;exa UAF$B_RTYPE{*}
     0.0|UAF$B_RTYPE{0}|1
     0.1|UAF$B_RTYPE{1}|0
     0.2|UAF$B_RTYPE{2}|0
     0.3|UAF$B_RTYPE{3}|0
     0.4|UAF$B_RTYPE{4}|0
     0.5|UAF$B_RTYPE{5}|0
     0.6|UAF$B_RTYPE{6}|0
     0.7|UAF$B_RTYPE{7}|0

  A UIC

   DIX&GT;exa UAF$L_UIC
    36.0|UAF$L_UIC|[100,1515]

   DIX&GT;exa UAF$L_UIC{"*"}		!display all fields
    36.0|UAF$L_UIC{GROUP} |00000001515
    38.0|UAF$L_UIC{MEMBER}|00000000100
   DIX&GT;exa UAF$L_UIC{"MEM*"}            !display fields matching MEM*
    38.0|UAF$L_UIC{MEMBER}|00000000100

  A data field
   DIX&GT;exa UAF$Q_LASTLOGIN_N		    !the normal way
   404.0|UAF$Q_LASTLOGIN_N|10-JUL-2008 17:20:01.30
   DIX&GT;exa UAF$Q_LASTLOGIN_N{*}             !examine all subfields
   404.0|UAF$Q_LASTLOGIN_N{YEAR}     |2008
   404.0|UAF$Q_LASTLOGIN_N{MONTH}    |7
   404.0|UAF$Q_LASTLOGIN_N{DAY}      |10
   404.0|UAF$Q_LASTLOGIN_N{HOUR}     |17
   404.0|UAF$Q_LASTLOGIN_N{MINUTE}   |20
   404.0|UAF$Q_LASTLOGIN_N{SECOND}   |1
   404.0|UAF$Q_LASTLOGIN_N{HUNDREDTH}|30
   DIX&GT;exa UAF$Q_LASTLOGIN_N{"*"}           !examine all fields matching *
   404.0|UAF$Q_LASTLOGIN_N{YEAR}     |2008
   404.0|UAF$Q_LASTLOGIN_N{MONTH}    |7
   404.0|UAF$Q_LASTLOGIN_N{DAY}      |10
   404.0|UAF$Q_LASTLOGIN_N{HOUR}     |17
   404.0|UAF$Q_LASTLOGIN_N{MINUTE}   |20
   404.0|UAF$Q_LASTLOGIN_N{SECOND}   |1
   404.0|UAF$Q_LASTLOGIN_N{HUNDREDTH}|30
   DIX&GT;exa UAF$Q_LASTLOGIN_N{"*U*"}         !examine all fields matching *U*
   404.0|UAF$Q_LASTLOGIN_N{HOUR}     |17
   404.0|UAF$Q_LASTLOGIN_N{MINUTE}   |20
   404.0|UAF$Q_LASTLOGIN_N{HUNDREDTH}|30

</pre>
<a name="78">
<h3 Align=center><a href="dix_help_idx_5.html#77" target="index">DIX RECORD_FORMAT_FOR_DESCRIPTIONS Field_declaration SUBFIELDS examples_evaluate </a> </h3>
<pre>

  Fieldname and symbols may be used in evaluations with subnames.
   
  DIX&GT;examine UAF$Q_LASTLOGIN_N
  404.0|UAF$Q_LASTLOGIN_N|10-JUL-2008 17:20:01.30
  DIX&GT;eval UAF$Q_LASTLOGIN_N
  10-JUL-2008 17:20:01.30
  DIX&GT;eval UAF$Q_LASTLOGIN_N{*}
  [2008,7,10,17,20,1,30]
  DIX&GT;eval UAF$Q_LASTLOGIN_N{"*U*"}
  [17,20,30]

  Now for a symbol

  DIX&GT;a=UAF$Q_LASTLOGIN_N	!contains a date value
  DIX&GT;eval a
  10-JUL-2008 17:20:01.30
  DIX&GT;eval a{*}
  [2008,7,10,17,20,1,30]
  DIX&GT;eval a{"*U*"}
  [17,20,30]

</pre>
<a name="79">
<h3 Align=center><a href="dix_help_idx_5.html#78" target="index">DIX RECORD_FORMAT_FOR_DESCRIPTIONS Field_declaration SUBFIELDS Examples_deposit </a> </h3>
<pre>

  DIX&GT;exa UAF$Q_LASTLOGIN_N
  404.0|UAF$Q_LASTLOGIN_N|10-JUL-2008 17:20:01.30
  DIX&GT;dep UAF$Q_LASTLOGIN_N{"DAY"}=23
  DIX&GT;exa UAF$Q_LASTLOGIN_N
  404.0|UAF$Q_LASTLOGIN_N|23-JUL-2008 17:20:01.30



</pre>
<a name="80">
<h3 Align=center><a href="dix_help_idx_5.html#79" target="index">DIX RECORD_FORMAT_FOR_DESCRIPTIONS Field_declaration SUBFIELDS examples_assign </a> </h3>
<pre>

  DIX&GT;exa UAF$Q_LASTLOGIN_N
  404.0|UAF$Q_LASTLOGIN_N|10-JUL-2008 17:20:01.30
  DIX&GT;UAF$Q_LASTLOGIN_N{"DAY"}=23
  DIX&GT;exa UAF$Q_LASTLOGIN_N
  404.0|UAF$Q_LASTLOGIN_N|23-JUL-2008 17:20:01.30
  DIX&GT;a=UAF$Q_LASTLOGIN_N
  a{"DAY"}=25
  DIX&GT;say a
  23-JUL-2008 17:20:01.30


  Or with much more fun

  DIX&GT;a{2:7}=1		!change all subfields except the year
  DIX&GT;say a
  1-JAN-2008 01:01:01.01

  DIX&GT;A{4:7}=[1,2,3,4]  !table shape must be equal (both have 4 elements)
  DIX&GT;say A
  1-JAN-2008 01:02:03.04

  DIX&GT;UAF$Q_LASTLOGIN_N{4:7}=[1,2,3,4]	!table shape must match
  DIX&GT;exa UAF$Q_LASTLOGIN_N
  404.0|UAF$Q_LASTLOGIN_N|23-JUL-2008 01:02:03.04

  DIX&GT;UAF$Q_LASTLOGIN_N{"*U*"}=[10,11,12]  !table shape must match
  DIX&GT;exa UAF$Q_LASTLOGIN_N{"*U*"}
  404.0|UAF$Q_LASTLOGIN_N{HOUR}     |10
  404.0|UAF$Q_LASTLOGIN_N{MINUTE}   |11
  404.0|UAF$Q_LASTLOGIN_N{HUNDREDTH}|12
  DIX&GT;exa UAF$Q_LASTLOGIN_N
  404.0|UAF$Q_LASTLOGIN_N|23-JUL-2008 10:11:03.12
  
 
</pre>
<a name="81">
<h3 Align=center><a href="dix_help_idx_4.html#71" target="index">DIX RECORD_FORMAT_FOR_DESCRIPTIONS Field_declaration USERTYPES </a> </h3>
<pre>
  The user can define his own types. The translations between ascii and
  binary must be programmed in the DIX interactive language. 
  This translation script can be defined in the following ways.
  1. In the .des file
     Somewhere in the .DES file there must be a section the contains the
     script code. This section must begin with #TYPE name and end with #ENDTYPE
  2. In a module in the DIX_des.tlb (either user or system) library.
     The module name must be USERTYPE_'name'. In this case the 
     #TYPE and #ENDTYPE tags are not necessary.

  This script is called with 4 symbols defined
  1. ACTION : a string symbol that defines the action to take, values can be
              SIZE   : Return the size (in bits) of the binary data.
                       (only used in variable length data)
              ASCBIN : Convert from ascii to binary
              BINASC : Convert from binary to ascii
  2. DATA   : A string variable containing the source data. 
              In case "SIZE" and "BINASC" DATA contains the binary data
              In case "ASCBIN" DATA contains the ascii text.
              In all cases the length of the string is the size in bytes.
  3. BITSIZE: An integer value that contains the size in bits. Normally this
              is 8*length(data), but not for bitfields.
  4. FIELDS : The fields as defined in the declaration statement.

  The script must set the following symbols
  Case "SIZE"   : SIZE  , an integer containing the size in BITS.
  case "ASCBIN" : RESULT, a string variable containing the binary data.
                  SIZE  , an integer value containing the size in BITS.
  case "BINASC" : RESULT, a string variable containing the ascii text.

  Also the script must finish with an EXIT statement that returns the status.
   For BINASC 0 means the text will be suppressed by the /compress qualifier.
              1 means is not regarded as "suppressable"
   For others 1=ok, 2=error.
             
  Example:
  You have a line in the description record:

  mytype*8/user fieldname  !user type mytype , size=fixed to 8.
  
  Now we must have either a section in the description record enclosed 
   in the following statements:
    #type usertype
      ...
    #endtype
  Or a module in the DIX_DES or DIX_DES_USER file with the name USERYTPE_MYTYPE
    In this case the #type and #endtype are not needed.

  Below an example of a script that will work. It will convert a 8 byte 
  string to a sequence like 12,34,56,43,123,0,56,9

  #type  mytype
  if (action = "SIZE") then	!return symbol SIZE (size in bits)
   size = 8*8			!will not be called since the size is
   stat = 1			!fixed at 8 bytes (is 8*8 bits)
  endif

  if (action = "BINASC") then	!return symbol RESULT
   nk = f$length(data)
   stat = 0			!assume all bytes are ZERO
   result = ""
   for k=1,nk
    kar = f$extract(k-1,1,data)
    byt = f$extzv(0,8,kar)
    if (byt &LT;&GT; 0) stat = 1	!not all bytes ZERO
    result = result + "," + string(byt)
   endfor
   result = f$extract(1,-1,result)
  endif

  if (action = "ASCBIN") then	!return symbol RESULT and SIZE
   set noon
   result = ""
   k = 0
   stat = 2			!assume error in conversion
  lp2: part = f$element(k,",",data)
   if (part &LT;&GT; ",") then
    byt = int(part)
    if (even($status)) goto err
    if (byt &LT; 0 | byt &GT; 255) goto err
    result = result + f$char(byt)
    k = k + 1
    goto lp2
   endif
   size   = f$length(result)*8	!return length in bits
   stat = 1			!successful convert
  err:
  endif
  exit 'stat'			!return  conversion result
  #endtype

 
</pre>
<a name="82">
<h3 Align=center><a href="dix_help_idx_4.html#72" target="index">DIX RECORD_FORMAT_FOR_DESCRIPTIONS Field_declaration RADIX_OVERRIDE </a> </h3>
<pre>

  Normally all fields are displayed in decimal or text.
  If the fieldtype is followed by the a radix qualifier the display 
  (and also the input is in the requested radix)
 
  The following radices are supported
  /HEXADECIMAL
  /OCTAL
  /BINARY 

  example

  INTEGER*4 FIELD         Will be displayed and modified in decimal
  INTEGER*2/BIN DATA      Will be displayed and modified in Binary
  INTEGER*2/OCT DATA      Will be displayed and modified in OCT
  CHARACTER*3/HEX TMP     Will be displayed and modified in HEX


</pre>
<a name="83">
<h3 Align=center><a href="dix_help_idx_3.html#37" target="index">DIX RECORD_FORMAT_FOR_DESCRIPTIONS Control_statements </a> </h3>
<pre>

  DIX also supports a number of control statements

  STRUCTURE,ENDSTRUCTURE    After the structure statement follows a name
                            optionally followed by a dimension (dim1,dim2,dim3)
                            If the name is specified the fieldname is 
                            extended by .structurename. if no name is specified,
                            the fieldname is not extended
 
  UNION,ENDUNION
  MAP,ENDMAP                See MAP_SYNTAX below. 
  

  RANGE,ENDRANGE            See RANGE_SYNTAX below
  BLOCK,ENDBLOCK            See RANGE_SYNTAX below

  POSITION[/RELATIVE] (value) Set the bit/byte offset to the value. 
                             The () must be specified.
                            This can be useful in some overlay structures
                            See also the example in RANGE_SYNTAX. The value
                            is the new byte position, unless in a bitfield,
                            where the value is in bits.
                            If the /relative is given (or the value is negative)
                            the value is added/subtracted to/from the current 
                            offset, else it new offset=value.

  POINTER                   Temporary override the bitoffset for the
                            following structure. See pointer_syntax below
 

  PAD[*NN]                  Round up bit/byte-offset to NN fold. nn=2,4,8 
                             default in bitmode 8 (align to next byte)
                                     else       2 (align to next word)
                             Rounding takes 0..NN-1 bytes/bits.
                            The verb ALIGN is a synonym for PAD
                            The /VFC or not decides where the pad is done
                             
  PAD PACKED|NATURAL        Set a policy for padding/aligning.
                            The verb ALIGN is a synonym for PAD
                            PACKED : Align from now on fields on bit/byte boundary
                            NATURAL: Align from now on fields on its natural size
                             f.e. INTEGER*4 will be aligned on a 4 byte boundary
                            The PAD*nn overrules this setting for the next
                            field only.

  EXIT [condition]          If condition is not specified, it will be evaluated
                            true. If condition is true, skip the repeat of the
                            current structure (there must be one)
                            See exit_syntax below

  ABORT reason [condition]  If the abort statement is seen, DIX checks if
                            condition evaluates to TRUE (or is not present).
                            If this is the case, the description is regarded
                            as not valid. This statement can be used to do
                            some sanity checking. See the examples help
                            for an example.
  DEFAULT INTEGER size      Set the default integer size. 
                            Size can be 4,8,32 or 64
  DEFAULT REAL size         Set the default real size
                            Size can be 4,8,16,32,64 or 128

  You can also define your own types. See the help about 
    [DIX/help] record_form field usertypes.

  BITFIELD
  ENDBITFIELD
    Normally the number after the * will be interpreted as bytes, but
    between a BITFIELD and an ENDBITFIELD the numbers will be interpreted
    as bits. Only (U)INTEGER,(R)BITS,LOGICAL and PAD fields are allowed between
    BITFIELD and ENDBITFIELD. After an ENDBITFIELD the record pointer will 
    be padded to the next byte.

  Case construct. Select one of the case constructs.
    SWITCH/CASE/ENDSWITCH           See the select_syntax below

</pre>
<a name="84">
<h3 Align=center><a href="dix_help_idx_4.html#74" target="index">DIX RECORD_FORMAT_FOR_DESCRIPTIONS Control_statements SWITCH_SYNTAX </a> </h3>
<pre>

  Syntax 
 
   SWITCH[/FALL_THROUGH] expression  [fieldnames]
     CASE value1		!if fieldnames present you may use a name
       statement(s)
     CASE value2
       statement
       statement
     CASE 
       statement(s)
    ENDSWITCH

  The first match is used, following matches will not be found. 
   Expression and value must be a valid (scalar) expression, and the
   types and sizes must match

  If no value is specified after the CASE (or the text is *), this 
   will be the default case.
   If the switch is defined with a fieldname, you may also use one of
   the names
  If /FALL_THROUGH is specified, all cases after the selected
   one are used (but not the default case). If /FALL_THROUGH
   is specified, and no case matches, the default case IS used
   and then all the following cases.

  The /fall_through can also be used in the case statement. If the
     /fall_through is already specified on the switch it is ignored.
  If the switch has no /fall_through and the case has, the following
     case statement will also be executed (and that one can also have a 
     /fall_through)
 
  Example
 
  SWITCH expression
    case value1
      statement1
    case value2/fall
      statement2
    case value3/fall
    case value4/fall
      statement3
   endswitch

   If expression is value1, only statement statement1 is executed
   If expression is value2, only statement statement2 and statement3 are executed
   If expression is value3 or value4, statement3 is executed

  If /FALL_THROUGH is not set, only the first match is
   found, so if multiple cases match the SWITCH value, only
   the first is used. This also applies to the default case

   Example (using the #MESSAGE command, but you could also use
            any data type)

   SWITCH SELECTOR*2
    CASE 10
     #message "value=10"
    CASE 20
     #message "value=20"
    CASE
     #Message "The default case"
    CASE 40
     #message "Value=40"
   ENDSWITCH

  Selectorvalue Result
   10           The text "value=20" is printed
   11           The text "The default case" is printed
 
   SWITCH/FALL SELECTOR*2
    CASE 10
     #message "value=10"
    CASE 20
     #message "value=20"
    CASE
     #Message "The default case"
    CASE 40
     #message "Value=40"
   ENDSWITCH

  Selectorvalue Result
   10           The texts "value=20","value=40" are printed (not the default case)
   11           The texts "The default case" and "value=40" are printed
 
  Example with fieldnames

   parameter names=",PROD,TEST,DEVELOP"   !1=prod,2=rest,3=develop
   integer*4 phase [#names]               !use the parameter for fieldnames
   switch expression [#names]             !use the parameter for the switch too
   case prod				  !the text prod is found in names
    #message "It is prod"
   case test
    #message "It is test"
   case develop
    #message "It is develop"
   case 10
    #message "It is case 10"
   endswitch

</pre>
<a name="85">
<h3 Align=center><a href="dix_help_idx_4.html#75" target="index">DIX RECORD_FORMAT_FOR_DESCRIPTIONS Control_statements RANGE_SYNTAX </a> </h3>
<pre>

  The record descriptions can contain one or more RANGES or BLOCKS
  RANGE[/RELATIVE] (min_offset:max_offset)
    field
    field
    ...
  END RANGE
  BLOCK[/RELATIVE] (start_pos:end_pos) 
    field
    field
    ...
  END BLOCK

  The () are required syntax.
  The fields start at offset "min_offset" and continue until the offset
  "max_offset". If the byte_offset is &GT;= max_offset, the rest of
  the RANGE is ignored. RANGE and BLOCK are very much the same, but
  after the ENDRANGE is found, the (bit-)offset is restored to the value
  before the RANGE, and the BLOCK sets the (bit-)offset to end_pos. 
  So if the range/block is in another part of the record you should use 
  RANGE, and if the range/block is inline you should use BLOCK

  If /relative is specified, the start_pos and end_pos are added to the
  current bit_offset, otherwise they will set the bit_offset  

  An example is in the ODS2 File headers


	byte		id_offset	! Offset to Ident area
	byte		map_offset	! Offset mapping area
	byte		acl_offset	! Offset to ACL area
	byte		res_offset	! Offset to ACL area
	integer*2	seg_num		! Extension seqment number
        ....
	range (map_offset*2:acl_offset*2-1)
	 diskmap maps(256)		!enough
	end range
        .....
	position (510)
	integer*2/hex checksum

  The DISKMAP entries start at byte offset MAP_OFFSET*2 (MAP_OFFSET is in 
  words) and continues until ACL_OFFSET*2-1.

  The checksum is at fixed location 510 

  And example for the BLOCK statement is in the $BUCKET description for
  a bucket in an indexed file
   ...
   uinteger*2 first_free_byte
   ...
   block (14:first_free_byte)	!this part extends from byte 14 ..the
                                !value in first_free_byte
     structure sidrvalues(*)    !we don't know how many sidr values there are
                                !but if we cannot exceed the block
        integer*2 total_len     !the total length of the sidrvalue
        ...                     !display the keyvalue (compressed or not)
        block/relative (0:total_len+%loc("TOTAL_LEN")-%location+2)
                                !the sidrvalue record
                                !starts at offset 0(relative) and continues
                                !until the length is exceeded
	  structure rrvs(*)    !the rrvs are limited to the block
          ...
          end structure         !end of the rrvs
        end block               !end of the rrv block
     end structure              !end of the sidr values structure
   end block			!end of the total block
  ...

</pre>
<a name="86">
<h3 Align=center><a href="dix_help_idx_4.html#76" target="index">DIX RECORD_FORMAT_FOR_DESCRIPTIONS Control_statements MAP_syntax </a> </h3>
<pre>
  The MAP command has a special syntax. It is included in a UNION statement.

   UNION
    MAP [selectionstring]
    END MAP
    MAP [selectionstring]
    END MAP
   ..
   END UNION

  If there is no selectionstring specified, DIX will show the mapping.
  If there is a selection string, DIX will show the map only if the
  selection string matches. The format for the selection string is:
 
  Expression=sel_value[,sel_value...]
  And sel_value is 
  1. expresion              Just a single (integer) expression
  2. expression:expression  A range of (integer) expressions

  At this moment only integer expressions are allowed.

  You can specify a dependency on a previously defined variable.

  SYNTAX:
  integer*4 sel		!any field will do (dependency field)
   UNION
    MAP  SEL=value  !Display this map if SEL has value "value"
    END MAP
    MAP  SEL=VALUE1 !Display this map if SEL has value "value1"
    END MAP
   ..
   END UNION

  If all maps have a dependency and none of them is used, DIX will always 
  use the last one, unless one of the MAP entries has a depandancy-fieldname
  of *

  Example

  integer*4 sel		!any field will do (dependency field)
   UNION
    MAP  SEL = 0,10:12	!case for sel=0 and 10:12
     character*4 valuec
    END MAP
    MAP  SEL = 1        !case for sel=1
     integer*4 value4
    END MAP
    MAP *               !case for all other values of sel
     logical*4 valuel
    END MAP
    MAP  SEL = 2        !case for sel=2
     integer*2 value2(2)
    END MAP
   END UNION

  If SEL has value 0 or is between 10 and 12 the character VALUEC is displayed
  If SEL has value 1 the INTEGER*4 VALUE4 is displayed
  If SEL has value 2 the INTEGER*2 VALUE2(2) is displayed
  If SEL has any other value the LOGICAL*4 VALUEL is displayed

  IF the MAP * had not existed, and SEL would not have been 0 or 10-12 or 
   1 or 2 the last map (SEL=2 : = VALUE2(2)) would have been used.

</pre>
<a name="87">
<h3 Align=center><a href="dix_help_idx_4.html#77" target="index">DIX RECORD_FORMAT_FOR_DESCRIPTIONS Control_statements POINTER_syntax </a> </h3>
<pre>
  The pointer statement allows you to decode a piece of data in an other
  place in the record. 

   Syntax  POINTER[*n] [/RANGE=min:max] fieldname [pointee]
    The next structure block (there must be a structure block directly
    after this statement) will contain the fields that are part of the 
    pointed data.

   The *n is optional, default *4
   The /range is optional, if allows you to mark certain values of the
   pointervalue as not valid, so POINTER/RANG=1: name [pointee] will 
   not be taken is the contents of the pointer is &LT;1.

   The [pointee] is necessary. If contains the fieldname, of which the
    address will be added to the pointer value to get the correct offset

  An example is the PENDING structure (pending.dat) for Allin1/Office server

        character*64 pending_key          !MAIL + the name of the user
        character*1  record_code          !continuation record index
        character*1  cont_flag            ! flag for contin record
        integer*2    total_attr_size      !total size of the pointers+data 
                                          ! of all records together
        integer*2    this_rec_attr        !size of pointer+data in this record
        character*2  usage_count          !how often is this record used
        character*5  new_mail_count       !new mail count for the user
        character*3  padding                  
        structure pointers(100)               [1] !start of pointer/data 
          integer*2 type [7=mail]		  !type of field
          integer*2 %dummy
          pointer*4 offs [pointers]           [2] !offset to the "pointer" field
          structure work                      [3] !the data section
            integer*2 length                      !length of string
            byte  %unknown(6)
            character*(length-6) test             !the string
          end structure                       [4] !end of the data definition
          exit [offs+length+2&GT;=this_rec_attr] [5] !exit statement
        end structure

    The record is build up as follows
    a. 80 bytes of fixed data
    b. a pointer section containing an array of
        1. Type
        2. Offset to a position in the record after the pointers
    c. the text area pointed to by the offset
   
    The statement pointer*4 offset[pointers]  at [2] must be followed by a
    structure statement [3].
    DIX will take the value from the record at the position of the pointer
    statement [2] (the length contains the size of the field), adds the 
    location of "POINTERS" [1], and uses that offset to expand the
    statements in the structure "work" [3]. When the end structure [4] 
    is found, DIX will resume processing the next statement [5]
    with the saved offset.
    At the end [5] is the exit test. If the offs &GT; cur rec length : exit
    This means : leave the "pointers" structure. since there is no more
    data available, the display is stopped.

  See the display below

    0|PENDING_KEY            |MAIL JOHN.DOE
   64|RECORD_CODE            |
   65|CONT_FLAG              |.
   66|TOTAL_ATTR_SIZE        |86
   68|THIS_REC_ATTR          |82
   70|USAGE_COUNT            |
   72|NEW_MAIL_COUNT         |3
   77|PADDING                |
   80|POINTERS(1).TYPE       |MAIL
   84|POINTERS(1).OFFS       |16
   96|POINTERS(1).WERK.LENGTH|31
  104|POINTERS(1).WERK.TEST  |OA$SHARA7718:IFQ3FORG.TXT
   88|POINTERS(2).TYPE       |MAIL
   92|POINTERS(2).OFFS       |49
  129|POINTERS(2).WERK.LENGTH|31
  137|POINTERS(2).WERK.TEST  |OA$SHARE2664:IFR1XUY1.TXT
   96|POINTERS(3).TYPE       |31

  You could suppress the display of pointers(1).offs, by changing the 
  definition of pointer to :
     pointer*4/nodisplay offs [pointers]

  Another example is from the records of the accounting file

    BITFIELD
     INTEGER*1 FLAG
     INTEGER*7 TOTTYPE [,PRCDEL,PRCPUR,IMGDEL,IMGPUR,SYSINIT,SETTIME,LOGFAIL,PRINT,USER,ENABLE,DISABLE,ALTACM,FILE_FL,FILE_BL]
     INTEGER*4 SUBTYPE [,INTERACTIVE,SUBPROCESS,DETACHED,BATCH,NETWORK]
     INTEGER*3 VERSION
     INTEGER*1 CUSTUMER
    ENDBITFIELD
    INTEGER*2 LENGTH
    DATE SYSTIME
    STRUCTURE PACKET(10)                            [1]
      BITFIELD
       INTEGER*1 PACKETFLAG
       INTEGER*7 PACKETTYPE [,ID,RESOURCE,IMAGENAME,FILENAME,USER_DATA,,,PRINT]
       INTEGER*4 SUBTYPE
       INTEGER*3 VERSION
       INTEGER*1 CUSTUMER
      ENDBITFIELD
      INTEGER*2 SUBLENGTH
      UNION
       MAP PACKETTYPE=1
        INTEGER*4/HEX PID
        INTEGER*4/HEX OWNER
        UIC UIC
        INTEGER*4 PRIVS(2)
        BYTE PRIO
        BYTE FLAGS
        POINTER*2/RANGE=1: USERNAMEOFFSET [PACKET]  [2]
        STRUCTURE                                   [3]
         STRING USERNAME
        END STRUCTURE                               [4]
        POINTER*2/RANGE=1: ACCOUNTOFFSET [PACKET]   [5]
        STRUCTURE 
         STRING ACCOUNTNAME
        END STRUCTURE
        .... and some more pointers for other fields
       END MAP
      ... for other packettypes
      END UNION
    ENDSTRUCTURE

  The pointer statement at [2]
        POINTER*2/RANGE=1: USERNAMEOFFSET [PACKET]  [2]
   will be processed as follows.
    Take the value from the record, 2 bytes The (*2).
    See if this value is at least 1 (the /rang=1:) 
    If not, skip the following structure [3], and continue with the next [5]
    If it is &GT;=1, add the value to the offset of PACKET [1]
     and decode the data at that offset as the structure [3]
       So we expect a STRING datatype there 
            (the structure contains only one field)
     After this sidestep (we found the ENDSTRUCTURE [4]) , 
    return to processing the data at [5]
</pre>
<a name="88">
<h3 Align=center><a href="dix_help_idx_4.html#78" target="index">DIX RECORD_FORMAT_FOR_DESCRIPTIONS Control_statements EXIT_syntax </a> </h3>
<pre>
  The pointer statement allows you to terminate a structure repeat count

	character*64 test
	structure pointers(100)               [1]
	  integer*4 type [7=mail]
          integer*4 value
	  exit [type=10]                      [2]
	end structure                         
        character*10 rest

    The record is build up as follows
    a. 64 bytes of fixed data (test)
    b. a structure section containing an array of
        1. Type
        2. value
    c. 10 bytes trailer (rest)
   
    The statement "exit [type=10]" at [2] will exit the *100 repeat for [1]
    if the contents for type = 10.
      

   0|TEST                   |MAIL 01CURSIST
  80|POINTERS(1).TYPE       |MAIL
  96|POINTERS(1).VALUE      |20                         
  88|POINTERS(2).TYPE       |MAIL
  92|POINTERS(2).VALUE      |25
  96|POINTERS(3).TYPE       |10		&LT;- this terminates with the exit
 100|POINTERS(3).VALUE      |25
 104|REST                   |The rest
 

  If the description had been
	character*64 test
	structure pointers(100)               [1]
	  integer*4 type [7=mail]
	  exit [type=10]                      [2]
          integer*4 value
	end structure                         
        character*10 rest

  The result would have been  (POINTERS(3).VALUE at 100 is not displayed)
  and so the offset for REST is 4 lower

   0|TEST                   |MAIL 01CURSIST
  80|POINTERS(1).TYPE       |MAIL
  96|POINTERS(1).VALUE      |20                         
  88|POINTERS(2).TYPE       |MAIL
  92|POINTERS(2).VALUE      |25
  96|POINTERS(3).TYPE       |10		&LT;- this terminates with the exit
 100|REST                   |The rest
 
</pre>
<a name="89">
<h3 Align=center><a href="dix_help_idx_4.html#79" target="index">DIX RECORD_FORMAT_FOR_DESCRIPTIONS Control_statements Examples </a> </h3>
<pre>
</pre>
<a name="90">
<h3 Align=center><a href="dix_help_idx_5.html#89" target="index">DIX RECORD_FORMAT_FOR_DESCRIPTIONS Control_statements Examples EXAMPLE_FOR_SWITCH </a> </h3>
<pre>

   INTEGER*4 value[_expression]
   SWITCH value
     CASE 1			!case taken if value=1
      integer*4 value1
      character*20 text1
     CASE 4                     !case taken if value=4
      integer*4 val2
      logical*4 ext
     CASE                   	!default case if nothing matches
      character*(20) default
     CASE 1                     !will not be found, since we had a 
      integer*4 not_used        !match before
     CASE                       !will not be found, since we had a 
      integer*4 not_used_def    !match before
   ENDSELECT

</pre>
<a name="91">
<h3 Align=center><a href="dix_help_idx_5.html#90" target="index">DIX RECORD_FORMAT_FOR_DESCRIPTIONS Control_statements Examples Example_for_bitfield </a> </h3>
<pre>

    INTEGER*4 value            value contains 4 bytes = 32 bits
    BITFIELD
     integer*4 first_nibble    value contains 4 bits.
     logical*1 first_bit[0=no,1=yes]
                               value contains 1 bit
     PAD 2                     Align to even bit (so this takes 1 bit)
     integer*1 second_bit      value contains 1 bit
    ENDBITFIELD                aligns on byte boundary (so 1 pad bits)
    LOGICAL*1 temp             value contains 1 byte.

</pre>
<a name="92">
<h3 Align=center><a href="dix_help_idx_5.html#91" target="index">DIX RECORD_FORMAT_FOR_DESCRIPTIONS Control_statements Examples Example_for_file_link </a> </h3>
<pre>

    CHARACTER*12/FILE=SYSUAF Username
                             You can follow this link to the file SYSUAF
                             keyvalue the contents of "USERNAME", KEY=0

    INTEGER*4/FILE=DATAFILE/RECORD/COMPUTE="$field+10" index
                             You can follow this link to the file DATAFILE
                             with the recordnumber the contents of 
                             the field "index" + 10                         

    INTEGER*4/FILE=SYSUAF/KEY=1/IF="$field&GT;0" identifier
                             Follow the identifier to the SYSUAF file, but
                             only if the identifier is &GT;0 (UIC identifier)



   Example for not displayable fields
   The file_char bits in the indexf.sys contain 2 bits that define the
    caching attributes (bit 8 and 9). Since the names for these bits are
    a #, DIX will not display these bits.

    The POSITION (-24) : reposition the byte_offset by 24 (bits).
    The INTEGER*2      : define a 2 bits integer with 4 possible values.
    The POSITION/RELATIVE (22) : Sets the byte_offset back to where we were. 

        bits*4          file_char -
                [Wascontig,Nobackup,Writeback,Readcheck,Writecheck,-
                 Contigb,Locked,Contig,#,#,,Badacl,-
                 Spool,Directory,Badblock,Markdel,Nocharge,Erase,alm_aip,-
                 shelved,scratch,nomove,noshelvable,shelv_res]
        bitfield	!start in bits mode, the next 2 bits define the caching
          position/relative (-24)     !skip back 24 bits, the /relative 
                                      !is optional since the value is negative
          integer*2 caching [writethrough,writeback,flush_on_clos,no_cache]
	  posision /relative (22)     !skip the next 22 bits(in total 3 bytes)
        end bitfield	!back to non field mode again

     This could also have been achieved by
        structure                   !no name attached
          union
            map
              bits*4          file_char -
                [Wascontig,Nobackup,Writeback,Readcheck,Writecheck,-
                 Contigb,Locked,Contig,#,#,,Badacl,-
                 Spool,Directory,Badblock,Markdel,Nocharge,Erase,alm_aip,-
                 shelved,scratch,nomove,noshelvable,shelv_res]
            end map
	    map
	      byte %temp1
	      bitfield
                integer*2 caching [writethrough,writeback,flush_on_clos,no_cache]
	      end bitfield	!will align back to the next byte
            end map
	  end union
	end structure

</pre>
<a name="93">
<h3 Align=center><a href="dix_help_idx_5.html#92" target="index">DIX RECORD_FORMAT_FOR_DESCRIPTIONS Control_statements Examples EXAMPLE_for_ABORT </a> </h3>
<pre>

  The following description is from the SYSUAF description. The
  UAF$B_RTYPE is expected to be 1.

  BYTE UAF$B_RTYPE
  ABORT wrongtype [UAF$B_RTYPE &LT;&GT; 1]
  ....  rest of description

  If the UAF$B_RTYPE is &LT;&GT; 1, DIX will assume that the current record
  cannot be described by this description. DIX will issue a warning
  "description is aborted wrongtype. The description will remain
  open for the file, so if another record does have the right UAF$B_RTYPE
  this record will be displayed using this description.

</pre>
<a name="94">
<h3 Align=center><a href="dix_help_idx_5.html#93" target="index">DIX RECORD_FORMAT_FOR_DESCRIPTIONS Control_statements Examples EXAMPLE_for_MAP </a> </h3>
<pre>
	   PARAMETER REP_BITS=2
           INTEGER*4 RECNR
           STRUCTURE DATUSR
             DATE*4 DATTIM 	!internal date format #minutes since 1857
             UIC*4 UIC          !standard OpenVMS UIC format (group,member)
           END STRUCTURE
	   INTEGER*2 type -     !1,4,10 will be by name, all others in
              [1=special,4=normal,10=fatal]    !decimal format
	   INTEGER*2 COUNT
           INTEGER*4 RESCHED
           STRUCTURE BITS(REP_BITS)    !2 structures, with both bits*1 flag=1 byte long
             BITS*1 FLAGS [mon,tue,wed,thu,fri,sat,sun]      !the total is 2 bytes
           END STRUCTURE
	   UNION

	    MAP TYPE=Special    !this case is valid if type=1 (special)
             INTEGER*2 time(2)     
	    END MAP

	    MAP *               !this case is valid for any other field value
	     CHARACTER*2 dunnow !
	    ENDMAP		

	    MAP type=normal     !this case is value if type=4 (normal)
             INTEGER*4 time        
	    ENDMAP

	    MAP Type=fatal      !this case is valid if type=10 (fatal)
	    ENDMAP		!No allocation is this type
	   ENDUNION             !total structure length is dependent on type

           WSTRING*60 MESSAGE   !word counted ASCII string with 60 bytes room
	   INTEGER*4 FIELD(1:COUNT)
                                !field has COUNT members


</pre>
<a name="95">
<h3 Align=center><a href="dix_help_idx_5.html#94" target="index">DIX RECORD_FORMAT_FOR_DESCRIPTIONS Control_statements Examples EXAMPLE_for_FIELD_FOLLOW </a> </h3>
<pre>
  An example about field_following to another file

  The example is about 3 RMS indexed files that form a simple sourcemodule
  cross_reference system

  The first file (CROSS_REF.CRF_FILE_NAMES) has the following description
  (.CRF_FILE_NAMES in the system or user textlibrary)
          integer*2    file_nr                          !primary key
          character*60 file_name
          integer*2    %filler

  The second file (CROSS_REF.CRF_MOD_NAMES) has the following description
  (.CRF_MOD_NAMES in the system or user textlibrary)
          integer*2    mod_nr                           !primary key
          character*32 mod_name
          integer*2    file_nr/file=.crf_file_names	!link to the filename

  The third file (CROSS_REF.CRF_CROSS) has the following description
  (.CRF_CROSS in the system or user textlibrary)
          integer*2    caller_nr /file=.crf_mod_names   !link to modulename
          integer*2    called_nr /file=.crf_mod_names   !link to modulename

  Now if you open a record in the third file
  $DIX CROSS_REF.CRF_CROSS
  %DIX-I-USINGFIL, Using file DSA40:[DIR]CROSS_REC.CRF_CROSS
  %DIX-I-USINGDES, Using description DIX_SYS(.CRF_CROSS)
  DIX&GT; EXA *
   0|CALLER_NR&GT;|738		!the &GT; tells us there is a link present
   2|CALLED_NR&GT;|-262

  DIX&GT; EXA/DES *
   0|CALLER_NR&GT;|738
     Type      :INTEGER*2
     Linenumber:0
     Variable  :False
     Dependency:False
     Link file :.CRF_MOD_NAMES	!and yes there is a link defined
     Link field:0
     Match     :EQ
   2|CALLED_NR&GT;|-262
     Type      :INTEGER*2
     Linenumber:1
     Variable  :False
     Dependency:False
     Link file :.CRF_MOD_NAMES
     Link field:0
     Match     :EQ

  DIX&GT; Follow CALLER_NR		!try to follow this link
  File .CRF_MOD_NAMES not (yes) opened, open it (y/[n]):Y     !do you want to open the file
  %DIX-I-USINGFIL, Using file DSA40:[DIR]CROSS_REF.CRF_MOD_NAMES
  %DIX-I-USINGDES, Using description DIX_SYS(.CRF_MOD_NAMES)

  DIX&GT; Exa *
  0|MOD_NR  |738
  2|MOD_NAME|CHECK_ALLOWED_USER
 34|FILE_NR&GT;|66			!and this field has a link defined

  DIX&GT; Follow file_nr
  File .CRF_FILE_NAMES not (yes) opened, open it (y/[n]):y
  %DIX-I-USINGFIL, Using file DSA40:[DIR]CROSS_REF.CRF_FILE_NAMES
  %DIX-I-USINGDES, Using description DIX_SYS(.CRF_FILE_NAMES)

  DIX&GT; Exa *
  0|FILE_NR  |66
  2|FILE_NAME|REM_SERVER_CHECK_ACCESS

  DIX&GT; Back			!now backtrace
  %DIX-I-USINGFIL, Using file DSA40:[DIR]CROSS_REF.CRF_MOD_NAMES
  %DIX-I-USINGDES, Using description DIX_SYS(.CRF_MOD_NAMES)

  DIX&GT; Exa *
  0|MOD_NR  |738
  2|MOD_NAME|CHECK_ALLOWED_USER
 34|FILE_NR&GT;|66                 

  DIX&GT; Back			!and again a backtrace
  %DIX-I-USINGFIL, Using file DSA40:[DIR]CROSS_REC.CRF_CROSS
  %DIX-I-USINGDES, Using description DIX_SYS(.CRF_CROSS)

  DIX&GT; EXA *
   0|CALLER_NR&GT;|738             !the &GT; tells us the is a link present
   2|CALLED_NR&GT;|-262

  As you see, you can jump around an look at the recordstructures and links

  Another example is the .DIR description

  integer*2 verslim [32767=None]		!version limit
  bits*1 flags                                  !flag byte
  string name                                   !bytecounted string (variable)
  pad*2						!align to word boundary
  structure v(64)				!n*version,fileid
    integer*2 version
    fileid    fileid/file=[000000]indexf.sys/record-
       /comp="f$getd($file,""blnr"")+int(f$extr(1,-1,f$elem(0,"","",$FIELD)))"
  end structure 
  
  The fileid has a link to the corresponding indexf.sys with a record number
  equal to the first number in the fileid (layout = (filenr,revnr,volume))
  + the record number in indexf.sys of the fileheader with fileid 0.

  You need read access to the index file for this

  $ DIX somedir.dir/int
  %DIX-I-USINGFIL, Using file USER50:[STUBBF.PROGRAMS.DIX]SOMEDIR.DIR;1/NOMOD
  %DIX-I-USINGDES, Using description DSA50:[STUBBF.PROGRAMS.DIX]DIX_DES.TLB;54(.DIR)
  DIX&GT;exa *
   0|VERSLIM     |NONE
   2|FLAGS       |
   3|NAME        |Q.Q
   8|V(1).VERSION|1
  10|V(1).FILEID&GT;|(63474,3,0)

  DIX&GT;foll v(1).fileid		!follow link to fileheader
  File [000000]INDEXF.SYS not (yet) opened, open it (y/[n]):y
  %DIX-I-USINGFIL, Using file USER50:[000000]INDEXF.SYS;1/NOMOD
  %DIX-I-USINGDES, Using description DSA50:[STUBBF.PROGRAMS.DIX]DIX_DES.TLB;54(INDEXF)
  DIX&GT;exa *
    0|ID_OFFSET          |40
    ...
    8|FILE_ID            |(63474,3,0)
    ...
   66|BACKL_FID         &GT;|(62674,1,0)
   80|FNAM               |Q.Q;1
    ...
  DIX&GT;Follow backl_fid		!follow link to parent directory
    0|ID_OFFSET          |40
   ...
    8|FILE_ID            |(62674,1,0)
   ...
   66|BACKL_FID         &GT;|(44986,1,0)
   ...
   80|FNAM               |SOMEDIR.DIR;1
   ...
  DIX&GT;back		!back to the fileheader

  DIX&GT;exa *
    0|ID_OFFSET          |40
    ...
    8|FILE_ID            |(63474,3,0)
    ...
   66|BACKL_FID         &GT;|(62674,1,0)
   80|FNAM               |Q.Q;1
    ...

  DIX&GT;back		!back to the entry in the somedir.dir file  
  %DIX-I-USINGFIL, Using file USER50:[STUBBF.PROGRAMS.DIX]SOMEDIR.DIR;1/NOMOD
  %DIX-I-USINGDES, Using description DSA50:[STUBBF.PROGRAMS.DIX]DIX_DES.TLB;54(.DIR)

  DIX&GT;exa *
   0|VERSLIM     |NONE
   2|FLAGS       |
   3|NAME        |Q.Q
   8|V(1).VERSION|1
  10|V(1).FILEID&GT;|(63474,3,0)


</pre>
<a name="96">
<h3 Align=center><a href="dix_help_idx_5.html#95" target="index">DIX RECORD_FORMAT_FOR_DESCRIPTIONS Control_statements Examples EXAMPLE_for_LIMIT_QUAL </a> </h3>
<pre>
 Example for the /LIMIT qualifier

  Description
   CHARACTER*10 TEXT
   STRUCTURE data(100)
     INTEGER*4 flag/limit=&GT;100
     CHARACTER*20 what
   END STRUCTURE

  If the field limit contains a value &GT; 100, the repeat for the 
  structure data(100) will be terminated.

   CHARACTER*10 TEXT
   STRUCTURE data(100)
     INTEGER*4 flag(5)/limit=&GT;100
     CHARACTER*20 what
   END STRUCTURE

  If the field limit contains a value &GT; 100, the repeat for the 
  structure flags (5) will be terminated, but the repeat for
  the structure will be continued

</pre>
<a name="97">
<h3 Align=center><a href="dix_help_idx_2.html#9" target="index">DIX Record_searches </a> </h3>
<pre>

  You can search records in three ways. 
  a. Via the key record selection (/ge/gt/eq/le/lt). This will only
     work for indexed or relative files

  b. Via the record selection (/record). THis will work for all types of files

  c. Via a search on record contents. This help page describes this method.

  DIX has a powerful record search function. You can look for data in
  records, but also in fields (if you have a description). 
  Parameters 2..8 can be used for search input.

  If the fields are not text-fields but binary data, DIX will do a convert
  of the search string to binary and then do the compare. 

  DIX also allows you to search data in more than one record, so a query
  like "search a record that contains A and the next record contains B" is
  possible, and this is not limited to just 2 records.

  The search can be a simple locate, or a wildcard match, or a compare
  (le,le,eq,ge,gt), and the compares can be done in any known type.

  The searchsyntax is

    Parameter [parameter2] [parameter3..] Up to 7 parameters.

  If more than one parameter is given, parameter2 must match data in the
  following record, parameter3 in the next record and so on.

  Each parameter has the syntax (a list of values and qualifiers)

    string1[/qual],string2[/qual],.. 

  Search can be used in 4 places
  Interactive mode : Entered on the command line or in the interactive commands:
                      Will set the record pointer to the first match
  Screen mode      : Will set the record pointer to the first match
  Decwindow mode   : Will set the record pointer to the first match
  File   mode      : Will display all records matching the search 
                     (unless /count is given)

 

</pre>
<a name="98">
<h3 Align=center><a href="dix_help_idx_3.html#39" target="index">DIX Record_searches Examples </a> </h3>
<pre>

  All these examples are for the DIX/FILE mode. They can also be used
  for the screen and interactive mode. The file mode will display all matches,
  the interactive and screen will select the first record that matches.

  1.DIX/FILE data.dat TEST 
    Display all records that contain TEST (/MATCH=LOCATE). The search is
    NOT case sensitive.

  2.DIX/FILE data.dat TEST,12/FIELD=FOR*MAT/MATCH=GE
    Display all records that contain TEST (/MATCH=LOCATE), 
      OR have the value in any field that matches "FOR*MAT" &GT;=12

  3.DIX/FILE data.dat TEST/LOGIC=AND,12/FIELD=FORMAT/MATCH=GE
    Display all records that contain TEST (/MATCH=LOCATE), 
      AND have the value of field "FORMAT" &GT;=12

  4.DIX/FILE data.dat TEST/WINDOW=(position=10,size=40)
    Display all records that contain TEST (/MATCH=LOCATE) in the 
    byte 10..49 of the record. The search is NOT case sensitive.

  5.DIX/FILE data.dat *XYZ/MATCH=match
     Display all records that match *XYZ (so the XYZ must be at
     the end of the record.

  6. DIX/FILE data.dat "TesT"/case_sensitive
     Display all records that contain TesT is this case.

  7. DIX/FILE data.dat string1,string2/next_record/wild=extended
     Display the records that contains string1 and the next record
     matches string2 (with extended wild characters). 
     Only the first record is displayed.

  8. DIX/FILE data.dat 123:456/match=range/field=myfield
     Displays the records that contain a value between 123 and 456 
     (including) in field myfield

  9. DIX/FILE data.dat 123/field=myfield/type=integer*2/mat=eq
     Displays the records that contain an value of 123 in the 
     first two bytes (converted as integer*2) of the field myfield
     Field myfield does not have to be of type integer.

 10. DIX/FILE data.dat 123/field=myfield/type=integer*2/wind=(pos=10)/mat=eq
     Displays the records that contain an value of 123 in the 
     bytes 10,11 (converted as integer*2) of the field myfield.
     If bytes 10-11 do not exist in the field, the match returns false.

 11. DIX/FILE data.dat 123:456/field=myfield/wind=(pos=10,siz=4)/mat=Range
     Displays the records that contain an value between 123 and 456 in the 
     bytes 10-13 (converted as integer*4 (size=4)) of the field myfield.
     If bytes 10-13 do not exist in the field, the match returns false.
    
 12. DIX/file data.dat *str*ing1*/mat=match/wild 1234/matc=eq/field=myfield
     search for a record that match *str*ing1* 
     AND the next record contains the value 1234 in field myfield.

 13. DIX/FILE data.dat string1 string2 string3
     Will search for a record that contains "string1" 
              AND the next record contains "string2" 
             AND the third record contains "string3".
     Record 1 will be displayed, record 2 and 3 not.

 14. DIX/FILE data.dat string1 string2/show string3/show
     Will search for a record that contains "string1" 
              AND the next record containing "string2" 
              AND the third record containing "string3".
     Record 1 will not be displayed, record 2 and 3 will.

 15. DIX/FILE data.dat string1 10/mat=ge/loca=recl string3
     Will search for a record that contains "string1" 
                      AND the next record has a recordlength of 10 or more, 
                      AND the 3 record contains string3

 16. DIX/FILE SYSUAF RESTRICTED/field=*flag*/mat=eq
     Will search all sysuaf records that have ONLY the restricted flag

 17. DIX/FILE SYSUAF DISACNT/field=*flag*/mat=ge
     Will search all sysuaf records that have AT LEAST the DISACNT flag

 18. dix/file filename "1"/win=(pos=0,size=1)/log=and,1/loca=recl/match=eq
     Will search all records with a ! in the first position
     and no more on the line (record length=1)

 19. dix/file filename 10:12/loca=recl/match=range
     Will search all records with a record length between 10 and 12
</pre>
<a name="99">
<h3 Align=center><a href="dix_help_idx_3.html#40" target="index">DIX Record_searches SEARCH_Qualifiers </a> </h3>
<pre>

</pre>
<a name="100">
<h3 Align=center><a href="dix_help_idx_4.html#83" target="index">DIX Record_searches SEARCH_Qualifiers /BACKWARD </a> </h3>
<pre>
  Search the file in the backward direction. Beware that this may take
  a long time, especially for sequential files (backspace is implemented
  as a rewind/read n-1 records.
</pre>
<a name="101">
<h3 Align=center><a href="dix_help_idx_4.html#84" target="index">DIX Record_searches SEARCH_Qualifiers /CASE_SENSITIVE </a> </h3>
<pre>
  The text in STRING is to be matched case sensitive. DCL will change
  all parameters to uppercase unless within quotes. So if you use
  /case_sensitive, make sure STRING is within quotes.
  This qualifier is positional, so each search item can have its own value.
</pre>
<a name="102">
<h3 Align=center><a href="dix_help_idx_4.html#85" target="index">DIX Record_searches SEARCH_Qualifiers /EXISTS </a> </h3>
<pre>

  If the /field is specified, DIX checks if the field is present.
  If the /WINDOW is also used, DIX checks if the range specified
  is in the record (no /FIELD) or in the field.
  The search string will not be used in this case.
  
</pre>
<a name="103">
<h3 Align=center><a href="dix_help_idx_4.html#86" target="index">DIX Record_searches SEARCH_Qualifiers /FIELD </a> </h3>
<pre>
  /FIELD=NAMEMASK

  namemask is fieldnamemask
              descriptionmask\fieldnamemask
              filenamemask\descriptionmask\fieldnamemask


  If filename mask is present, the pattern is matched against the filename
   if no match is found, this entry is skipped.
  If descriptionname mask is present, the pattern is matched against the 
   description. If no match is found, this entry is skipped.

  Normally DIX will search the string in the whole record. If you
  enter /FIELD only the field(s) that match the "fieldnamemask"
  are searched. This match uses the normal OpenVMS wildcard * and %.
  See the examples, see also the /WINDOW qualifier.

  The type of the field (integer,character etc.) determines the way the
  compares are done. For examples, for INTEGERS the compare is done in 
  binary etc.
  This qualifier is positional, so each search item can have it own value.

</pre>
<a name="104">
<h3 Align=center><a href="dix_help_idx_4.html#87" target="index">DIX Record_searches SEARCH_Qualifiers /LOCATION </a> </h3>
<pre>
  /LOCATION=location_value

  Where the data should be searched.
  location_value can be
   data : the normal data (default)
   vfc  : the vfc data
   both : in the vfc as well in the normal data
   recl : Special value for comparing record_length. In the case only the
          /match=lt,le,eq,ge,gt and range can be used. The default will be eq
</pre>
<a name="105">
<h3 Align=center><a href="dix_help_idx_4.html#88" target="index">DIX Record_searches SEARCH_Qualifiers /LOGIC </a> </h3>
<pre>
 /LOGIC=AND
 /LOGIC=OR   !Default

  If you specify /LOGIC=AND, this string must match as well as the next.
  This qualifier is positional, so each search item can have it own value.
  Example

  STRING1/LOGIC=AND,STRING2

  Matches only if both STRING1 and STRING2 are found.

  STRING1/LOGIC=OR,STRING2   (the /logic=or is default)

  Matches only if either STRING1 or STRING2 are found.

  STRING/LOGIC=AND,STRING2,STRING3

  Matches only if either (STRING1 and STRING2) or STRING3 is found.

  
</pre>
<a name="106">
<h3 Align=center><a href="dix_help_idx_4.html#89" target="index">DIX Record_searches SEARCH_Qualifiers /MATCH </a> </h3>
<pre>
 /MATCH=LOCATE  Default
 /MATCH=MATCH
 /MATCH=LT 
 /MATCH=LE 
 /MATCH=EQ 
 /MATCH=GE
 /MATCH=GT
 /MATCH=RANGE 

  Defines the match.
  This qualifier is positional, so each search item can have it own value.

  See also the /wildcard qualifier 

  LOCATE : The string must occur somewhere in the (part of the) record 
  MATCH  : The string must match the whole record
   LE,LE,EQ,GE,GT :
          The value is compared with the STRING. This can be used with a /FIELD
          If the fieldvalue is a numeric value, compares are done in the normal
          numeric way. If the fieldvalue is a STRING, compares are done as 
          strings. See also the /TYPE command to overrule the default type.
          For the [R]BIT datatype DIX has the following rule:
          LE : All specified bits may be present, but not more
          GE : All specified bits must be present, but there may be more
          LT : All specified bits may not be present
          EQ : All specified bits must be present, but not more
        
  RANGE : The searchstring is LOW:HIGH. A match will be found it the value
           is between LOW and HIGH (including the boundaries). 

  Example
   123/FIELD=UAF$W_BYTLM/MATCH=GE        (binary (integer*2)   field)
   Will display all records with the UAF$W_BYTLM value &GT;=123.  (binary compare)

   XYZ/FIELD=UAF$T_USERNAME/MATCH=LT     (ascii (character*12) field)
   Will display all records with the UAF$T_USERNAME value &LT;XYZ (ascii compare)


   123:345/field=UAF$L_BYTLM/MATCH=RANGE (binary (integer*4) field)
   Will display all records with BYTLM between 124 and 345

</pre>
<a name="107">
<h3 Align=center><a href="dix_help_idx_4.html#90" target="index">DIX Record_searches SEARCH_Qualifiers /NEXT_RECORD </a> </h3>
<pre>

 With the /NEXT_RECORD you can specify a search over more than one record.
 If you specify string1,string2/next_record, DIX will look for records that
 contain string1 in this record and string2 in the next record.
 This should normally be done by using more than one parameter, and the above
 example is equivalent to : string1 string2 , but if you need more than
 6 records to match, you need this option (DCL allows only 8 parameters).
 This qualifier is positional, so each search item can have it own value.
 
</pre>
<a name="108">
<h3 Align=center><a href="dix_help_idx_4.html#91" target="index">DIX Record_searches SEARCH_Qualifiers /NOT </a> </h3>
<pre>

  The result of the test will be reversed. So a match with /LOCATE will return
  true if the string is not found.
  This qualifier is positional, so each search item can have it own value.
</pre>
<a name="109">
<h3 Align=center><a href="dix_help_idx_4.html#92" target="index">DIX Record_searches SEARCH_Qualifiers /RECORD </a> </h3>
<pre>
  /RECORD=N

  Start search at record N. If /record is not specified, DIX will start the
  search from the first (or current) record
  N can be negative, in that case DIX will start from N record before the
  end_of_file.
  See also the /LIMIT qualifier.
  Example  (assume a file of 50 records)
  
  /RECORD=5/LIMIT=10   Search record 4..14
  /RECORD=-10/LIMIT=4  Search record 41..44
  
</pre>
<a name="110">
<h3 Align=center><a href="dix_help_idx_4.html#93" target="index">DIX Record_searches SEARCH_Qualifiers /SHOW </a> </h3>
<pre>

  If no /show is given on a multi record search, the first record is displayed
  You can give a /show for any of for all records. See the examples

</pre>
<a name="111">
<h3 Align=center><a href="dix_help_idx_4.html#94" target="index">DIX Record_searches SEARCH_Qualifiers /TYPE </a> </h3>
<pre>

  /TYPE=datatype[*size]

  This allows you to overrule the default datatype (the type of the field,
  or CHARACTER if no field is given). Datatype can be any valid declaration
  f.e. INTEGER, CHARACTER, UIC, BITS  etc.
  The size has its default for each datatype (see the description help)
  "help record_format_for_descriptions field_decl"

</pre>
<a name="112">
<h3 Align=center><a href="dix_help_idx_4.html#95" target="index">DIX Record_searches SEARCH_Qualifiers /WINDOW </a> </h3>
<pre>
  /WINDOW=(position=n,size=m)
  Do not use the whole record, but take a subset. See also the /FIELD qualifier.
  Position starts at byte 0. Size defaults to 1. If the /TYPE is used, the
  size defaults to the size of the datatype.
  This qualifier is positional, so each search item can have it own value.

</pre>
<a name="113">
<h3 Align=center><a href="dix_help_idx_4.html#96" target="index">DIX Record_searches SEARCH_Qualifiers /WILDCARD </a> </h3>
<pre>
  /WILDCARD=NONE
  /WILDCARD=STANDARD	Default
  /WILDCARD=EXTENDED

  /WILDCARD=NONE     No wildcard matching is used.
  /WILDCARD=STANDARD The following wildcard characters can be used
            *     : matches all substrings (0 or more chars)
            %     : matches exactly 1 char
  /WILDCARD=EXTENDED The Following extended wildcard characters can be used
            [abc] : Matches a "a" or a "b" or a "c"
            [-abc]: Matches anything except a,b,c
            [a-z] : Matches all letters (a-z)
            [-a-z]: Matches anything except letters
            'a    : Char "a" is not longer a special char ([*%' etc)
            ~     : If in front of the searchstring , the searchstring must be in the
                    beginning of the line, if at the end of the searchstring,
                    the searchstring must be at the end of the line
            !     : Matches one or more whitespace chars


</pre>
<a name="114">
<h3 Align=center><a href="dix_help_idx_4.html#97" target="index">DIX Record_searches SEARCH_Qualifiers /VALID </a> </h3>
<pre>

  The searchstring must be converted to a specific type.
  If this conversion succeeds, this match succeeds

  This qualifier can be useful if you have specified a /FIELD with
  a wildcard somewhere, and the matching fields have different types.

</pre>
<a name="115">
<h3 Align=center><a href="dix_help_idx_2.html#10" target="index">DIX Default_descriptions </a> </h3>
<pre>
  
  DIX has a number of descriptions. They are stored in the DIX_DES.TLB
  file. If you want to add descriptions you may add them to this tlb file,
  or if you do not have write access to this file, you may add them
  to the DIX_des_user tlb file which can be placed in your own directory.
  See the help about [DIX/help] "/user_library".
  The standard descriptions are (besides a number of entries for my own use)

</pre>
<a name="116">
<h3 Align=center><a href="dix_help_idx_3.html#42" target="index">DIX Default_descriptions $AREA </a> </h3>
<pre>
   A description for a diskblock containing one or more indexed-files
    areas. You must open the indexed-file in block-mode.

    DIX[/int] indexedfile/block=1/record=n/descr=$area

   If the record=n points to a block that contains areas, this 
   description will show the contents of the area(s).

</pre>
<a name="117">
<h3 Align=center><a href="dix_help_idx_3.html#43" target="index">DIX Default_descriptions $BUCKET </a> </h3>
<pre>
   A description for a diskblock(s) containing one or more indexed-files
    buckets. You must open the indexed-file in block-mode.

    DIX[/int] indexedfile/block=k/record=n/descr=$bucket
    DIX&GT; exa *
    DIX&GT; FULL_BUCKET=1
    DIX&GT; exami/expand

    in the /block=k , the k is the bucket_size of this bucket.
    If the record=n points to a block that contains a bucket, this 
    description will show the contents of the bucket.
    All variants of the bucket (INDEX, SIDR and DATA) are supported
    If you want to see the contents of the record data in the 
    data-buckets, you must define a symbol FULL_BUCKET.

</pre>
<a name="118">
<h3 Align=center><a href="dix_help_idx_3.html#44" target="index">DIX Default_descriptions $DEFAULT </a> </h3>
<pre>

   A default desciption containing

    BYTEARR $BYTES(record_length)
    CHARACTER*(record_length) $LINE    
    CHARACTER $CHARS(record_length)

</pre>
<a name="119">
<h3 Align=center><a href="dix_help_idx_3.html#45" target="index">DIX Default_descriptions $KEY </a> </h3>
<pre>
   A description for a diskblock(s) containing one or more indexed-files
    key blocks. You must open the indexed-file in block-mode.
    DIX[/int] indexedfile/block=1/record=n/descr=$key

    If the record=n points to a block that contains a key block, this 
    description will show the contents of the key.

</pre>
<a name="120">
<h3 Align=center><a href="dix_help_idx_3.html#46" target="index">DIX Default_descriptions $PROLOGUE </a> </h3>
<pre>

   A description for a diskblock(s) containing and indexed/relative-file
    prologue block. You must open the indexed-file in block-mode.
    The prologue block is the first block in the file.

    DIX[/int] indexedfile/block=1/record=1/descr=$prologue


</pre>
<a name="121">
<h3 Align=center><a href="dix_help_idx_3.html#47" target="index">DIX Default_descriptions $LINE </a> </h3>
<pre>

    The whole record will be display as a character line.
    Unprintables will be displayed depending on the "SET FORMAT" command


</pre>
<a name="122">
<h3 Align=center><a href="dix_help_idx_3.html#48" target="index">DIX Default_descriptions *DAF*.DAT </a> </h3>
<pre>

    The layout of the All-In-1/office-server DAF file records.

</pre>
<a name="123">
<h3 Align=center><a href="dix_help_idx_3.html#49" target="index">DIX Default_descriptions .AUDIT$JOURNAL </a> </h3>
<pre>
 
   The layout of the security.audit$journal file.

</pre>
<a name="124">
<h3 Align=center><a href="dix_help_idx_3.html#50" target="index">DIX Default_descriptions .BCK|.SAV </a> </h3>
<pre>

  The layout of a backup saveset
  This description will match all files with names *.BCK and *.SAV

</pre>
<a name="125">
<h3 Align=center><a href="dix_help_idx_3.html#51" target="index">DIX Default_descriptions .DIR </a> </h3>
<pre>

    The layout of directory file records

</pre>
<a name="126">
<h3 Align=center><a href="dix_help_idx_3.html#52" target="index">DIX Default_descriptions ACCOUNTNG </a> </h3>
<pre>

    The layout of accountng file records
</pre>
<a name="127">
<h3 Align=center><a href="dix_help_idx_3.html#53" target="index">DIX Default_descriptions DOCDB </a> </h3>
<pre>

    The layout of the All-In-1/office-server DOCDB file records.
</pre>
<a name="128">
<h3 Align=center><a href="dix_help_idx_3.html#54" target="index">DIX Default_descriptions FILECAB </a> </h3>
<pre>

   The layout of the All-In-1/office-server FILECAB file records.

</pre>
<a name="129">
<h3 Align=center><a href="dix_help_idx_3.html#55" target="index">DIX Default_descriptions INDEXF </a> </h3>
<pre>

    The layout of the indexf.sys file records, but only those records
    that contain file headers. The first few hundred blocks contain
    a bitmap of used file headers

</pre>
<a name="130">
<h3 Align=center><a href="dix_help_idx_3.html#56" target="index">DIX Default_descriptions LMF$LURT </a> </h3>
<pre>

    The layuout of the LMF$LURT file. This file contains the information
     how many license points are needed for all computer types for
     the various types of licences

</pre>
<a name="131">
<h3 Align=center><a href="dix_help_idx_3.html#57" target="index">DIX Default_descriptions MONITOR </a> </h3>
<pre>

   Files containing monitor recording files

</pre>
<a name="132">
<h3 Align=center><a href="dix_help_idx_3.html#58" target="index">DIX Default_descriptions NETPROXY </a> </h3>
<pre>

  THe contents for the NETPROXY file

</pre>
<a name="133">
<h3 Align=center><a href="dix_help_idx_3.html#59" target="index">DIX Default_descriptions NET$PROXY </a> </h3>
<pre>

  THe contents for the NET$PROXY file

</pre>
<a name="134">
<h3 Align=center><a href="dix_help_idx_3.html#60" target="index">DIX Default_descriptions NETWORK </a> </h3>
<pre>

    The layout of the All-In-1/office-server NETWORK file records.

</pre>
<a name="135">
<h3 Align=center><a href="dix_help_idx_3.html#61" target="index">DIX Default_descriptions PARTITION </a> </h3>
<pre>

    The layout of the All-In-1/office-server PARTITION file records.

</pre>
<a name="136">
<h3 Align=center><a href="dix_help_idx_3.html#62" target="index">DIX Default_descriptions PENDING </a> </h3>
<pre>

    The layout of the All-In-1/office-server PENDING file records.

</pre>
<a name="137">
<h3 Align=center><a href="dix_help_idx_3.html#63" target="index">DIX Default_descriptions PROFILE </a> </h3>
<pre>

    The layout of the All-In-1/office-server PROFILE file records.

</pre>
<a name="138">
<h3 Align=center><a href="dix_help_idx_3.html#64" target="index">DIX Default_descriptions QUOTA.SYS </a> </h3>
<pre>
 
   The layout of diskquota files disk:[000000]QUOTA.SYS

</pre>
<a name="139">
<h3 Align=center><a href="dix_help_idx_3.html#65" target="index">DIX Default_descriptions RESERVATIONS </a> </h3>
<pre>

    The layout of the All-In-1/office-server RESERVATIONS file records.

</pre>
<a name="140">
<h3 Align=center><a href="dix_help_idx_3.html#66" target="index">DIX Default_descriptions RIGHTSLIST </a> </h3>
<pre>

    The layout of the RIGHTSLIST file records.
</pre>
<a name="141">
<h3 Align=center><a href="dix_help_idx_3.html#67" target="index">DIX Default_descriptions SYSUAF </a> </h3>
<pre>

    The layout of the SYSUAF file records.

</pre>
<a name="142">
<h3 Align=center><a href="dix_help_idx_3.html#68" target="index">DIX Default_descriptions VMS$PASSWORD_HISTORY </a> </h3>
<pre>

    The layout of the VMS$PASSWORD_HISTORY file records.

</pre>
<a name="143">
<h3 Align=center><a href="dix_help_idx_3.html#69" target="index">DIX Default_descriptions VMSMAIL_PROFILE </a> </h3>
<pre>

    The layout of the VMSMAIL_PROFILE file records.

</pre>
<a name="144">
<h3 Align=center><a href="dix_help_idx_2.html#11" target="index">DIX Case_sensitivity </a> </h3>
<pre>

  By default DIX is not case sensitive, all commands/data will
  be converted to upper case (unless within quotes).

  You can enable case_sensitivity via the interactive command
  DIX&GT; enable case or disable case

  You can also enable case_sensitivity on the command line via
  the /flag=case_sensitive, but you also need to tell DCL that
  you want case_sensitive mode via the 
  $SET PROCES/PARSE=EXTENDED.
  I am sorry, but that wil not work on VAX (and older alpha versions)

  If you  work in case_sensitive mode, all symbol/field/parameter
  names are case sensitive, and also values from commands are not
  upcased. So f.e. if you want to read a record from an indexed
  file (with the /eq=xyz qualifier), you need to specify xyz in
  the correct case (and you do not need the ""'s)

  For more info see the help about "interac set case"

  Examples 
  DIX&GT; READ/eq=system  !in case sensitive mode the key system is searched
                       !in not case_sensitive mode SYSTEM
  DIX&GT; read/eq="system"!in both cases the key system is searched

</pre>
<a name="145">
<h3 Align=center><a href="dix_help_idx_2.html#12" target="index">DIX Version_history </a> </h3>
<pre>

 Version Author       Date   Comment
  1.0     F.S.   19-jan-1991 Initial release
  1.1     F.S.    1-mar-1991 Support for sequential files
  2.0     F.S.    1-jan-1992 Use of smg routines
  2.1     F.S.   26-feb-1992 Support block io
  2.2     F.S.   27-feb-1992 Support fieldnames for bits values
  2.3     F.S.   18-mar-1992 Support for multiple files
  3.0     F.S.    1-jul-1998 Multiple changes
                              support for parameters
                              support for run-time evaluation of expressions
  3.1     F.S.   10-mar-2003 Support for scripting in interactive mode
  3.2     F.S.   16-Jun-2003 Added user defined keys
  4.0     F.S.    7-may-2004 Added user defined types
  5.0     F.S.   19-apr-2006 Added a lot of new features, see the release_notes
  6.0     F.S.    1-dec-2006 Added decwindow interface
  7.0     F.S.    1-feb-2008 Added views and a lot more
  7.1     F.S.   14-apr-2009 Added a lot of DCL compatibility
  7.2     F.S.    1-dec-2009 Added compiled scripts/indexed symbols
  8.0     F.S.    1-oct-2011 Added plot command
  8.1     F.S.   22-mar-2012 Added plotting of csv files
  8.2     F.S.   31-oct-2012 plotting pie charts.
  8.3     F.S.    1-oct-2013 Smaller enhancements, access to library modules
                             Added description and structured type symbols.
  8.4     F.S.    1-jun-2014 A lot of smaller enhancements, Added complex datatype
                             Added auto command completion (set term/auto)
</pre>
<a name="146">
<h3 Align=center><a href="dix_help_idx_2.html#13" target="index">DIX Qualifiers </a> </h3>
<pre>
</pre>
<a name="147">
<h3 Align=center><a href="dix_help_idx_3.html#73" target="index">DIX Qualifiers /AUTOSAVE </a> </h3>
<pre>
 For interactive, screen and decwindows mode only.
  Set the autosave flag to enabled. If you later exit DIX, the
  context will be saved, and you can restore with DIX/RESTORE
  See also the "modes restore","interactive_com set auto" help

</pre>
<a name="148">
<h3 Align=center><a href="dix_help_idx_3.html#74" target="index">DIX Qualifiers /ATTRIBUTES </a> </h3>
<pre>
 
   In decwindows mode only. You can set some attibutes of the decwindows
   displays. You can later change them via the interactive command
   SET DECW[/qualifiers]

  Syntax /ATTRIBUTES=(attr,attr...)

 Attr can be

  HEIGHT=n       : The height of the main display in pixels,
                    default is 80 characters, so it depends on the font
  WIDTH=n        : The width of the main display in pixels
                    Default is 30 lines, so it depends on the font
  FONT=name      : Name can be Small,Medium,Large,name=fontname
                    Default is medium on display with more than 1024
                    pixels, and small for smaller ones.
  COLOUR=display=(fore=colour,back=colour,High=colour)
                  : Change the colours for the various displays
                    Default colours are 
                     backgound=gray50,foreground=white,high=red
    Display can be
         main       The main display
         offset     The offset part of the main display
         field      The field part of the main display
         value      The value part of the main display
         bar        The scroll bars
         menu       The menu
         message    The message display
         alldisplay The all-format display
         desdisplay The description display


  

</pre>
<a name="149">
<h3 Align=center><a href="dix_help_idx_3.html#75" target="index">DIX Qualifiers /BINARY </a> </h3>
<pre>
  If the /BINARY qualifier is given, the program will display the data
  in binary. 

  Default /HEX in raw dump mode.
  Default /DECIMAL in interpreted mode.
  See also the /HEX, /BINARY and /OCTAL qualifier.

   /BINARY is a shortcut for /radix=2

</pre>
<a name="150">
<h3 Align=center><a href="dix_help_idx_3.html#76" target="index">DIX Qualifiers /BLOCKED </a> </h3>
<pre>
  /BLOCKED[=blocksize]
  /BLOCKED[=blocksize.bytesize]

  If the /BLOCK qualifier is specified, the file is accessed via BLOCK IO.
  You can either specify a number, this will interpreted as a number of
  disk blocks, or a block.byte where you can specify part of one or more 
  blocks. The total size cannot exceed 65535.

  The data transfer is done via a blocksize 512 bytes, and 
  no recordstructure is assumed. This method can destroy file/record
  integrity and should only be used if you know what you are doing.
  Blocksize is default 1 (=512 bytes if you specify /BLOCKED).
  It can be useful for files with undefined recordtype (as the DUMP file).

  In blockmode you can use the /record=n qualifier to select the 'n'th 
   record of the /blnr=n to start the read at (virtual-) blocknumber 'n'
 
  Examples

  $DIX/INT filename/block=4	!use a block size of 4*512 bytes
  $DIX/INT filename/block=0.32   !Use a blocksize of 32 bytes
  $DIX/INT filename/block=2.32   !Use a lblocksize of 1056 (2*512+32)
  $DIX/INT filename/block=0.1056 !the same as above


  $DIX/INT filename/block=0.128/rec=6  !read blocknumber 2, bytes 128..255
  $DIX/INT filename/block=0.128/blnr=2 !read blocknumber 2, bytes 0..127
  $DIX/INT filename/block=2/rec=4      !read blocknumber 7 and 8
  $DIX/INT filename/block=2/blnr=4     !read blocknumber 4 and 5

</pre>
<a name="151">
<h3 Align=center><a href="dix_help_idx_3.html#77" target="index">DIX Qualifiers /BLNR </a> </h3>
<pre>
  /BLNR=nn

  If block mode IO, you can select a virtual blocknumber to startt the read

  $DIX/INT filename/block=0.128/rec=6  !read blocknumber 2, bytes 128..255
  $DIX/INT filename/block=0.128/blnr=2 !read blocknumber 2, bytes 0..127
  $DIX/INT filename/block=2/rec=4      !read blocknumber 7 and 8
  $DIX/INT filename/block=2/blnr=4     !read blocknumber 4 and 5


</pre>
<a name="152">
<h3 Align=center><a href="dix_help_idx_3.html#78" target="index">DIX Qualifiers /COMMAND </a> </h3>
<pre>
  /COMMAND DIXcommand(s)  In command mode
  /COMMAND=DIXcommand(s)  In interactive mode


  The command mode will start dix and execute dixcommand with all 
  functions available in interactive mode. You may specify multiple 
  commands separated by ;'s
      command;command;command..
  This mode does not allow parameters.
    

  In interactive mode (dix/inter/command=(command[,command)) [parameters]
   The will startup DIX in interactive mode, inclusive the parameters
   and execute the commands. 

  Examples

   DIX/COMMAND dir *.*/sort=(organization,date=creat)
    Will generate a list of files sorted by 
      1. Organization (idx,rel,seq) 
      2. The creating date

   DIX/INTER/COMMAND=("while true","exam uaf$t_user*","next rec","end while") -
            sysuaf

    Display a list of users defined in the sysuaf file.

</pre>
<a name="153">
<h3 Align=center><a href="dix_help_idx_3.html#79" target="index">DIX Qualifiers /COMPRESS </a> </h3>
<pre>

  Default DIX will display all fields. If you specified /COMPRESS,
  "empty" fields will not be displayed. 
  For text data "empty" means all blank (spaces, binary %X20)
  For binary data "empty" means all zero's (binary %X00)
</pre>
<a name="154">
<h3 Align=center><a href="dix_help_idx_3.html#80" target="index">DIX Qualifiers /COUNT </a> </h3>
<pre>
  /COUNT[=number]

  If the /COUNT qualifier is given, the program will dump "number"
  records . If number is omitted, DIX will default to /COUNT=1
  if a record is specified via the /LT,../GT or the /RECORD qualifier and
  to /COUNT=0 (all records) otherwise.
  This will only work in FILE_ORIENTED mode.
  The /LIMIT qualifier limits the number of records searched, the
      /COUNT the number of results
</pre>
<a name="155">
<h3 Align=center><a href="dix_help_idx_3.html#81" target="index">DIX Qualifiers /CSV </a> </h3>
<pre>
  /CSV
   /CSV=(Csv_option[,csv_option...])
  Csv_option can be
   HEADER    : Print a header line before all data
   NOQUOTES  : Do not 'quote' fields (see below)
   ALL_QUOTES: User quotes around all fields
   SEPARATOR=COMMA    : Use COMMA as separator	   (default)
   SEPARATOR=TAB      : Use TAB char as separator
   SEPARATOR=COLON    : Use COLON (:) as separator
   SEPARATOR=BAR      : Use | as separator
   SEPARATOR=SEMICOLON: Use SEMICOLON (;) as separator
   SEPARATOR=CHARACTER=%Xdd:  Use %Xdd as separator
   QUOTE=DOUBLEQUOTE   : Use the " character for quotes around fields (default)
   QUOTE=QUOTE         : Use the ' character for quotes around fields
   QUOTE=CHARACTER=%Xdd: Use the %Xdd character for quotes around field

  If you want quoting (DEFAULT) , DIX will insert the "quotecharacter" 
  around text fields and field that contain the "separatorcharacter" or space

  If you specify ALL_QUOTES, DIX will insert the "quotecharacter"
  around all fields.

  If you specify NOQUOTES, DIX will never insert the "quotecharacter"

  The header fields are regarded as "text" fields.

  See also the /SELECT qualifier for help about selection of fields

  Example

  DIX/FILE/CSV=(header,all_quotes,quote=quote,separator=semicolon) file
    Output is a file with all fields quoted, using ' as quote and ; as
    separator with a header line.

  DIX/FILE/CSV=(header,noquote,separator=char=32) file   or
  DIX/FILE/CSV=(noquote,separator=char=%X20) file
    Output is a file with no fields quoted, and SPACE as separator

</pre>
<a name="156">
<h3 Align=center><a href="dix_help_idx_3.html#82" target="index">DIX Qualifiers /DECIMAL </a> </h3>
<pre>
  If the /DECIMAL qualifier is given, the program will display the data
  in decimal. 

  Default /HEX in raw dump mode.
  Default /DECIMAL in interpreted mode.
  See also the /HEX, /BINARY, /OCTAL and /RADIX qualifier.
   /DECIMAL is a shortcut for /radix=10

</pre>
<a name="157">
<h3 Align=center><a href="dix_help_idx_3.html#83" target="index">DIX Qualifiers /DECWINDOW </a> </h3>
<pre>
  /DECWINDOW

  If the /DECWINDOW qualifier is given, the program will display a 
  record, (either interpreted or raw) and lets you specify
  editing(only in /MODIFY mode) or display commands . You can
   1. Alter display formats (raw/interpreted)
   1. Modify/insert/delete records (only in modify mode)

   Press the PF2/HELP key for info in screen mode.
  The /DECWINDOW qualifier must be the first on the command line.
  This mode will only work if you have Decwindows installed.
</pre>
<a name="158">
<h3 Align=center><a href="dix_help_idx_3.html#84" target="index">DIX Qualifiers /DEFINE </a> </h3>
<pre>

  /DEFINE=(definition[,definition...])

  A definition can be
  1. name       : this will deliver an integer symbol with the value 1
  2. name=value : DIX will try to convert value to integer. If this
                  succeeds an integer symbol will be defined. If this
                  fails a character symbol will be defined.
  See also the /script qualifier

</pre>
<a name="159">
<h3 Align=center><a href="dix_help_idx_3.html#85" target="index">DIX Qualifiers /DEMO </a> </h3>
<pre>

  DIX/DEMO [demoname]

  The [demoname] is a mask for the selection of demo's.

  Start a demonstration. If you do not specify the demoname, or the
  mask matches more than one demo DIX will display a screen with a list 
  of demo's. You can then select one and a demo slide-show will begin.

</pre>
<a name="160">
<h3 Align=center><a href="dix_help_idx_3.html#86" target="index">DIX Qualifiers /DISPLAY </a> </h3>
<pre>
   /DISPLAY=(displayitem[,displayitem...])
   /DISPLAY=ALL Default 

  Valid with /FILE only. This qualifier defines which parts of the 
                         record are printed.

  Valid displayitems are
  [NO]RECNR     : Print the record number
  [NO]RECSIZE   : Print the record size
  [NO]VFC       : Print the VFC part of the record (If the file contains vfc_data)
  [NO]DATA      : Print the data part of the record
  [NO]RFA       : Print the RFA of the record
  ALL           : Print all parts
  WHOLE_RECORD  : Do not try to format, just dump the whole record. In this case
                  all other flags are cleared. You may use /FORMAT to select the 
                  display of binary data, the default is passall. You may also
                  specify /display=(whole,[recnr],[recsize],[rfa]) to add an
                  additional record with this info.
  [NO]WRAP      : If set, DIX will wrap output to terminal width. Default is WRAP
  [NO]BIT_OFFSET: Force offsets to be displayed with the bitoffset part.
                   Normally DIX displayes bit_offsets only if somewhere in the
                   record a data field is not byte aligned.
  SEPARATOR=sep : Set the separator between offsets/fieldnames/data
                   Allowed options are
                    SEPARATOR=COMMA    : Use COMMA as separator
                    SEPARATOR=TAB      : Use TAB char as separator
                    SEPARATOR=COLON    : Use COLON (:) a separator
                    SEPARATOR=SEMICOLON: Use SEMICOLON (;) as separator
                    SEPARATOR=BAR      : Use | as separator (default)
                    SEPARATOR=CHARACTER=%Xdd:  Use %Xdd as separator
  DESCRIPTION     Display the description of a field after the field data.
 
</pre>
<a name="161">
<h3 Align=center><a href="dix_help_idx_3.html#87" target="index">DIX Qualifiers /EBCDIC </a> </h3>
<pre>
  
  The file contains EBCDIC data. 
  DIX assumes the whole record is ebcdic. You can also define fields
  with ebcdic contents. If you have a description present, DIX will
  add a /EBCDIC to all fields. If you have no description the raw display
  will display the data after conversion to ASCII
  
</pre>
<a name="162">
<h3 Align=center><a href="dix_help_idx_3.html#88" target="index">DIX Qualifiers /FAST </a> </h3>
<pre>
  /FAST=number 
  /FAST=1024  (default)
 
  If you specify /FAST, DIX will read the file bypassing RMS,  using
  SYS$QIOW to access the datablocks. This may speed up searches for
  indexed files, skipping the overhead for RMS-locking. It also allows
  you to read (not modify) files that are locked. Since DIX bypasses
  RMS locking there is no garantee that you will get the correct data,
  you are completely on your own.

  If number is positive, it specifies the size of the buffers 
    (in blocks), DIX will use for file-io.  
  If you specify number as -1, DIX will 
    map the file in memory via a sys$crmpsc function and all IO
    will be done via paging. On Alpha and IA64 DIX will choose
    between p0 and p2 space depening on the size of the file.
    Specifying number=-2, will force p2 space.

  For searches though files it may speedup things, but not always.
  It depends on how the buckets are distributed over the file.
  If the buckets are mostly sequential in the file,
  DIX can use large buffers, and read many buckets in one IO. If
  buckets are scattered over the file, these large reads will not be
  beneficial, and a normal search with the SYS$GET may be faster.
  The qualifier is supported for all types of files, but the gain for
  non-indexed files may be small.


  
    
</pre>
<a name="163">
<h3 Align=center><a href="dix_help_idx_3.html#89" target="index">DIX Qualifiers /FILE </a> </h3>
<pre>
  DIX will dump the record(s) like OpenVMS dump, or if a description 
  is given in description format. If you do not specify /COUNT DIX 
  will output all records of the file.
  The /FILE qualifier must be the first on the command line.

</pre>
<a name="164">
<h3 Align=center><a href="dix_help_idx_3.html#90" target="index">DIX Qualifiers /FLAG </a> </h3>
<pre>
  /FLAG=(name[,name...])

   Set initial mode settings for interactive, decwindows and screen mode

   name can be
   DCL_COMPATIBLE : for scripts
   DCL_FALLBACK   : dcl_compat + spawning of unknown verbs
   USE_MOUSE      : enable mouse usage
   LOW_FIRST      : for multidimensional tables
   CASE_SENSITIVE : Enable case sensitive mode

   For more info see the help in interactive_mode set ...
</pre>
<a name="165">
<h3 Align=center><a href="dix_help_idx_3.html#91" target="index">DIX Qualifiers /FOLLOW </a> </h3>
<pre>

  /FOLLOW=(begin,[skipkey])
  /FOLLOW=(end[,skipkey])
  /FOLLOW=(field[,skipkey])

  This is an easy way to generate a one line view
  The generated source for the view file is 
     "field/foll=begin|end|field[/skipkey] *"
  See the documentation about VIEWs for more info
  
  If you have a file with a description that contains a link to another file
  DIX can automatically include the fields from that file.
  If you specify /FOLLOW=BEGIN, DIX will first follow all link fields, and
     then display all fields of current description
  If you specify /FOLLOW=END, DIX will first display all fields of the
     current description, and then the follow fields.
  If you specify /FOLLOW=FIELD, DIX will follow the link directly after
     the follow field is found.
  If you ADD the skipkeys keyword, DIX will not print the keyfields of
     the followed file, since that value will probably also be a field
     in the follow field.

  Examples
   This example is a set of thee files that make a (simple) crossref
   system
  
   File 1. name.CRF_CROSS
    Contains records with 2 numbers. 
      First the (module-)number of the caller
      And then the (Module-)number of the callee
                                        
        integer*2 /file=.crf_mod_names caller_nr !link to mod_names
        integer*2 /file=.crf_mod_names called_nr !link to mod_names

   File 2. name.CRF_MOD_NAMES
    Contains the module number and the name and a link to the filename
     There is a key on the mod_nr

        integer*2    mod_nr
        character*32 mod_name
        integer*2    /file=.crf_file_names file_nr !link to file_names

   File 3. name.CRF_FILE_NAMES
    Contains the file number and the file name
     There is a key on the file_nr

        integer*2    file_nr
        character*60 file_name

    $DIX/FILE/COUNT=1/CSV=HEADER name.CRF_CROSS	!DIX will not follow the links
    "CALLER_NR","CALLED_NR"
    738,-262

    $DIX/FILE/COUNT=1/CSV=HEADER name.CRF_CROSS/FOLLOW=END
    "CALLER_NR","CALLED_NR",
       "MOD_NR","MOD_NAME","FILE_NR",
             "FILE_NR","FILE_NAME",
       "MOD_NR","MOD_NAME","FILE_NR",
             "FILE_NR","FILE_NAME"
    738,-262,				!both caller and callee
       738,"CHECK_ALLOWED_USER",66,     !info about caller number
              66,"REM_SERVER_CHECK_ACCESS",  !and its file
       -262,"SYS$VERIFY_PROXY",69,      !info about callee
              69,"SYSTEM"                    !and its file

     The indentation is only to show the actions.

    $DIX/FILE/COUNT=1/CSV=HEADER name.CRF_CROSS/FOLLOW=FIELD
     "CALLER_NR",
       "MOD_NR","MOD_NAME","FILE_NR",
         "FILE_NR","FILE_NAME",
     "CALLED_NR",
       "MOD_NR","MOD_NAME","FILE_NR",
         "FILE_NR","FILE_NAME"
     738,				!caller number
        738,"CHECK_ALLOWED_USER",66,     !its name
           66,"REM_SERVER_CHECK_ACCESS",  !and it file
     -262,                              !callee number
        -262,"SYS$VERIFY_PROXY",69,      !its name
           69,"SYSTEM"                    !and its file

     Again, the indentation is only to show the actions.

     You will see that the mod_nr and file_nr are specified twice
     If you had added a SKIPKEYS, the display would have been

    $DIX/FILE/COUNT=1/CSV=HEADER name.CRF_CROSS/FOLLOW=(FIELD,skip)
     "CALLER_NR",
       "MOD_NAME","FILE_NR",
         "FILE_NAME",
     "CALLED_NR",
       "MOD_NAME","FILE_NR",
         "FILE_NAME"
     738,			    !caller number
        "CHECK_ALLOWED_USER",66,      !its name
           "REM_SERVER_CHECK_ACCESS",  !and it file
     -262,                          !callee number
        "SYS$VERIFY_PROXY",69,        !its name
           "SYSTEM"                     !and its file

       The display of the MOD_NR/FILE_NR for the second and third 
        level files are now gone, since they are the key values

</pre>
<a name="166">
<h3 Align=center><a href="dix_help_idx_3.html#92" target="index">DIX Qualifiers /FORMAT </a> </h3>
<pre>
  /FORMAT=option
  /FORMAT=DOT     (default)

  Normally all "character"-like fields will not contain unprintable data.
  These field types are CHARACTER,xSTRING.
  If the data does contain unprintables (hex 0:1f,7f,80:9f or ff, this
  includes the TAB character) the /FORMAT qualifier determines how this 
  data should be displayed.

   Option can be
    DOT   :All unprintables are replaced by a ".". This encoding is not
            reversible, after an unprintable value is replaced by a ".", 
            DIX cannot know what the unprintable value was. This may
            be a problem in the screen mode.
    HEX   :All unprintable data is displayed as %Xdd, a hexadecimal display.
            A % in the data will be displayed as %%. This display is reversible,
            so DIX can reconstruct the original unprintable value.
            If you are in this mode, on input a % must be entered as %%
    PASSALL:DIX will not change the unprintable data. The data is displayed as
            it is. THis mode will not work in screen mode, and maybe poorly
            when the output device is a terminal.
    DUMP   :Unprintable bytes are represented by a 2 or 3 letter mnemonic
            like &LT;DEL&GT; or &LT;CR&GT;. A &LT; in the text will be displayed as &LT;&LT;.
            This display is reversible, so DIX can reconstruct the original 
            unprintable value.
            If you are in this mode, on input a &LT; must be entered as &LT;&LT;

</pre>
<a name="167">
<h3 Align=center><a href="dix_help_idx_3.html#93" target="index">DIX Qualifiers /HEX </a> </h3>
<pre>
  
  If the /HEX qualifier is given, the program will display the data
  in Hexadecimal.
  In interpreted mode the CHARACTER*(*) fields will be dumped in
  ascending order separated by spaces. All other fields will be dumped
  in descending byte order (the OpenVMS standard).

  Default /HEX in raw dump mode.
  Default /DECIMAL in interpreted mode.
  See also the /HEX, /BINARY, /OCTAL and /RADIX qualifier.

   /HEX is a shortcut for /radix=16

</pre>
<a name="168">
<h3 Align=center><a href="dix_help_idx_3.html#94" target="index">DIX Qualifiers /INTERACTIVE </a> </h3>
<pre>

  Enters INTERACTIVE mode. This is a commandline mode that allows you to
  enter commands at the prompt. This mode us useful for DCL procedures.
  See the INTERACTIVE_COMMANDS help for possible commands. 
  This mode also supports scripting commands (IF, GOTO etc).

  The /INTERACTIVE qualifier must be the first on the command line.

  Example:

  $ DIX/INTERACTIVE SYSUAF/EQ=SYSTEM
  Processing file :SYS$COMMON:[SYSEXE]SYSUAF.DAT;1/NOMOD
  Using description:DSA0:[PROGRAMS.DIX]DIX_DES.TLB;9(SYSUAF)
  DIX&GT;disp *pwd*
  340.0|UAF$Q_PWD(1)      |22B619B5
  344.0|UAF$Q_PWD(2)      |E19FAE22
  348.0|UAF$Q_PWD2(1)     |00000000
  352.0|UAF$Q_PWD2(2)     |00000000
  362.0|UAF$B_PWD_LENGTH  |8
  372.0|UAF$Q_PWD_LIFETIME|30 00:00:00.00
  380.0|UAF$Q_PWD_DATE    |17-MAY-2002 18:34:12.00
  388.0|UAF$Q_PWD2_DATE   |17-NOV-1858 00:00:00.00
  DIX&GT;EXIT

  You can type HELP at the prompt to obtain online help.

</pre>
<a name="169">
<h3 Align=center><a href="dix_help_idx_3.html#95" target="index">DIX Qualifiers /KEYBOARD </a> </h3>
<pre>
  /KEYBOARD=value
   Define the input keyboard. Value can be
    Normal : the LK45X keyboard layout
    PC     : The normal pc-type keyboard. Since the PC-keyboard
             misses some keys, those keys are redefined. This is
             visible in the help.
             f13..f20 are displayed as Shift-F3..Shift-f10
             Find                      Home
             Select                    End
             Next_screen               PageDown
             Prev_screen               Pageup
    LAPTOP : The normal LAPTOP misses also the PF1-PF4 keys, they
             are redefined to ^F,^G,^K and ^L as well as the PC
             keyboard modifications.

    EXTENDED: Use extend input method for command input
              See the set terminal/exten for more info

</pre>
<a name="170">
<h3 Align=center><a href="dix_help_idx_3.html#96" target="index">DIX Qualifiers /LIMIT </a> </h3>
<pre>
 
  Set limits to the records DIX will process from this file
  
  For indexed files
   /LIMIT=(value=end,key=nn) 	     !limit to key value &LT;=end
   /LIMIT=(value=(begin,end),key=nn) !limit to key values &GT;=beg and &LT;=end
   /LIMIT=(number,value=(begin,end),key=nn) !limit to record numbers 
                                            !&GT;=beg and &LT;=end for key nn

  For non-indexed files or if you do not want to use key values but recordnumbers
   /LIMIT=(number,value=end)         !limit to record number &LT;=end
   /LIMIT=(number,value=(begin,end)) !limit to record number &GT;=beg and &LT;=end
  
  Limit the number of records searched. If /limit is not specified
  DIX will process all records of the file.

  If /LIMIT=VALUE=nnnnn      the nnnnn is the last record number searched
  If /LIMIT=VALUE=(xyx,key)  the xyz is the last key value processed

  Together with the /RECORD, you can search a part of the file
  The /COUNT qualifier limits the number of records printed.

  If the begin is set, DIX will position the file on the first record
  that satisfies the record/key value. 
  If the end is set, DIX will issue a warning when the 
  recordnumber/keyvalue exceeds the value

  Example

   $DIX/FILE myfile.dat/limit=value=10 
     Will process records 1..10 of the file
   $DIX/FILE myfile.dat/limit=value=(4,10) 
     Will process records 4..10 of the file
   $DIX/FILE myfile.dat/limit=(key=0,value=("A","B") )
     Will process records with keyvalues &GT;="A" and &LT;="B"  of the file

</pre>
<a name="171">
<h3 Align=center><a href="dix_help_idx_3.html#97" target="index">DIX Qualifiers /LOCKING </a> </h3>
<pre>
  /LOCKING=(val,val...)

  Val can be
  RRL      : Read all record with the RAB$M_RRL option. This means that even
             if the record is locked by another stream, DIX can read it.
             The usage is at your own risk, since any other user can
             modify the data you are looking at (and possibly change).

 OPTIMISTIC: DIX will read the record with the RAB$M_NLK option. The record
             is read, but not locked. Other streams can read the data.
             When you want to update a modified record, DIX will check if
             the record still contains the original data, and if not
             warn you, and give you the option to not modify the record.
             If the file is opened with /nomodify (default) records will
             never be locked (the file is readonly).

</pre>
<a name="172">
<h3 Align=center><a href="dix_help_idx_3.html#98" target="index">DIX Qualifiers /MARK </a> </h3>
<pre>
  If you leave the program DIX will define a symbol DIXRFA containing
  the filename and RFA of the current record. If you start DIX at a
  later moment with the same file and the /RFA qualifier, DIX will return 
  to the same record as before.
  Example
  $DIX/INTER SYSUAF/EQ=SYSTEM
  DIX&GT;EXA *        Will display all data of the SYSTEM record
  DIX&GT;READ         Will read the next record from the sysuaf
  DIX&GT;Exit         Leave DIX
  $DIX/RFA SYSUAF  Will return you to the record in sysuaf following
                   the SYSTEM record.


</pre>
<a name="173">
<h3 Align=center><a href="dix_help_idx_3.html#99" target="index">DIX Qualifiers /MAX_BYTES </a> </h3>
<pre>
 
   /MAX_BYTES=n

   Limit the read from the file to maximum 'n' bytes
 
   Example

   DIX/FILE filename/max_bytes=10

     Dump the first 10 bytes of all records in the file.

  
</pre>
<a name="174">
<h3 Align=center><a href="dix_help_idx_3.html#100" target="index">DIX Qualifiers /MODIFY </a> </h3>
<pre>

  If the /MODIFY qualifier is specified, you are allowed to modify
  /delete/insert records, Either in interactive or screen mode, and
  in raw (DEP BYTE_OFFSET=VALUE) or description mode (DEP field_name=value).
  The /WRITE qualifier is a synonym for /MODIFY

</pre>
<a name="175">
<h3 Align=center><a href="dix_help_idx_3.html#101" target="index">DIX Qualifiers /MOUSE </a> </h3>
<pre>
  /MOUSE    (default)
  /NOMOUSE

  Enable the usage of the mouse in screen (SMG) mode.
  Default mouse_usage is enabled, but if you want, you can disable it to
  allow the mouse for selecting text.
  In the interactive mode the mouse usage can be enabled/disabled via the
  set mouse command.
</pre>
<a name="176">
<h3 Align=center><a href="dix_help_idx_3.html#102" target="index">DIX Qualifiers /MULTI_FILE </a> </h3>
<pre>

  Normally DIX will open only one file. If you specify more than
  one file (via wildcard or list), the program will prompt you which
  file to use. If you specify /MULTI_FILE, DIX will open all files
  and lets you switch between them.

  If you specify dix/file, multi_file is the default.

</pre>
<a name="177">
<h3 Align=center><a href="dix_help_idx_3.html#103" target="index">DIX Qualifiers /OFFSET </a> </h3>
<pre>
  /[no]OFFSET
  /OFFSET=DECIMAL Default
  /OFFSET=HEX       
  /OFFSET=BINARY
  /OFFSET=DECIMAL

  If the /NOOFFSET qualifier is given, the program will not display
  the  byte offsets of the data. Default is /OFFSET(=decimal)

</pre>
<a name="178">
<h3 Align=center><a href="dix_help_idx_3.html#104" target="index">DIX Qualifiers /OCTAL </a> </h3>
<pre>
  If the /OCTAL qualifier is given, the program will display the data
  in octal. 

  Default /HEX in raw dump mode.
  Default /DECIMAL in interpreted mode.
  See also the /HEX, /DECIMAL and /BINARY and /RADIX qualifier.

   /OCTAL is a shortcut for /radix=8

</pre>
<a name="179">
<h3 Align=center><a href="dix_help_idx_3.html#105" target="index">DIX Qualifiers /OUTPUT </a> </h3>
<pre>
  /OUTPUT=Filename

  Give an alternative output file. This qualifier will only be used if you
  specify the /FILE qualifier. Default is the terminal.
  If you specified /WIDE the width will be 132.
  If you specified /WIDTH=nn, the width will be nn (up to 4095)

</pre>
<a name="180">
<h3 Align=center><a href="dix_help_idx_3.html#106" target="index">DIX Qualifiers /RADIX </a> </h3>
<pre>

  /RADIX=nn   nn=2..36

  Display/modify data in any radix. 
  This is the general case of /hex, /decimal, /octal and /binary

</pre>
<a name="181">
<h3 Align=center><a href="dix_help_idx_3.html#107" target="index">DIX Qualifiers /RAW </a> </h3>
<pre>

  If DIX can find a description, DIX will use it. If you specify /RAW
  DIX will display in RAW mode even if it can find a description.


</pre>
<a name="182">
<h3 Align=center><a href="dix_help_idx_3.html#108" target="index">DIX Qualifiers /RFA </a> </h3>
<pre>
  /RFA=(rfaval)

   Can be used to select a specific record by rfa
  rfaval is either a 3 16bits number value (like dump)
    bucketnrl,bucketnrh,offset
  or a 32 bits bucketnr, followed by a 16bit offset

  example
   $ DIX FILE.DAT/RFA=(100,12)    !Bucket=100, offset=12	
   $ DIX FILE.DAT/RFA=(100,3,12)  !Bucket=3*65536+100, offset=12	

</pre>
<a name="183">
<h3 Align=center><a href="dix_help_idx_3.html#109" target="index">DIX Qualifiers /SCREEN </a> </h3>
<pre>
  /SCREEN

  If the /SCREEN qualifier is given, the program will display a 
  record, (either interpreted or raw) and lets you specify
  editing(only in /MODIFY mode) or display commands . You can
   1. Alter display formats (raw/interpreted)
   2. Modify description files
   3. Create description files
   4. Modify/insert/delete records (only in modify mode)

   Press the PF2/HELP key for info in screen mode.
  The /SCREEN qualifier must be the first on the command line.
</pre>
<a name="184">
<h3 Align=center><a href="dix_help_idx_3.html#110" target="index">DIX Qualifiers /SCRIPT </a> </h3>
<pre>
  /SCRIPT=filename

  If interactive mode, if you enter /script=file, DIX will take commands
  from that file (defaultfilename=.DIX), and return to DCL.
  See also the /define qualifier and the /command qualifier
  If you are in dcl_compatable mode, the default filename is .COM

</pre>
<a name="185">
<h3 Align=center><a href="dix_help_idx_3.html#111" target="index">DIX Qualifiers /SELECT </a> </h3>
<pre>
  /SELECT=(name[,name..])
 In the /FILE mode, DIX will print all fields (of all desriptions) to a file. 
 If you specify /SELECT, DIX will display only fields with a name that matches
 one of the name(s) of the /SELECT. Wildcards (* and %) can be used.
 The value is [filemask\][descriptionmask\]fieldmask. 
 If only one \ is found, it is the descriptionmask, and the filemask is *\ .
 If no description mask is given, all description (for the current file) are used.
 
 There is one special name
   $LINE : this will display the whole record as a single line, asif a
           description with one line "CHARACTER*32767 LINE" has been given.
                                                            
 Examples:

  DIX/FILE SYSUAF/EQ=SYSTEM              will display all the known fields.
  DIX/FILE SYSUAF/EQ=SYSTEM/SELEC=*PWD*  will display only the fields
                                             with PWD in the name.
  DIX/FILE SYSUAF/EQ=SYSTEM/SELEC=UAF$P* will display only the fields
                                             beginning with UAF$P
  DIX/FILE SYSUAF/des=(sysuaf,special) -
     /EQ=SYSTEM/SELEC=(SYS*\UAF$P*,SPE*\TEMP*)
                                         will display only the fields that
                                         match UAF$P* in the description SYSUAF
                                         or TEMP* in the description SPECIAL
  DIX/FILE SYSUAF/des=(sysuaf,special) -
     /EQ=SYSTEM/SELEC=(TEMP*)
                                         will display only the fields that
                                         match TEMP* in the description SYSUAF
                                         or TEMP* in the description SPECIAL

  DIX/FILE SYSUAF /select=$LINE.         Display each record with a single
                                         description "CHARACTER*32767"

  DIX/FILE a*.dat/MULTI/sel=(ax*\*\field1,ay*\*\field2)
                                         Dump all files a*.dat. For the ax*.dat
                                         files all field1 fields are dsiplayed, 
                                         and for the ay*.dat the field2 fields.
                                         All other fields (also in other files) 
                                         are NOT displayed.

  The select is case insensitive.
</pre>
<a name="186">
<h3 Align=center><a href="dix_help_idx_3.html#112" target="index">DIX Qualifiers /SHARED </a> </h3>
<pre>

  /SHARED    Default in DIX mode
  /NOSHARED  Default in DCL mode

  Open the file share or not shared.
	

</pre>
<a name="187">
<h3 Align=center><a href="dix_help_idx_3.html#113" target="index">DIX Qualifiers /STARTUP </a> </h3>
<pre>
  /STARTUP=filename
  /STARTUP=DIX_INI   Default

  Process commands from a startup file. The default filename is SYS$LOGIN:.INI 
  See the topic about the interactive_commands about allowed commands.
  If the qualifier is defaulted, a missing file (sys$login:DIX_ini.ini) will not
  be signalled. If you specify /startup explicitly, the file must exist.

</pre>
<a name="188">
<h3 Align=center><a href="dix_help_idx_3.html#114" target="index">DIX Qualifiers /STRICT </a> </h3>
<pre>
  /STRICT=(mode[,...])
  Sets the STRICT mode for DIX for this level. Deeper levels inherit
  the strict mode from the outer levels.

  Normally DIX is not very strict in the symbol handling.
  You can define new symbols by typing
  1. a=10 (define the symbol a , type integer, value 10)
  and then say
  2. a="SKLFG" (redefine a to type character, value "SKLFG"

   TYPING      : Once a symbol is created, you cannot change the type anymore
                 In the example above you can do 1. but not 2.
   DECLARATION : All symbols have to be declared before usage
                 This also disallows calling subroutines or @ files
                   and not having the same number of arguments 
                   given and declared.
   LOCAL       : Even with /DECLARATION, symbols from an outer level
                 can be used. With /LOCAL this is not allowed.

</pre>
<a name="189">
<h3 Align=center><a href="dix_help_idx_3.html#115" target="index">DIX Qualifiers /SYMBOL </a> </h3>
<pre>
  /SYMBOL=symbolname
  
  If you specify /SYMBOL and DIX operates in /FILE mode, the
  result is printed to the output file, and symbols are defined for
  each fieldname.
  for example
  $ DIX/FILE  sysuaf/eq=system/select=*pwd*/symb=test
    will display
  %Recordsize = 644
  340.0|UAF$Q_PWD(1)          |22B619B5
  344.0|UAF$Q_PWD(2)          |E19FAE22
  348.0|UAF$Q_PWD2(1)         |00000000
  352.0|UAF$Q_PWD2(2)         |00000000
  362.0|UAF$B_PWD_LENGTH      |8
  372.0|UAF$Q_PWD_LIFETIME    |30 00:00:00.00
  380.0|UAF$Q_PWD_DATE        |17-MAY-2002 18:34:12.00
  388.0|UAF$Q_PWD2_DATE       |17-NOV-1858 00:00:00.00
    But also the following symbols will be set
  $show symbol test*
  TESTUAF$B_PWD_LENGTH = "8"
  TESTUAF$Q_PWD(1) = "22B619B5"
  TESTUAF$Q_PWD(2) = "E19FAE22"
  TESTUAF$Q_PWD2(1) = "00000000"
  TESTUAF$Q_PWD2(2) = "00000000"
  TESTUAF$Q_PWD2_DATE = "17-NOV-1858 00:00:00.00"
  TESTUAF$Q_PWD_DATE = "17-MAY-2002 18:34:12.00"
  TESTUAF$Q_PWD_LIFETIME = "30 00:00:00.00"

  This makes it easy to use DIX in command procedures.

</pre>
<a name="190">
<h3 Align=center><a href="dix_help_idx_3.html#116" target="index">DIX Qualifiers /USER_LIBRARY </a> </h3>
<pre>
  
  /USER_LIBRARY=usertlbfile
  /USER_LIBRARY=DIX_DES_USER (default)

  If you specify /USER_LIBRARY (default), DIX will use this .TLB file
  for extra description records. 
  The default filespecification is SYS$LOGIN:.TLB
  So if you pace a DIX_DES_USER.TLB in your login directory, DIX can 
  it. In this file you can store your own descriptions, if you do not
  have write access to the default DIX_DES.TLB file.

</pre>
<a name="191">
<h3 Align=center><a href="dix_help_idx_3.html#117" target="index">DIX Qualifiers /SYSTEM_LIBRARY </a> </h3>
<pre>
  
  /SYSTEM_LIBRARY=systemtlbfile
  /SYSTEM_LIBRARY=DIX_DES (default)

  If you specify /SYSTEM_LIBRARY (default), DIX will use this .TLB file
  for systemwide description records. 
  The default filespecification is DIX-image-directory:.TLB
  If you want to add your own descriptions, you may add them in this
  file, or (if you do not have write access to this file) in the
  DIX_DES_USER tlb file . See the help about [DIX/help] "/USER_LIBRARY".

</pre>
<a name="192">
<h3 Align=center><a href="dix_help_idx_3.html#118" target="index">DIX Qualifiers /WIDE </a> </h3>
<pre>

  Set the output width (/INFO en /FILE) to 132.
  This is a shorthand for /WIDTH=132.

</pre>
<a name="193">
<h3 Align=center><a href="dix_help_idx_3.html#119" target="index">DIX Qualifiers /WIDTH </a> </h3>
<pre>
  /WIDTH=nn

  Set the output width (/INFO and /FILE) to nn
  nn will be clipped between minimum 80 and maximum 4095.
</pre>
<a name="194">
<h3 Align=center><a href="dix_help_idx_3.html#120" target="index">DIX Qualifiers /WRITE </a> </h3>
<pre>

  If the /WRITE qualifier is specified, you are allowed to modify
  /delete/insert records, Either in interactive or screen mode, and
  in raw (DEP BYTE_OFFSET=VALUE) or description mode (DEP field_name=value).
  The /WRITE qualifier is a synonym for /MODIFY

</pre>
<a name="195">
<h3 Align=center><a href="dix_help_idx_2.html#14" target="index">DIX INTERACTIVE_COMMANDS </a> </h3>
<pre>

 If you specify /INTERACTIVE the program will enter commandline mode.
 It will prompt you for commands. Lines can be continuated with a -
 on the last position of the line (like DCL). 
 The only exception is the variable-- command, so if you want a continuation
  line ending on a -(minus) be sure to add a space between the two -'s
    a = a - -   (mind the space between the -'s) wil be a=a-10
       10  
   versus
    a --        will be a--

 Blanks are not significant, except in symbol names, verbs and strings.
 DIX is by default not case sensitive, except within strings.
 DIX can be set to case_sensitive mode, see the help about "set case"

 DIX has a powerful set of commands to enable scripting inside a command file.
 
 See the @file_and_commands_in_file help topic.

 You can make a one-line command list. To do this you must start the command 
 with PIPE or a ; and separate the commands with a ;
 Example:
   DIX&GT;PIPE for k=1,10 ; evalu k ; endfor
    will create pseudo-command file containing 
     for k=1,10
     evalu k 
     endfor
   DIX&GT;; for k=1,10 ; evalu k ; endfor    !alternative version

  And execute it. In this way you can use the 'file_commands' on the command line
  If DCL mode enabled, DIX expects each line to start with a $ (all others are 
  data lines). To help you in DCL mode DIX will automatically insert a $ before
  each line, unless the first line starts with a $. In that case DIX will assume
  you understand the need for leading $.
  Example (in DCL mode)
 
  DIX&GT; ;show time;show time;show time   
     dix will insert a dollar before each line
  DIX&GT; ;$type sys$input;line1;line2;$show time
     Since the first line starts with a $, DIX assumes you understand the need
     for a $ before each command. Line2 and line3 will be regarded as data 
     for the type command.

  If you enter a command without a verb, DIX will try to evaluate the line
   as an expression and print the result, so an input like
  DIX&GT; 10*10	!will give the answer
  100           !just as if you had typed DIX&GT; eval 10*10

</pre>
<a name="196">
<h3 Align=center><a href="dix_help_idx_3.html#122" target="index">DIX INTERACTIVE_COMMANDS Output_modes </a> </h3>
<pre>

   Normally DIX will print the output of the commands to the terminal
   (or the filename given with @command/out=filename)

   Some commands (the ones with possibly a lot of output) accept the 
     /OUTPUT=filename qualifier : Output to a file
     /PAGE qualifier            : Output per page
     /SCREEN qualifier          : Get all output first and then let
                                  you look at it in a window.

   If the outputfilename is preceeded by a # or DCL: or DCL::, 
    DIX will take the rest of thefilename as a symbolname, 
    and store results in (DCL_) symbols 
    name,name_1,name_2...name_n. 
    The symbol name_cnt will be filled with the highest index (might be 0)
    In this way you can use DIX to  define dcl symbols , e.g. after 
    $dix/comm/out=dcl:abc say 4+5
    the DCL_symbol ABC will be defined with the value 9
   
    DCL:: will define global symbols, and DCL: local ones 

           Example: DIX&GT;dir/out=dcl:tmp.tmp ; 
                    DIX&GT;open lun dcl:tmp.tmp ; 
                    DIX&GT;proces data
                    DIX&GT;close lun [/dispose=delete]
                Or  DIX&GT;type mem:tmp.tmp

    If the outputfilename is preceded by MEM:, the output is stored
    in a memory table. F.e. dir/out=mem:tmp.tmp ; 
                            open lun mem:tmp.tmp ; 
                            proces data
                            close lun [/dispose=delete]

    The output files generated via the mem: and dcl: will be treated as
     files, so you can also do a directory mem:*. These 'files' can also
     be deleted. The names may contain letters,digits and ., but the first
     character must be a letter

    The 'device'names mem: and dcl: can be shown and changed via the
     set/show extra_devices

   For all commands you can redirect the output to a (one dimensional)
   (DIX_)symbol via the "symbolname &LT; command" syntax

   You may also use the &LT; syntax to get a count of lines/words/chars
    the output has generated, if you precede the symbolname with a #
    (or specifying only a #), see the examples below

    Example                   !default to screen
    DIX&GT; SHOW SYMBOL
    %OVERFLOW=False
    $STATUS=00000001
    $SEVERITY=1
    $DESCRIPTION=""
    $FILE=""
    $NRARGS=0

    DIX&GT; test&LT;show symbol     !Output to symbol testno output
    DIX&GT; Show symb/all test   !show the symbol (contains 6 lines)
    TEST(1)="%OVERFLOW=False"
    TEST(2)="$STATUS=00000001"
    TEST(3)="$SEVERITY=1"
    TEST(4)="$DESCRIPTION="""
    TEST(5)="$FILE="""
    TEST(6)="$NRARGS=0"

    DIX&GT;#&LT;show symbol	      !example of counting
    %OVERFLOW=False           !the normal output
    $STATUS=00000001
    $SEVERITY=1
    $DESCRIPTION=""
    $FILE=""
    $NRARGS=0
    TEST= table(6)
    7 lines, 7 partial lines, 7 words, 88 characters printed  !and the counters

    DIX&GT;#test&LT;show symbol     !example of counting/symbol output
    7 lines, 7 partial lines, 7 words, 88 characters printed
    DIX&GT;		      !no output, except for count line
    DIX&GT;show symb test
    TEST= table(7)	      !test is a table of 7 elements

  Example for output file specifications

   DIX&GT; show symbols/out=tst.dat	   !output to the file test.dat
   DIX&GT; show symbols/out=#abc              !output to ABC, ABC_1, ABS_2...
   DIX&GT; show symbols/out=mem:name          !output to memory file name
   DIX&GT; show symbols/out=dcl:name          !output to dcl symbol 'file' name

   $DIX/COMMAND show symbols/out=dcl:name  !output to dcl symbol 'file' name
   $show symb name*                        !and on dcl level the sybols are there
    NAME_1 = "$ARCHITECTURE="ALPHA""
    NAME_2 = "$DESCRIPTION="""
    NAME_3 = "$DIX_VERSION="8.6""
    NAME_4 = "$FILE="""
    NAME_5 = "$NRARGS=0"
    NAME_6 = "$SEVERITY=1"
    NAME_7 = "$STATUS=00000001"
    NAME_8 = "%OVERFLOW=False"
    NAME_CNT = "8"

</pre>
<a name="197">
<h3 Align=center><a href="dix_help_idx_3.html#123" target="index">DIX INTERACTIVE_COMMANDS @file_and_commands_in_file </a> </h3>
<pre>
  Format
   @filename[/output=filename][/[no]verb[=readin]][/usage]-
            [/dcl_compatible[=value]]-
            [/verify] -
            [expression[,expression...]

  Take the commands from a command file. The default filespec is
  'this_directory'.DIX , or .COM if in dcl compatible mode.

  The expressions will be available in the subroutine as local symbols
  with the names Pn (As DCL) or any name the ENTRY statement gives them.
  There is no limit to the number of arguments.
  There is also a symbol $NRARGS that contains the number of arguments.
  See also the help about the ENTRY command.

  The /[no]verbs decides if verb symbolsubstitution is ON or OFF for
   commands in the file (default is OFF). The OFF mode allows DIX to
   precompile all statements in the file, make execution a lot faster.
   The ON mode disables the precompile mode, because DIX does not know
   if the verb may have been changed (f.e. like dir*ectory = "dir/col=1")
 
  If you specify /verb=readin, the verbs will be translated on reading the
   command file, but not again on execution of the statements. In this
   way you can use (global-)symbols for your verbs, but you cannot change
   the verbs in the command file.

  The /usage will display a control-t like line after execution of
   each command. If the user had set the statistics to /usage
   DIX will output a line for the usage data after execution of the command file

  The /[NO]DCL_compatile decides if the command file is executed in DCL mode
   If not specified, DIX uses the current setting for DCL_COMPAT
     set dcl_compat compatible
     set dcl_compat fallback

   /dcl_compatile=none       No dcl functionality
   /dcl_compatile=compatible Support for leading $, replace .xx. by =&LT;&GT; 
   /dcl_compatile=fallback   compatible + Unknown dix verbs will be spawned to dcl


  The file is read into memory before any statement is executed. At this
  point all loop-structures are checked for correct overlap, so 
   FOR
    IF
    ENDFOR
   ENDIF
  is not accepted. 

  During this phase DIX will pre-compile all statements in the file
  (if verb substitution is OFF for command procedures) , See the remarks
  about /verb above.

  Also Verb symbol-substitution for loopcontrol verbs like IF, LOOP, 
  [END]FOR, [END]WHILE, etc. is NOT supported.

  Loop commands can also be entered in terminal input mode  (so not in a 
   command file). DIX will prompt you to enter more command lines until the 
   END statement is found, and them execute this set of commands.
   (This happens asif the commands had been entered in a command procedure
    so the command level will be one higher. THis may affect symbols)
   Support is for the IF, LOOP, SWITCH, REPEAT, and WHILE statement.

 Inside a command file you can use the following extra commands.

</pre>
<a name="198">
<h3 Align=center><a href="dix_help_idx_4.html#181" target="index">DIX INTERACTIVE_COMMANDS @file_and_commands_in_file CALL </a> </h3>
<pre>

  Call label [expression[,expression...]
  Call to a subroutine with optional parameters
  There is no limit to the number of arguments.

  See help about SUBROUTINE statement
 
  The parameters will be local symbols for the SUBROUTINE, see the help
  about [DIX/help] interactive symbols.

</pre>
<a name="199">
<h3 Align=center><a href="dix_help_idx_4.html#182" target="index">DIX INTERACTIVE_COMMANDS @file_and_commands_in_file DECK </a> </h3>
<pre>
  DECK [/DOLLARS=string] [/SYMBOL_SUBSTITUTION]

   The DECK statement is meant to allow user data to be be inside a
   command procedure (see the DCL help about DECK)
   the /DOLLARS specifies a string used to signal the end of the data
     default is /dollars=EOD. The match IS case-sensitive, so if you
     want a lowercase string, include the string within "".

   If /SYMBOL_SUBSTITUTION is set, DIX will try to substitute
   all strings between ''s. This allows you to use data lines and 
   still have symbol substitution. See example below

   DIX can operate in 2 modes
   DCL_COMPAT : The data is ended by a statement starting with a $.
                 This may be the EOD command. In this mode, all lines
                 not starting with a $ will be regarded as data (like DCL,
                 so the DECK statement is not needed.
   Normal     : The data is ended by the DOLLARS string
                 Since DIX cannot distinguish between data and commands
                 (no leading $), you must use the DECK statement.

</pre>
<a name="200">
<h3 Align=center><a href="dix_help_idx_5.html#199" target="index">DIX INTERACTIVE_COMMANDS @file_and_commands_in_file DECK Examples </a> </h3>
<pre>
  Example for DCL mode (leading $ required, so DECK is optional)

     $type sys$input      example with no deck and no EOD
     line 1		  3 data lines
     line 2
     line 3
     $exit

     $type sys$input      example with deck and eod
     $deck		  Using the $DECK
     line 1               2 data lines
     line 2
     $eod                 It stops here

  Example for dix mode  DECK statement required

     type sys$input	example with explicit /dollars
     deck/dollars=test  the test will be upcased by DIX
     line 1             2 data line
     line 2
     TEST               The terminator
     exit               Exit 

     type sys$input	example with implicit dollars (EOD)
     deck               so we stop with a line containing EOD
     line 1 nodol       2 data lines
     line 2 nodol
     EOD                The terminator

   Example with /symbol_substitution, the examples are for DIX mode

    type sys$input
    deck 		without symbol substution
    line 1 nodol 'a'    2 data lines
    line 2 nodol 'a+1'
    EOD                 Terminator
   
    This will return:
    line 1 nodol 'a'
    line 2 nodol 'a+1'

    a=10
    type sys$input
    deck/symbol	        with symbol substution
    line 1 nodol 'a+2'
    line 2 nodol 'a+3'
    EOD

    This will return:
    line 1 nodol 12
    line 2 nodol 13

   For DCL mode the example is the same, but in this case the $DECK 
   is necessary, since that is the statement with the /symbol

    $a=10
    $type sys$input
    $deck/symbol	        with symbol substution
    line 1 nodol 'a+2'
    line 2 nodol 'a+3'
    $EOD

    Read the description inline from the command file
  
    OPEN name filename/des=sys$input
    DECK
    description text
    EOD


</pre>
<a name="201">
<h3 Align=center><a href="dix_help_idx_4.html#183" target="index">DIX INTERACTIVE_COMMANDS @file_and_commands_in_file ENTRY </a> </h3>
<pre>
  ENTRY parametername[qualifiers][,parametername[qualifiers]...]

   Declare names for parameters on @ed files.
   must be the first command in the file

   If a call is make to a command file, the (optional) parameters are 
   evaluated, and the resulting value is placed in the (local) symbol
   with the name "parametername" or Pn if there are more parameters
   than parameternames.

   Qualifiers can be
   /REAL
     You may specify the size of the real with the 
      /SIZE=4,8,16
   /[U]INTEGER
   /CHARACTER
   /DATE
   /DECIMAL
   /LOGICAL      The expression given at the @ line must match the
                 type given to this symbol
   /SYMBOL
    If the parametername has a /SYMBOL qualifier, the parameter will be
    an alias to the original expression parameter. If you use the
    /SYMBOL the caller must be a SYMBOl or any subset (exept indexed symbols).
    If you change te he parameter the changes will be done to the 
    (caller-)symbol. This is a way to let the @file return output values.
    If you use /SYMBOL and the parameter is an indexed symbol, you may
    only use the whole symbol, not a subset.

   If DIX is in STRICT/DECLARATIONS mode, the number of defined and
   actual parameters must be equal.

  Example
 
  integer x=10
  @mysub 10*4,"TExt",x,41

  and the file mysub.DIX contains the following lines

  entry count/integer,name,xparam/symbol
  ...
  ...
  exit

  In the file "mysub" there will be 5 symbols defined
  COUNT  : integer with the value 40 (the expression MUST be integer).
  NAME   : character with the value "TExt"
  XPARAM : Integer with the value 10, is an alias for to symbol x.
           and modifications are done to the X symbol of the caller
  P4     : integer with the value 41
  $NRARGS: Integer with the value 4 (4 arguments)

  If there are more parameternames than parameters, the parametername
  will be defined as a character string with the value "" (empty).
  If there are more parameters than parameternames, the symbols
  P* are defined with the same type as the parameter.

  Both possibilities are not allowed with the STRICT/DECLARATION mode.  

  Examples

   Example for a subsetted table

   DIX&GT; INTEGER val(10,2)
   DIX&GT; @tt: val(1,*)
   DIX_1&GT; ENTRY MYVAL/symbol
   DIX_1&GT; show symbol myval/fu
   MYVAL(Fixed,Integer,Level=2.0,alias-&GT;VAL)=table(2)
   DIX_1&GT; say myval
   [0,0]
   DIX_1&GT; myval(2)=12
   DIX_1&GT; exit
   DIX&GT; say val
   [[0,0,0,0,0,0,0,0,0,0][12,0,0,0,0,0,0,0,0,0]]

   Example for a strucutured type
 
  DIX&GT;load/structure def_main.struct	 !load the structure
  DIX&GT;sh struc/fu def_main               !what does it look like
  DEF_MAIN, level 1                      !
  File USER50:[STUBBF.PROGRAMS.DIX.SOURCE]DEF_MAIN.STRUCT;2
  INTEGER*4              INDEX
  CHARACTER*40           MYSTR
  REAL_X*16              REAL16VAL
  INTEGER*4              EXTRA_INT
  INTEGER*4              EXTRA2(2,3)
  DIX&GT;decl/stru=def_main val             !declare a symbol of this type

  DIX&GT;say val				 !normal evalute, only values
  [0,,0.0,0,[[0,0][0,0][0,0]]]  
  DIX&GT;@tt: val.extra2(2,*)               !call a subroutine
  DIX_1&GT; entry locval/symbol             !declare a local value as alias
  DIX_1&GT; show symbol locval/fu           !is is now a table of  elements
  LOCVAL(Fixed,Integer,Level=2.0,alias-&GT;VAL)=table(3) !extra(2,1),(2,2),(2,3)
  DIX_1&GT; say locval
  [0,0,0]
  DIX_1&GT; locval(3)=31			!set the 3 (=(2,3)) to 31
  DIX_1&GT; exit
  DIX&GT; say val
  [0,,0.0,0,[[0,0][0,0][0,31]]]         !et voila
</pre>
<a name="202">
<h3 Align=center><a href="dix_help_idx_4.html#184" target="index">DIX INTERACTIVE_COMMANDS @file_and_commands_in_file GOTO </a> </h3>
<pre>

 Syntax: Goto Label

  Goto the line with this label. If the label cannot be found, 
  DIX will close this command file (and possibly its parent) until
  the input comes from a terminal or (in BATCH) exit DIX.
  The label must be visible from the current context level, so for
  example "LAB" will not be found, because "LAB" is in the repeat/until
  structure, and you cannot jump into a loop structure.

  x=1
  repeat
   lab : x=x+1
  until x&GT;5
  goto lab

</pre>
<a name="203">
<h3 Align=center><a href="dix_help_idx_4.html#185" target="index">DIX INTERACTIVE_COMMANDS @file_and_commands_in_file GOSUB </a> </h3>
<pre>
  
  Syntax: GOSUB label

  Goto the line with this label. If the label cannot be found, 
  DIX will signal an error. Depending on the current ON  state DIX
  may continue or close the command file.
  The return address will be stacked, and the RETURN command returns
  you to the next line.
  The label must be visible from the current context level, so for
  example "LAB" will not be found, because "LAB" is in the repeat/until
  structure, and you cannot jump into a loop structure.

  x=1
  repeat
   lab : x=x+1
  until x&GT;5
  gosub lab

</pre>
<a name="204">
<h3 Align=center><a href="dix_help_idx_4.html#186" target="index">DIX INTERACTIVE_COMMANDS @file_and_commands_in_file Labels </a> </h3>
<pre>
 Each line can be preceded by a label .
  The label can be any string terminated by a :
  Labelnames are not case-sensitive and can have up to 32 characters. 
  All the character must be a-z 0-9 $ or _.

  Example

  This_label12 : statement  

</pre>
<a name="205">
<h3 Align=center><a href="dix_help_idx_4.html#187" target="index">DIX INTERACTIVE_COMMANDS @file_and_commands_in_file ON </a> </h3>
<pre>

  On option [then] command

    The then is optional

  Option can be 

  Warning
  Error
  Severe
  Control_c
  overflow
 
  And can be abbreviated to one letter
 
  For the message levels:
    If an error occurs, DIX will execute 'command' for the errorlevel or
    a lower level. 

    Example

    ON error goto label_error.
    Any error and severe will jump to label_error. Warnings will be ignored.


  on overflow say "got overflow"  !say "got Overflow" if it is found

  on control_c then debug         !Jump to the debugger if you hit a ^c
  
</pre>
<a name="206">
<h3 Align=center><a href="dix_help_idx_4.html#188" target="index">DIX INTERACTIVE_COMMANDS @file_and_commands_in_file RETURN </a> </h3>
<pre>
  Will return from a previous GOSUB.

  Return without an open GOSUB is NOT signalled as an error. DCL does not
  signal it, and so does DIX.


</pre>
<a name="207">
<h3 Align=center><a href="dix_help_idx_4.html#189" target="index">DIX INTERACTIVE_COMMANDS @file_and_commands_in_file SUBROUTINE_ENDSUBROUTINE </a> </h3>
<pre>

  Format
  label:  SUBROUTINE [parametername[/qualifiers][,parametername[/qualifiers]..]]

   Defines the beginning of a subroutine in a command procedure. The
   SUBROUTINE command must be the first executable statement in a
   subroutine. The subroutine must be terminated with an ENDSUBROUTINE.
   If a call is make to a subroutine, the (optional) parameters are 
   evaluated, and the resulting value is placed in the (local) symbol
   with the name "parametername" or Pn if there are more parameters
   than parameternames.

   Qualifiers can be
   /REAL
     You may specify the size of the real with the 
      /SIZE=4,8,16
   /[U]INTEGER
   /DATE
   /DECIMAL
   /CHARACTER
   /LOGICAL      The expression given at the @ line must match the
                 type given to this symbol
   /SYMBOL
   If the parametername has a /SYMBOL qualifier, the parameter will be
   an alias to the original expression parameter. If you use the
   /SYMBOL the caller must be a SYMBOl or an scalar element of a symbol.
   If you change te he parameter the changes will be done to the 
   (caller-)symbol. This is a way to let the the SUBROUTINE return 
    output values.

   If DIX is in STRICT/DECLARATIONS mode, the number of defined and
   actual parameters must be equal.

  Example
 
  integer x=10
  Call mysub 10*4,"TExt",x,4


  mysub: subroutine count,name/character,xparam/symbol
  ...
  ...
  endsubroutine

  In the subroutine "mysub" there will be 5 symbols defined
  COUNT  : integer with the value 40
  NAME   : character with the value "TExt" (must be a character expression)
  XPARAM : Integer with the value 10, is an alias for the symbol X,
           and so modifications are done to the X symbol of the caller
  P4     : integer with the value 4
  $NRARGS: Integer with the value 4 (4 arguments)

  If there are more parameternames than parameters, the parametername
  will be defined as a character string with the value "" (empty).
  If there are more parameters than parameternames, the symbols
  P* are defined with the same type as the parameter.

  Both possibilities are not allowed with the STRICT/DECLARATION mode.  



</pre>
<a name="208">
<h3 Align=center><a href="dix_help_idx_4.html#190" target="index">DIX INTERACTIVE_COMMANDS @file_and_commands_in_file Examples </a> </h3>
<pre>

  k = 1				!define symbol k value 1
  Loop: k = k + 1                  !label + increment of symbol
  Examine field_'k'		!exam with symbol substitution
  IF (2*(k+10) &LT; 20) goto loop	!test for repeat

  This following script will increment BYTLM by 1000 for all users with
  a name that matches *A*, and have a bytlm of &GT;=50000 and a jtquota &GT;4000
  (maybe not a very useful example, but is shows the possibilities)
  
	nmod = 0
	nfnd = 0
	on error goto done
   loop:
	nfnd = nfnd + 1
	if (f$matchwild(uaf$t_username,"*A*")) goto next
	echo "Found user ''uaf$t_username'"
	if (uaf$l_bytlm &LT; 50000 | uaf$l_jtquota &LT;= 4000 ) goto next
	deposit uaf$l_bytlm='uaf$l_bytlm + 1000'
	nmod = nmod + 1
	update/quiet
	echo "Updated ''uaf$t_username' to ''uaf$l_bytlm'"
   next:	
	read
	goto loop
   done:
	echo "Found ''nfnd' users , modified ''nmod' users"


</pre>
<a name="209">
<h3 Align=center><a href="dix_help_idx_3.html#124" target="index">DIX INTERACTIVE_COMMANDS Dcl_compatibility </a> </h3>
<pre>

  DIX has a syntax very simular to DCL.  If you want to be able
  to use dcl-command files, DIX has to put in dcl_compatible mode.
  DIX will then remove leading $'s, and if if fallback mode
  it will spawn commands that are not recognized by dix.
 
  You can set/clear dcl_compatible mode via the

  SET DCL none|compatible|fallback    Or via
  @procedure/dcl[=fallback]

  You cannot change the dcl_compat mode within one procedure.

  There are 2 levels of dcl_compat mode 
  compatibility : -leading $'s are removed before parsing
                  -the DECK statement behaves dcl like
                  -.lt. , .ge. etc are replaced by the dix couterparts &LT; &GT; etc.
  fallback      : -If a command fails to be parsed by DIX (ivverb)
                   dix will spawn the commandline. Be aware that
                   spawning is not the same as execution under dcl
                   and that DIX symbols are not DCL symbols,
                   but maybe the spawn will do what you want.
  
</pre>
<a name="210">
<h3 Align=center><a href="dix_help_idx_3.html#125" target="index">DIX INTERACTIVE_COMMANDS Debugger </a> </h3>
<pre>
  Dix has a built-in debugger for the debugging of command-scripts

  You start this by @procedure/debug

  You can set/delete break and watchpoints
  You can step [/into] and go

  You can also specify most of the interactive DIX commands to
  examine/modify symbols/fields etc.

  By default the following keys are defined
  KP5     : Show calls
  PF1-KP5 : SHow call /full
  KP0     : step
  PF1-KP0 : step/into

  And you may define more via de def/key command.

  You can also store commands in a file and execute the file via 
   @file (default filespec .DIX;), the @commands can be nested 10 deep.

</pre>
<a name="211">
<h3 Align=center><a href="dix_help_idx_4.html#193" target="index">DIX INTERACTIVE_COMMANDS Debugger levels </a> </h3>
<pre>

   Each command procedure has a level

   dix&GT;@first    level 2 (the DIX&GT; prompt is level 1)
     if there is a @ line in first[.dix]  
       that procedure will be at level 3

   Since DIX is an interpreter, DIX does not know anything
   about deeper levels until the @ is reached.
   So if you are on level 2, you cannot specify breakpoints 
   on deeper levels

  On some commands you can specify lines/labels on lower levels
   via the level\line or the level\label syntax
    
</pre>
<a name="212">
<h3 Align=center><a href="dix_help_idx_4.html#194" target="index">DIX INTERACTIVE_COMMANDS Debugger cancel </a> </h3>
<pre>

   cancel break
   cancel watch
   cancel trace
</pre>
<a name="213">
<h3 Align=center><a href="dix_help_idx_5.html#212" target="index">DIX INTERACTIVE_COMMANDS Debugger cancel break </a> </h3>
<pre>

  cancel a breakpoint

    cancel break/all                          Cancel all breakpoints
    cancel break line [level\]nn              cancel Break on line number
    cancel break label [level\]labelname      cancel Break on a label
    cancel break call                         cancel Break on call
    cancel break return                       cancel Break on return
    cancel break message                      cancel Break on error level

</pre>
<a name="214">
<h3 Align=center><a href="dix_help_idx_5.html#213" target="index">DIX INTERACTIVE_COMMANDS Debugger cancel trace </a> </h3>
<pre>

  cancel a tracepoint

    cancel trace/all                          Cancel all tracepoints

    cancel trace line [level\]nn              cancel trace on line number
    cancel trace label [level\]labelname      cancel trace on a label
    cancel trace call                         cancel trace on call
    cancel trace return                       cancel trace on return
    cancel trace message                      cancel trace on error level

</pre>
<a name="215">
<h3 Align=center><a href="dix_help_idx_5.html#214" target="index">DIX INTERACTIVE_COMMANDS Debugger cancel watch </a> </h3>
<pre>

   cancel watch /all                          Cancel all watchpoints
   cancel watch name                          Cancel watchpoint "name"
 
   cancel the specified watchpoint

  Supported qualifiers

   /field          Name is a fieldname, if /field is not
                   specified, name is a symbol

</pre>
<a name="216">
<h3 Align=center><a href="dix_help_idx_4.html#195" target="index">DIX INTERACTIVE_COMMANDS Debugger go </a> </h3>
<pre>

   Go [line][label]

   (re)start processing until a breakpoint occurs
 
    optionally a line or label may be specified.
    Dix will restart execution from that line
    line or label must be in the current level

</pre>
<a name="217">
<h3 Align=center><a href="dix_help_idx_4.html#196" target="index">DIX INTERACTIVE_COMMANDS Debugger help </a> </h3>
<pre>
 
  help [token]

  Help about the debugger
</pre>
<a name="218">
<h3 Align=center><a href="dix_help_idx_4.html#197" target="index">DIX INTERACTIVE_COMMANDS Debugger set </a> </h3>
<pre>
 
  Set some things

  set break
  set watch
  set trace

</pre>
<a name="219">
<h3 Align=center><a href="dix_help_idx_5.html#218" target="index">DIX INTERACTIVE_COMMANDS Debugger set watch </a> </h3>
<pre>

   set watch name
 
  If the symbol/field matching name is touched or modified
    display the value (and the new if changed) 

  Supported qualifiers

   /field          Name is a fieldname, if /field is not
                   specified, name is a symbol

   /reference      If /reference is specified, dix will also
                   report references (not changes)
                   If /reference is not specified, DIX will
                   only report changes
   /break          If the symbol/field is touched (with /refer) or 
                   modified DIX will enter the debugger

  Watchpoints support the following qualifiers

   /when="dix_command"
     If the watchpoint is reached, DIX will execute the code specified
     The result must be a logical. It the expression evaluates to true
     the watchpoint will be taken (but the /after must be satisfied too)

   /after=n
     Take the watchpoint after the 'n'th time.
     If both the /when and the /after are specified, DIX will evaluate
     the /when first, and if that succeeds, the /after is tested.

   /do="dix_command[;dix_command...]"

     When a watchpoint is found (after the /when and the /after are
     satisfied, DIX wil execute the the commands. All commands are
     executed, even if one of them is a "go" or a "step"

</pre>
<a name="220">
<h3 Align=center><a href="dix_help_idx_5.html#219" target="index">DIX INTERACTIVE_COMMANDS Debugger set break </a> </h3>
<pre>
   
    set break line [level\]nn              Break on line number
    set break label [level\]labelname      Break on a label
    set break call                         Break on call/gosub
    set break return                       Break on return/exit
    set break message severe|error|warning Break on error level
    set break instruction instructionname  Break on a specific instruction

     Instruction names are the normal dix command verbs, the @ command
     is named AT, and the assignment (a=10) as ASSIGN.

   Both nn and labelname may be prefixed by level\ to
   set breaks on lower levels

  Supported qualifiers

   /when="dix_command"
     If the breakpoint is reached, DIX will execute the code specified
     The result must be a logical. It the expression evaluates to true
     the breakpoint will be taken (but the /after must be satisfied too)

   /after=n
     Take the breakpoint after the 'n'th time.
     If both the /when and the /after are specified, DIX will evaluate
     the /when first, and if that succeeds, the /after is tested.

   /do="dix_command[;dix_command...]"

     When a breakpoint is found (after the /when and the /after are
     satisfied, DIX wil execute the the commands. All commands are
     executed, even if one of them is a "go" or a "step"

   /temporary    Remove the breakpoint when it is reached

</pre>
<a name="221">
<h3 Align=center><a href="dix_help_idx_5.html#220" target="index">DIX INTERACTIVE_COMMANDS Debugger set trace </a> </h3>
<pre>
   
    set trace line [level\]nn              trace on line number
    set trace label [level\]labelname      trace on a label
    set trace call		           trace on call/gosub
    set trace return                       trace on Exit/return
    set trace message severe|error|warning trace on error level
    set trace instruction instructionname  trace on a specific instruction

     Instruction names are the normal dix command verbs, the @ command
     is named AT, and the assignment (a=10) as ASSIGN.

   Both nn and labelname may be prefixed by level\ to
    set tracepoints on lower levels

  Supported qualifiers

   /when="dix_command"
     If the tracepoint is reached, DIX will execute the code specified
     The result must be a logical. It the expression evaluates to true
     the tracepoint will be taken (but the /after must be satisfied too)

   /after=n
     Take the tracepoint after the 'n'th time.
     If both the /when and the /after are specified, DIX will evaluate
     the /when first, and if that succeeds, the /after is tested.

   /do="dix_command[;dix_command...]"

     When a tracepoint is found (after the /when and the /after are
     satisfied, DIX wil execute the the commands. All commands are
     executed, even if one of them is a "go" or a "step"

   /temporary    Remove the breakpoint when it is reached

</pre>
<a name="222">
<h3 Align=center><a href="dix_help_idx_4.html#198" target="index">DIX INTERACTIVE_COMMANDS Debugger show </a> </h3>
<pre>
 
   Show break    Show breakpoints
   show trace    Show tracepoints
   show watch    Show watchpoints
   show calls    Show call stack

</pre>
<a name="223">
<h3 Align=center><a href="dix_help_idx_4.html#199" target="index">DIX INTERACTIVE_COMMANDS Debugger step </a> </h3>
<pre>

   Step[/into] [line][label]

   (re)start processing until the next line
 
    optionally a line or label may be specified.
    Dix will restart execution from that line
    line or label must be in the current level

   if the line is a @ line, dix will not debug the
   deeper level unless the /into qualifier is specified

</pre>
<a name="224">
<h3 Align=center><a href="dix_help_idx_4.html#200" target="index">DIX INTERACTIVE_COMMANDS Debugger type </a> </h3>
<pre>

   type        Type the current line
   type nn     Type line nn
   type nn:mm  Type line nn:mm
   type *      Type all lines

   type level\..  Type lines from lower levels

   If you specify /full DIX will also display the
   level and the commandprocedure.

</pre>
<a name="225">
<h3 Align=center><a href="dix_help_idx_3.html#126" target="index">DIX INTERACTIVE_COMMANDS ADD </a> </h3>
<pre>

  ADD DESCRIPTION name[,name...]
  ADD VIEW name[,name...]
  ADD PARAMETER
  ADD VALUE
  ADD TYPE

  Add new descriptions/views to the current file. 
   See also the remove command.
    example 

    Add description mask

    Will add the descriptions matching mask to the current file

  Parameter/values are a special type of symbol
   By default parameter/type/value names are not case sensitive,
   unless DIX is put into case sensitive mode, see the help about
   "set case" 

   Parameter,type and values can be defined GLOBAL (/global) or 
    at a specified level via /LEVEL=n.
     n can be  1..current command level
       or     -1..-n  N levels up

   Default level is the current command level
 
    ADD PARAMETER name=value     cannot be changed
    ADD VALUE =value             May be modified

  Types are used to specify enumeration types for symbols
     See also the help about [dix/help] interactive declaration

    ADD TYPE name=value
 
    Example
    DIX&GT; Add type myvals="0=zero,1=one,10=big"	!define a type to be used
    DIX&GT; a=10					!add a new symbol	       
    DIX&GT; Set symb a/type=#myvalues		!add a fieldname list to the
                                                !symbol
    DIX&GT; Evaluate a				!Evaluate will not use fieldnames
    10
    DIX&GT; show symb a				!show symbol will use the
    A=big					!fieldnames
    DIX&GT; show symb/fu a				!show all info about a
    A(Integer*4,Level=1.0)=big
    Type : #MYVALUE (0=zero,10=big)

</pre>
<a name="226">
<h3 Align=center><a href="dix_help_idx_3.html#127" target="index">DIX INTERACTIVE_COMMANDS ANALYZE </a> </h3>
<pre>
  ANALYZE [/DISPLAY=(option,option..)] [/VERBOSE=n]

  option can be
   KEY=n           : Analyze only key
   LEVEL=n         : Analyze only key level 'n'
   LEVEL="+n"      : Analyze only the top 'n' key levels
   LEVEL=-n        : Analyze only the lowest '-n' key levels
   [NO]DATA        : Analyze the data buckets too. Since this can take al lot
                     of time, this is not the default.
   [NO]SIDR        : Display the SIDR records, this is default
   [NO]KEYBUCKETS  : Display the key buckets records, this is default
   DETAIL          : THe amount of detail 0..4
                       Be careful, this can generate a lot of output.
   OUTPUT=filename : If verbose is &GT;0, the extra output can be redirected
                     to another file. THe normal output will be in the file
                     specified with /OUTPUT=filename
   START=n         : Start analysis at bucket 'n' in chain, default=0
                      (n may be negative, last but 'n' bucket of the chain)
   END=n           : End analysis at bucket 'n' in chain, default is whole chain
                      (n may be negative, last but 'n' bucket of the chain)

  VERBOSE=0    : Just the normal output
  VERBOSE=1    : Print out the buckets read
  VERBOSE=2    : detail 1 and the bucket header info
  VERBOSE=3    : detail 2 and SIDR records and the data records
  VERBOSE=4    : detail 3 and the SIDR pointers
  If verbose&GT;0, the output of the detail option can de redirected to another
                  file. See the OUTPUT= option
  
  For more info see the help about [DIX/help] modes analyze
![DIX MODES analyze]DIX modes analyze

</pre>
<a name="227">
<h3 Align=center><a href="dix_help_idx_3.html#128" target="index">DIX INTERACTIVE_COMMANDS ASSIGN </a> </h3>
<pre>

  symbolname=value
  fieldname=value

  You can assign values to symbols or fieldnames
  Fieldnames can also be assigned via the deposit command
  There are also four special formats

   name++   name=name+1
   name--   name=name-1
   name+=n  name=name+n
   name-=n  name=name-n

   For these formats only [u]integer types (symbols or fields) are allowed

  In DCL compatible mode the symbol[d1,d2]=expression and :=expression are
  also supported for strings and integers (like dcl)

</pre>
<a name="228">
<h3 Align=center><a href="dix_help_idx_4.html#204" target="index">DIX INTERACTIVE_COMMANDS ASSIGN ASSIGN_SYMBOLS </a> </h3>
<pre>

  symbolname = value
  
  Symbol may be a table or a subset of a table. In this case value
  must either be a scalar or have the same shape as the symbol
  Examples

   a=10			!scalar assignment
   decl a(3,3)/integer  !declare an integer table(3,3)
   a(*,*) = 0		!all values(9) to 0
   a(3,*) = 10		!all values(3,*) (3 of them) to 10
   a(3,*) = [1,2,3]	!fill a(3,*) with 1,2,3 respectively

  For indexed symbols you can also modify an existing entry or add a new
   one the the indexed symbol
    declare/index=char test/int !create an indexed symbol test of type integer
    test("a")=1	                !add a new element
    test("a")=2                 !modify element "a"
    test("b")=4                 !add a new element "b"
    test("c")=test("c") + 1     !update element "c" 
                                  or create it if not yet present

  For decription type sybols you may change all individual fields
    DIX&GT;load/descr sys$input mydesc
     integer*4 testi
     real*4 testr
     character*20 testc
    ^Z
    %DIX-I-DESADD, Description sys$input:mydesc added
    DIX&GT; show des/loaded mydesc
    Name  : sys$input:mydesc
    Status : Fixed
     INTEGER*4          TESTI
     REAL_F*4           TESTR
     CHARACTER*20       TESTC
     No variable Data lines
    DIX&GT; declare/des=mydesc mysymb
    DIX&GT; show symb mysymb/fu/all
    MYSYMB(Descr=sys$input:mydesc,Level=1.0)=2 descriptions,2 expanded
     MYSYMB.TESTI=0
        0 INTEGER*4 TESTI
     MYSYMB.TESTR=0.0
        4 REAL_F*4 TESTR
     MYSYMB.TESTC=
        8 CHARACTER*20 TESTC
    DIX&GT; mysymb.testi = 12
    DIX&GT; mysymb.testc = "abcd"
    DIX&GT; show symb mysymb/all
     MYSYMB.TESTI=0
     MYSYMB.TESTR=0.0
     MYSYMB.TESTC="abc"
    DIX&GT; show symb mysymb.*i/all

     
   
</pre>
<a name="229">
<h3 Align=center><a href="dix_help_idx_4.html#205" target="index">DIX INTERACTIVE_COMMANDS ASSIGN Assign_fields </a> </h3>
<pre>
  
  fieldname=value
 
  Fieldname may be the name of one field, or an table
  Fieldname may not contain wildcards (Except in the final dimension)
  value must have the same shape as fieldname

  examples
   suppose we have a field test.value(2,2) somewhere
  
  test.value(1,1) = 10		!assign to value(1,1)
  test.value      = 10          !assign 10 to all values (4 fields)
  test.value(1,*) = 10          !assign 10 to (1,*) (2 fields)

  The following is not supported
  Suppose we have a test(3).value(2,2)
   test(1).value(1,1) is valid, but
   test(*).value(1,1) not

  You may also assign values to fieldnames via the DEPOSIT command
  The differences are
   deposit
     allows wildcarding of the name (a text match is done)
      the text after the = is interpreted as text, and will be converted 
      according the fieldname type.
   assign
     Does not allow wildcarding of the name, but it does support
      wildcarding in the lowest dimension
     The piece after the = is evaluated as an expression, and must
      deliver a result of the same (or compatible) type as the field    

</pre>
<a name="230">
<h3 Align=center><a href="dix_help_idx_3.html#129" target="index">DIX INTERACTIVE_COMMANDS BACK </a> </h3>
<pre>

  Syntax BACK [/LOG]
  This command allows you to return to the file from which you 
  followed a link to this file. Up to 16 jumps are saved in a history
  buffer.
  See also the FOLLOW command
</pre>
<a name="231">
<h3 Align=center><a href="dix_help_idx_3.html#130" target="index">DIX INTERACTIVE_COMMANDS CD </a> </h3>
<pre>
  CD[/log] [string]
  A fast way to change directories. You can also use the SET DEFAULT command,
  but CD is easier to use.
  SDF is a synonym for CD

  Syntax:
  CD token[.token[.token...]
     Token can be
     1.            The beginning of the directory or a complete device name. 
                   If the directory is not  unique, DIX will print a list of 
                   directories, and lets you choose one.
                   If token ends with a :, DIX will change the current disk
                   to the token.
     2. #        : This is the SYS$LOGIN of the current user
     3. ~username: The login directory of user 'username'. If username is not
                   specified, the current user wil be used, and it is 
                   equivalent to #. This may need GRPPRV oR SYSPRV privilege
     4. -          Go one level up. If this is the last item on the line you
                   must add a . to prevent DIX from asking for a continuation 
                   line.

   Instead of the . as separator, the / or the \ can also be used. 
    If the / or the \ is typed as the first character, DIX will jump to 
    the [000000] directory of the current disk. 

   Examples
    DIX&GT;CD	!display current directories
    Current directory:USER50:[STUBBF.PROGRAMS.DIX.SOURCE]
    Subdirectories found :        DATA      T4        TEST 

    DIX&GT;CD T	  !goto a directory starting with a T (there are 2)
    1:T4   2:TEST !dix will display all matches and ask you for a choise
    Choose 1..2:2
    New directory:USER50:[STUBBF.PROGRAMS.DIX.SOURCE.TEST]

    DIX&GT;cd -.	  !go one up again
    New directory:USER50:[STUBBF.PROGRAMS.DIX.SOURCE]

    DIX&GT;CD ~	  !goto my login directory is the same as CD #
    New directory:USER50:[STUBBF]

    DIX&GT;CD P.D.S  !I want to go back to programs.dix.source
    1:PCSI          2:PERF      3:PROGRAMS
    Choose 1..3:3 !choose programs, and now we again have multiple matches
    1:DELETE_INTRUSIONS 2:DISKSTAT          3:DISTRIBUTED    4:DIX
    Choose 1..4:4 !Choose dix, and now the are no more ambig directories
    New directory:USER50:[STUBBF.PROGRAMS.DIX.SOURCE]
    DIX&GT; 

    DIX&GT;CD ~OTHERUSER	!goto login of otheruser (needs privs)
    New directory:USER100:[OTHERUSER]

</pre>
<a name="232">
<h3 Align=center><a href="dix_help_idx_3.html#131" target="index">DIX INTERACTIVE_COMMANDS CHARACTER </a> </h3>
<pre>
   CHARACTER[/level=n][/gobal] name[dimensions][=value]
   CHARACTER name[=value]

   Declare a new symbol of type "CHARACTER" and optionally give a value.
   The value(if present) must be an expression of type "character"

  Example
   CHARACTER mystring="Heading line"
  See the help about [DIX/help] interactive declaration

</pre>
<a name="233">
<h3 Align=center><a href="dix_help_idx_3.html#132" target="index">DIX INTERACTIVE_COMMANDS CHECKSUM </a> </h3>
<pre>

   Compute sha* and md5 checksums of files or strings
   
   checksum/xor=[vms] parameter [/qualifiers]   !compute xor hash 
   checksum/sum       parameter [/qualifiers]   !compute sum hash 
   checksum/md5       parameter [/qualifiers]   !compute md5 hash 
   checksum/sha=n     parameter [/qualifiers]   !compute sha hash
                                            ! n=1,224,256,384,512, default=256

   Dix will compute the data only from the record contents (if not in= block_mode)  
   If you copy the file to f.e. windows, the checksum may be different. This
   has two possible reasons.

   a. For text files (ascii transfer) the windows checksum utiltity checks 
      all data in the file including the separating crlf's. 
      See the /add qualifier for a possible solution
   b. If you checksum a .zip file, RMS will read the file as 512 byte records
      but the last record may not be completely filled (eof in the middle of
      the block). Use the /exact_file_size qualifier for a solution.
      The same applies if you checksum the file in block mode.      

   For the sum and xor checksum you can specify the /byte,/word and /longword
    qualifier to select the size of the xor/sum value.
    The default size is longword.

    If the size in /word or /long, and the record does not contain a multiple
     of bytes (2 or 4), the record will be appended by binary 0.
    If the user specifies /xor=vms, the last bytes will be added instead
     the appending with binary 0. This matches the VMS checkum/algor=xor
     method.

   Parameter is 
      a filename to checksum or a string (if /string is specified)
   Qualifiers
</pre>
<a name="234">
<h3 Align=center><a href="dix_help_idx_4.html#210" target="index">DIX INTERACTIVE_COMMANDS CHECKSUM /string </a> </h3>
<pre>
  
  The parameter is a string and not a filename.
</pre>
<a name="235">
<h3 Align=center><a href="dix_help_idx_4.html#211" target="index">DIX INTERACTIVE_COMMANDS CHECKSUM /symbol </a> </h3>
<pre>
  /symbol[=name] 

  Store result in a DIX symbol "name". THe default value is checksum$checksum
  If you also specify /dcl, the result will be in a DCL symbol
  If you are running in command mode (dix/command), /dcl is default

</pre>
<a name="236">
<h3 Align=center><a href="dix_help_idx_4.html#212" target="index">DIX INTERACTIVE_COMMANDS CHECKSUM /dcl </a> </h3>
<pre>
  If /symbol is specified, the result must be in a DCL symbol
  If you are running in command mode (dix/command), /dcl is default

</pre>
<a name="237">
<h3 Align=center><a href="dix_help_idx_4.html#213" target="index">DIX INTERACTIVE_COMMANDS CHECKSUM /logical </a> </h3>
<pre>
  /logical[=name]

   Store result in a process logical. THe default value is checksum$checksum
  
</pre>
<a name="238">
<h3 Align=center><a href="dix_help_idx_4.html#214" target="index">DIX INTERACTIVE_COMMANDS CHECKSUM /job_table </a> </h3>
<pre>
  If /logical is specified, the logical will be stored in a job lnm

</pre>
<a name="239">
<h3 Align=center><a href="dix_help_idx_4.html#215" target="index">DIX INTERACTIVE_COMMANDS CHECKSUM /block_mode </a> </h3>
<pre>
  /block_mode
    Open the file in blockmode , normally only records are processed
    In this case all bytes in the file are used, also the record separators.
    See also the /exact_file_size qualifier.
</pre>
<a name="240">
<h3 Align=center><a href="dix_help_idx_4.html#216" target="index">DIX INTERACTIVE_COMMANDS CHECKSUM /byte </a> </h3>
<pre>
  For the sum and xor checksum only.
  Set the size of the checksum to byte.
</pre>
<a name="241">
<h3 Align=center><a href="dix_help_idx_4.html#217" target="index">DIX INTERACTIVE_COMMANDS CHECKSUM /word </a> </h3>
<pre>
  For the sum and xor checksum only.
  Set the size of the checksum to word (2 bytes).
</pre>
<a name="242">
<h3 Align=center><a href="dix_help_idx_4.html#218" target="index">DIX INTERACTIVE_COMMANDS CHECKSUM /longword </a> </h3>
<pre>
  For the sum and xor checksum only.
  Set the size of the checksum to longword (4 bytes).

</pre>
<a name="243">
<h3 Align=center><a href="dix_help_idx_4.html#219" target="index">DIX INTERACTIVE_COMMANDS CHECKSUM /skip </a> </h3>
<pre>
   /skip=tag 

     Skip certain characters in input . 
      Tag can be
        LF   : Skip LF character
        CR   : Skip LF character
        BOTH : Skip CR and LF character, this is the default /skip

</pre>
<a name="244">
<h3 Align=center><a href="dix_help_idx_4.html#220" target="index">DIX INTERACTIVE_COMMANDS CHECKSUM /add </a> </h3>
<pre>
  /add=tag        
     Add certain characters after each record . 
      Tag can be
        LF   : Add LF character
        CR   : Add LF character
        BOTH : Add CR and LF character, this is the default /add

</pre>
<a name="245">
<h3 Align=center><a href="dix_help_idx_4.html#221" target="index">DIX INTERACTIVE_COMMANDS CHECKSUM /exact_file_size </a> </h3>
<pre>
   
  For fixed files only. The last record can have less than
  the fixed record length. RMS will always report the 
  fixed record length. With this switch the checksum will
  only be computed on the real file size. THis may/will be useful for
  .zip files

</pre>
<a name="246">
<h3 Align=center><a href="dix_help_idx_3.html#133" target="index">DIX INTERACTIVE_COMMANDS CLOSE </a> </h3>
<pre>
   CLOSE[/qualifiers]       close the current file
   CLOSE[/qualifiers] mask  close file with tag=mask or filename matches mask
                            mask can contain wildcards

  Will close the file(s) that match 'mask'. If the current file is closed
  the first file in the list will become the current file.

</pre>
<a name="247">
<h3 Align=center><a href="dix_help_idx_4.html#223" target="index">DIX INTERACTIVE_COMMANDS CLOSE qualifiers </a> </h3>
<pre>
</pre>
<a name="248">
<h3 Align=center><a href="dix_help_idx_5.html#247" target="index">DIX INTERACTIVE_COMMANDS CLOSE qualifiers /DISPOSITION </a> </h3>
<pre>
  /DISPOSITION=what

  What to with the file when it's closed
  what can be
   KEEP   : the default, do nothing
   SUBMIT : Submit the file in sys$batch
   PRINT  : Print the file in sys$print
   DELETE : Delete the file

 Only supported for rms files, no fastio or library module

</pre>
<a name="249">
<h3 Align=center><a href="dix_help_idx_5.html#248" target="index">DIX INTERACTIVE_COMMANDS CLOSE qualifiers /ERROR </a> </h3>
<pre>
  /ERROR=label

  If the CLOSE results in an error, DIX will jump to the label.
  If the /ERROR qualifier is not specified, DIX will look for the ON condition.

</pre>
<a name="250">
<h3 Align=center><a href="dix_help_idx_5.html#249" target="index">DIX INTERACTIVE_COMMANDS CLOSE qualifiers /LOG </a> </h3>
<pre>

  /LOG
  /NOLOG  Default

  If you specify /log, DIX will show the file(s) closed.
  Also the new current file is displayed (or the no files open message)
</pre>
<a name="251">
<h3 Align=center><a href="dix_help_idx_3.html#134" target="index">DIX INTERACTIVE_COMMANDS COMPILE </a> </h3>
<pre>
 
   COMPILE dixfile [/qualifiers]
  
   Compile the dix file to a compiled file. This may load a little faster,
   but runtime performance will be the same, since DIX precompiles all scripts.
   However using compiled scripts makes it (nearly) impossible for users to
   adapt the script, certainly if you do not specify /include 
   and even more if you specify /encrypt

  Supported qualifiers
   /INCLUDE_SOURCE : Include the source of the script. This allows the user
                     to display the lines during execution if SET VER is on
   /ENCRYPT        : Encrypt the output file. This makes it very hard to
                     change the commands.
   /OUTPUT=filename: Default filename is 'INPUTFILE'_COMPILED
   /LOG            : Display logging info
   /COMPRESS       : Compress the output file. THis makes the file smaller.
                     This is default
   /DCL_COMPATIBLE[=compatible|fallback] 
                   : Set the DCL compatible mode
                     Default /NODCL, /DCL is /DCL=compatible
   /VERB[=none|always|reading]
                   : Set the verb substitution
                     Default /NOVERB, /VERB is /DCL=always
                     See the help about "intera file_and_commands_in_file"

   Example

    DIX&GT;compile script/log   !compile script.dix to script.dix_compiled
    Compiled DISK:[DIR]SCRIPT.DIX/COMPRES;4
     /output=DISK:[DIR]SCRIPT.DIX_COMPILED;2
     20 records saved containing 3055 bytes
    DIX&GT;@script.dix_compiled !execute compiled script
    ....
    DIX&GT;

    DIX&GT; Compile a.com/DCL   !compile a dcl command file

</pre>
<a name="252">
<h3 Align=center><a href="dix_help_idx_3.html#135" target="index">DIX INTERACTIVE_COMMANDS CONVERT </a> </h3>
<pre>

  Convert [/qualifiers] inputfile[,inputfile] outputfile

  Convert an inpit file to an output file. Just like DCL convert

</pre>
<a name="253">
<h3 Align=center><a href="dix_help_idx_4.html#226" target="index">DIX INTERACTIVE_COMMANDS CONVERT Qualifiers </a> </h3>
<pre>

</pre>
<a name="254">
<h3 Align=center><a href="dix_help_idx_5.html#253" target="index">DIX INTERACTIVE_COMMANDS CONVERT Qualifiers /APPEND </a> </h3>
<pre>

   Controls whether converted records from an input file are
   appended to an existing sequential file.

   Normally DIX would creata new output file, but if you specify
   /append, DIX will append all records from inputfile to outputfile

</pre>
<a name="255">
<h3 Align=center><a href="dix_help_idx_5.html#254" target="index">DIX INTERACTIVE_COMMANDS CONVERT Qualifiers /EXCEPTIONS_FILE </a> </h3>
<pre>

   Specifies whether an exceptions file (file type .EXC) is to be
   generated during the conversion.

   Format

     /EXCEPTIONS_FILE  [=filespec]
     /NOEXCEPTIONS_FILE  (DEFAULT)

   Filespec is by default SYS$OUTPUT

</pre>
<a name="256">
<h3 Align=center><a href="dix_help_idx_5.html#255" target="index">DIX INTERACTIVE_COMMANDS CONVERT Qualifiers /EXIT </a> </h3>
<pre>

   Controls whether the DIX exits when it encounters an exception record. 
   By default, DIX continues processing records when it encounters 
   an exception record.

</pre>
<a name="257">
<h3 Align=center><a href="dix_help_idx_5.html#256" target="index">DIX INTERACTIVE_COMMANDS CONVERT Qualifiers /FAST_LOAD </a> </h3>
<pre>

   Specifies whether the DIX uses a fast-loading algorithm for 
    indexed files.

   Format

     /FAST_LOAD  (DEFAULT)
     /NOFAST_LOAD
</pre>
<a name="258">
<h3 Align=center><a href="dix_help_idx_5.html#257" target="index">DIX INTERACTIVE_COMMANDS CONVERT Qualifiers /FDL </a> </h3>
<pre>

   Indicates that an FDL file is to be used in creating the output
   file.

   Format

     /FDL=fdlfile

   Specifies the FDL file to be used in creating the output file.
   The newly created output file will have the name specified by the
   fdl-filespec command parameter; this name overrides any file name
   specified in the FDL file.

   The default file type for the FDL file is .FDL.
   The fdl file can also be specified inline. If the first character
   of the fdlfile is a ; DIX will treat the filespec as a (; separated)
   string that contains the fdl specifications.

   Example 
    DIX&GT; convert/fdl=x a b   
           COnvert file a to b using fdlfile x.fdl

    DIX&GT; convert/fdl="; file ; org seq" a b 
           Will convert file a to b as if an fdl file 
             FILE 
              ORG SEQ
           is given.

</pre>
<a name="259">
<h3 Align=center><a href="dix_help_idx_5.html#258" target="index">DIX INTERACTIVE_COMMANDS CONVERT Qualifiers /FILL_BUCKETS </a> </h3>
<pre>

   Controls whether to override the bucket fill percentage parameter
   associated with the output file.

   Format

     /FILL_BUCKETS

     /NOFILL_BUCKETS  (DEFAULT)

   If you specify /FILL_BUCKETS, the DIX fills the output file 
   buckets with as many records as possible. 
   This option is valid only for indexed output files.


</pre>
<a name="260">
<h3 Align=center><a href="dix_help_idx_5.html#259" target="index">DIX INTERACTIVE_COMMANDS CONVERT Qualifiers /FIXED_CONTROL </a> </h3>
<pre>

   Controls file conversions between files having variable-length
   with fixed-length control field (VFC) records and files having
   other record formats.

   Format

     /FIXED_CONTROL

     /NOFIXED_CONTROL  (DEFAULT)

   This qualifier applies only to conversions where either the input
   or the output file, but not both, uses VFC records. This option
   is applicable only to sequential files.

   o  If you specify /FIXED_CONTROL and the input file uses VFC
      records but the output file does not, the fixed-length control
      field from the input record is inserted into the output record
      as data.

   o  If you specify /FIXED_CONTROL and the output file has VFC
      records but the input file does not, the leading part of the
      input record is used to fill the fixed-length control part of
      the output record.

   o  If you specify /NOFIXED_CONTROL and the input file uses VFC
      records but the output file does not, the fixed-length control
      field from the input record is not included as data in the
      output record.

   o  If you specify /NOFIXED_CONTROL and the output file has
      VFC records but the input file does not, the control field
      attached to the output record is set to null.


</pre>
<a name="261">
<h3 Align=center><a href="dix_help_idx_5.html#260" target="index">DIX INTERACTIVE_COMMANDS CONVERT Qualifiers /KEY </a> </h3>
<pre>

   Directs DIX to read records from an indexed file
   using a specified key of reference, such as the primary key, the
   first alternate key, or the second alternate key.

   Format

     /KEY=n
</pre>
<a name="262">
<h3 Align=center><a href="dix_help_idx_5.html#261" target="index">DIX INTERACTIVE_COMMANDS CONVERT Qualifiers /MERGE </a> </h3>
<pre>

   Specifies that records are to be inserted into their proper
   position in an existing indexed file.

   Format

     /MERGE

     /NOMERGE  (DEFAULT)

   The /MERGE qualifier is useful when your input records are not
   sorted and you do not want them to be sorted as they are loaded
   into an output file.

   If you specify both /MERGE and /CREATE, /MERGE overrides the
   /CREATE qualifier.


</pre>
<a name="263">
<h3 Align=center><a href="dix_help_idx_5.html#262" target="index">DIX INTERACTIVE_COMMANDS CONVERT Qualifiers /PAD </a> </h3>
<pre>

   Determines whether short records are to be padded.

   Format

     /PAD  [=[%b]x]

     /NOPAD  (DEFAULT)

   Specifies that the short records are to be padded with either
   ASCII characters (A through Z, a through z, or 0 through 9) or
   numeric values.

   To specify x as a numeric value, you must specify the numeric
   base using the percent symbol (%)  followed by one of the
   following characters:

   D    Indicates that x is a decimal number.
   O    Indicates that x is an octal number.
   X    Indicates that x is a hexadecimal number.
   B    Indicates that x is a binary number.

</pre>
<a name="264">
<h3 Align=center><a href="dix_help_idx_5.html#263" target="index">DIX INTERACTIVE_COMMANDS CONVERT Qualifiers /PROLOG </a> </h3>
<pre>

   Specifies the prolog version number of the output indexed file.

   Format

     /PROLOG=n

   Specifies the prolog number 1, 2, or 3.


</pre>
<a name="265">
<h3 Align=center><a href="dix_help_idx_5.html#264" target="index">DIX INTERACTIVE_COMMANDS CONVERT Qualifiers /READ_CHECK </a> </h3>
<pre>

   Specifies whether each input record is to be read from the file a
   second time and compared to the record originally read.

</pre>
<a name="266">
<h3 Align=center><a href="dix_help_idx_5.html#265" target="index">DIX INTERACTIVE_COMMANDS CONVERT Qualifiers /SECONDARY </a> </h3>
<pre>

   Increases DIX's performance by reducing the
   number of required passes through the input data. This is
   accomplished by placing alternate key information into the
   CONVWORK file.

   Format

   /SECONDARY=n

   Qualifier Value
   n
   Specifies the number of alternate keys that will be loaded to
   the CONVWORK file with each pass through the input data.

   This qualifier is valid when you are fast-loading a file with
   more than one alternate key. This option allows CONVERT to use
   more disk space for its work file than would be used by default.

   The default number of alternate keys written to the CONVWORK
   file is 1.


</pre>
<a name="267">
<h3 Align=center><a href="dix_help_idx_5.html#266" target="index">DIX INTERACTIVE_COMMANDS CONVERT Qualifiers /SHARE </a> </h3>
<pre>

   Specifies whether the input file is to be opened for sharing with
   other processes during the conversion.

</pre>
<a name="268">
<h3 Align=center><a href="dix_help_idx_5.html#267" target="index">DIX INTERACTIVE_COMMANDS CONVERT Qualifiers /SORT </a> </h3>
<pre>

   Specifies whether the input file is to be sorted before being
   loaded into an indexed file. The sort is done according to the
   primary key of the output file.

</pre>
<a name="269">
<h3 Align=center><a href="dix_help_idx_5.html#268" target="index">DIX INTERACTIVE_COMMANDS CONVERT Qualifiers /STATISTICS </a> </h3>
<pre>

   Determines whether statistics about the file conversion are to
   be displayed.

   Format

     /STATISTICS[=keyword]

     /NOSTATISTICS  (DEFAULT)

   Keyword     Meaning

   BRIEF       Displays a summary of the file conversion at the
               completion of the operation. THis is the default.
   FULL        Displays summary information at the completion of
               each key load containing Sort and Load statistics
               for the key. A summary of the file conversion is
               also displayed at the completion of the operation.

</pre>
<a name="270">
<h3 Align=center><a href="dix_help_idx_5.html#269" target="index">DIX INTERACTIVE_COMMANDS CONVERT Qualifiers /TRUNCATE </a> </h3>
<pre>

   Specifies whether records that exceed the maximum record length
   for variable-length records, or records that exceed the specified
   record length for fixed-length records, are to be truncated.

</pre>
<a name="271">
<h3 Align=center><a href="dix_help_idx_5.html#270" target="index">DIX INTERACTIVE_COMMANDS CONVERT Qualifiers /WORK_FILES </a> </h3>
<pre>

   Specifies the number of temporary work files to be used during
   the sort process.

   Format

     /WORK_FILES=n

   Specifies the number of work files you want. You can specify 0 or
   any value from 1 through 10. Default is 2 work files.

</pre>
<a name="272">
<h3 Align=center><a href="dix_help_idx_5.html#271" target="index">DIX INTERACTIVE_COMMANDS CONVERT Qualifiers /WRITE_CHECK </a> </h3>
<pre>

   Specifies whether all writes are to be checked by comparing the
   new disk records with the original records in memory.

###
</pre>
<a name="273">
<h3 Align=center><a href="dix_help_idx_3.html#136" target="index">DIX INTERACTIVE_COMMANDS CREATE </a> </h3>
<pre>
 
  Create something

  CREATE/FILE filename			!create new file
  CREATE/DESCRIPTION new_description	!create new description record
  CREATE/RECORD [tag]			!create new record in a file

  In DIX mode the /RECORD is the default
  In DCL mode the /FILE is the default

</pre>
<a name="274">
<h3 Align=center><a href="dix_help_idx_4.html#228" target="index">DIX INTERACTIVE_COMMANDS CREATE CREATE </a> </h3>
<pre>

  CREATE/RECORD [TAG]

  Create a new record. The record will be filled with default data
   - binary null for non-text fields
   - Spaces for text fields
  and then allow you to modify this record, and eventually write it out
  via the Update command.
  Default in DIX mode
 
</pre>
<a name="275">
<h3 Align=center><a href="dix_help_idx_4.html#229" target="index">DIX INTERACTIVE_COMMANDS CREATE CREATE_FILE </a> </h3>
<pre>

  CREATE/FILE filename [/fdl=fdlname] [/log]
 
   Create a new file. Optionally specify an fdl filename
   
   Filename must be specified. 
   If the fdl filename is specified, the file is created using
   the fdl , otherwise a variable length file is created.
  Default in DIX mode

</pre>
<a name="276">
<h3 Align=center><a href="dix_help_idx_4.html#230" target="index">DIX INTERACTIVE_COMMANDS CREATE CREATE_DESCRIPTION </a> </h3>
<pre>
  
  CREATE/DESCRIPTION name [/qualifiers]

  Create a new description. This can be in the system_library(if you have
  write access), the user_library or in a file.
  Supported qualifiers

  /SYSTEM_LIBRARY  the new description will be placed in the system_library
  /USER_LIBRARY    the new description will be placed in the user_library
                   If you spccify nothing, the new description will be in a
                    file in the current directory.
  /TPU             Use the TPU editor for editting
  /EDT             Use the EDT editor for editting
                   If no editor is specified, use the internal editor
</pre>
<a name="277">
<h3 Align=center><a href="dix_help_idx_3.html#137" target="index">DIX INTERACTIVE_COMMANDS COPY </a> </h3>
<pre>
   is an alias for CUT

</pre>
<a name="278">
<h3 Align=center><a href="dix_help_idx_3.html#138" target="index">DIX INTERACTIVE_COMMANDS CUT </a> </h3>
<pre>
   CUT[/qualifiers] [TAG]
   COPY is an alias for the word

  Save current record values to save area (clipboard) or to a symbol.
  TAG is optional. If not specified, the current file is used, otherwise
  the file specified by 'TAG' is used.
  The PASTE command can be used to restore data from the save area.
  See the help about [DIX/help] interactive  PASTE

  Qualifiers can be

  /SYMBOL=symbolname  	save the data to a (DIX-)symbol
     You can use the PASTE command to restore the record from this save-area 
     or symbol.
  /DCL The symbol name is a dcl symbol. There are limitations on the length of
     DCL symbols, and it you exceed them, you will see an error
  /GLOBAL The dcl symbol is a global.
 
  If the file is a VFC file, and the /symbol is present, 2 symbols are created
  1. symbolname     : containing the record data value
  2. symbolname_VFC : containing the VFC data

</pre>
<a name="279">
<h3 Align=center><a href="dix_help_idx_3.html#139" target="index">DIX INTERACTIVE_COMMANDS CYCLE </a> </h3>
<pre>
  Skip the rest of the for, repeat, while, loop block and resume execution
  at the corresponding ENDxxx statement to start the next iteration. 
  This command does not exit the current block (as the LEAVE command).

  Example

  nrec = 0
  REPEAT
    read	       		!read next record
    if (fieldname=5) cycle      !if a fieldname = 5, skip the rest	
    fieldname = fieldname+1	!update the fieldname
    UPDATE              	!and write out to the file
    nrec = nrec + 1		!and count	
  UNTIL nrec=10			!when 10 processed stop

</pre>
<a name="280">
<h3 Align=center><a href="dix_help_idx_3.html#140" target="index">DIX INTERACTIVE_COMMANDS DATE </a> </h3>
<pre>
   DATE [/type=enum_type][/level=n][/global] name[dimensions][=value]
   DATE /INDEX=indextype name         Declare an indexed symbol of type integer
   DATE name[=value]

   Declare a new symbol of type "DATE" and optionally give a value.
   The value must be of type "date"
   See the help about [dix/int] interact declaration for the enum_type
   See the help about [dix/int] interact symbols indexed_symbols for /INDEX

  Example
   DATE start_date=f$date("1-JAN-2004")
  See the help about [DIX/help] interact declaration
   
</pre>
<a name="281">
<h3 Align=center><a href="dix_help_idx_3.html#141" target="index">DIX INTERACTIVE_COMMANDS DEASSIGN </a> </h3>
<pre>

   Deassign logicalname[/qualifiers]
  
  Supported qualifiers are
   Qualifier for the table
     /cluster
     /system
     /group
     /job
     /process
     /table=tablename

   Qualifiers for the mode of the logical
     /executive
     /supervisor
     /user

</pre>
<a name="282">
<h3 Align=center><a href="dix_help_idx_3.html#142" target="index">DIX INTERACTIVE_COMMANDS DECIMAL </a> </h3>
<pre>
   DECIMAL[/level=n][/global] name[=value]
   DECIMAL/INDEX=indextype name         Declare an indexed symbol of type date

   Declare a new symbol of type "DECIMAL" and optionally give a value.
   The value must be of type "decimal"

   See the help about [dix/int] interact symbols indexed_symbols for /INDEX

  Example
   DECIMAL counter=f$decimal("12345e12")

  See the help about [DIX/help] interactive declaration
</pre>
<a name="283">
<h3 Align=center><a href="dix_help_idx_3.html#143" target="index">DIX INTERACTIVE_COMMANDS DECLARATIONS </a> </h3>
<pre>
  
  Syntax, there are 2 formats

  format 1 for a limited number of data types

    'type'[/type=enum_type] [/level=n][/global][/overwrite] -
         name[['type']*size][dimensions][=value]
          [,name[dimensions][=value]...]

     where type : REAL[*n], CHARACTER, LOGICAL ,INTEGER[*n.m] or DATE, DECIMAL

   Format 2 , more general

    DECLARE[/'what'] [/type=enum_type] [/level=n][/global][/overwrite] -
         name[*size][dimensions][=value][,name[dimensions][=value]...]
 
      In this case all 'what' can be any datatype. If you do not
       specify 'what', the value has an undefined type

    name      : The name of the local symbol
    size      : For integer and reals and dates. Set the size to be fixed.
                For integer size is nbyte[.nbits] (0.1 .. 8.0)
                For reals size is nbyte (4,8,16)
                For dates size is nbyte (4,8)
    value     : An expression that returns a value of the correct type 
    dimensions: Up to 3 dimensions (d1[,d2[,d3]])
                Each dimension has the format [low:]high[:increment]
                   low  : lower boundary (default 1)
                   high : High boundary (must be present)
                   increment : Increment. If present, low must be present too
                   example (5:10:2) This results in 5,7,9

  Symbols declared in this way cannot be declared again (unless with
   the /overwrite qualifier) , and cannot be assigned
   another value than the declared type. See also the help about
   [DIX interactive] SET STRICT

  You may declare a symbol at a lower level. If you do not specify /level
   the symbol will be declared at the current procedure level.
   The value of level can be positive (the absolute level value)
   or negative (n levels higher). See the examples
   /global is the same as /level=0

  For integer data you can set the enumeration_type. This is equal to
   the functionality of the "fieldnames" of fields. The 'enum_type' may
   be defined before with the ADD TYPE statement, or can be specified
   within quotes. If you want the use a previously defined type (add type)
   you must prefix the name with a # sign. See below

  Example
 
  INTEGER a=10   declare an integer a with value 10
  INTEGER a=20   Will result in an error "symbol A is already defined."
  a=20           Is allowed, change the value to 20 (value must be integer)
  a="XYZ"        Will result in an error "Symbol A has other type than expression"


  DECLARE A/INT=10  Is the same as INTEGER A=10

  DECLARE X         The value X does not have a fixed type
  X=10              Value of x is now 10 (integer)
  X="String"        Value of X is now "String" (character)

  Example with defined types

  DIX&GT; ADD TYPE DAYS="0=sun,1=mon,2=tue,3=wed,4=thu,5=fri,6=sat"
  DIX&GT; integer/type=#days weekday
  DIX&GT; weekday=wed
  DIX&GT; Show symbol weekday
  WEEKDAY=wed
  DIX&GT; evaluate weekday		!the eval will always return the binary
  3

  Example with direct type

  DIX&GT; integer/type="0=sun,1=mon,2=tue,3=wed,4=thu,5=fri,6=sat" weekday
  DIX&GT; weekday=wed
  DIX&GT; Show symbol weekday
  WEEKDAY=wed
  DIX&GT; evaluate weekday		!the eval will always return the binary
  3

  Examples for level/global

  suppose we are at procedure level 3.
   Declare /level=1  symbol    Will declare a symbol at level 1
   declare /level=-2 symbol    Will declare a symbol at level 1
   Declare /global   symbol    Will declare a symbol at level 0

   Declare new                 Will declare at level 3
   Declare/level=-1 new        Will declare at level 2

                    
</pre>
<a name="284">
<h3 Align=center><a href="dix_help_idx_3.html#144" target="index">DIX INTERACTIVE_COMMANDS DECLARE </a> </h3>
<pre>
  
  DECLARE[/WHATTYPE][/type=enum_type][/OVERWRITE] -
          [/level=n][/global] NAME[*size][DIMENSIONS]=VALUE

  DECLARE/INDEX=indextype/whattype value  Declare a 'whattype' symbol with an
                                          index of type 'indextype' 

  This is the more generic form for INTEGER/REAL/DATE.. declarations.
  If you specify WHATTYPE, DIX will define a symbol of the specified
  type. You cannot change the 'type' of the symbol later.
  If you do not specify the "whattype", dix will define an "unspecified"
  symbol that can change types.

  Size can be specified like nbyte.nbit for integers and nbyte for reals
   DECLARE /int a*0.4   !declare a 4 bit integer

   See the help about [dix/int] interact declaration for indextype

  example

  DECLARE/LOG  Q=false,A/INTEGER=10,B(10,10)/char="test",K

  This will declare 
  1. A Logical value Q with value false
  2. An integer symbol A  with value 10
  3. A character table (10,10) with all elements initialized to "test"
  4. A logical value K (undefined)

  Also See the help about declarations for more information


</pre>
<a name="285">
<h3 Align=center><a href="dix_help_idx_3.html#145" target="index">DIX INTERACTIVE_COMMANDS DEFINE </a> </h3>
<pre>
   define logicals
   define keys
   define screenkeys
</pre>
<a name="286">
<h3 Align=center><a href="dix_help_idx_4.html#240" target="index">DIX INTERACTIVE_COMMANDS DEFINE DEFINE_LOGICALS </a> </h3>
<pre>

   Define name logicalname equivalence_name[,...]
   The same as the DCL define
   Supported qualifiers
</pre>
<a name="287">
<h3 Align=center><a href="dix_help_idx_5.html#286" target="index">DIX INTERACTIVE_COMMANDS DEFINE DEFINE_LOGICALS qualifiers </a> </h3>
<pre>
  The following qualifiers determine the table
  /CLUSTER
  /SYSTEM
  /GROUP
  /JOB
  /PROCESS
  /TABLE=nnn
 
  The following qualifiers determine the mode

   /EXECUTIVE
   /SUPERVISOR
   /USER

  The logical name can have the following attibutes
   /NAME=CONFINE
   /NAME=NO_ALIAS
  
  Each equiv string can have a the following attributes
    /CONCEALED 
    /TERMINAL


</pre>
<a name="288">
<h3 Align=center><a href="dix_help_idx_4.html#241" target="index">DIX INTERACTIVE_COMMANDS DEFINE DEFINE/KEY </a> </h3>
<pre>
 
  DEFINE/KEY keyname string[/qualifiers]
   
   Define keys for the INTERACTIVE mode of DIX.

   See also the RTL SCreen Management (SMG) manual about the possible
   keys. Also note that the f6..f14 keys are normally reserved for
   command line editing. You may use those keys when you set the
   terminal to /noline_edit, or if you prefix the key by a ^V.
   Also see the OpenVMS help about define/key.

</pre>
<a name="289">
<h3 Align=center><a href="dix_help_idx_5.html#288" target="index">DIX INTERACTIVE_COMMANDS DEFINE DEFINE/KEY Qualifiers </a> </h3>
<pre>
</pre>
<a name="290">
<h3 Align=center><a href="dix_help_idx_6.html#289" target="index">DIX INTERACTIVE_COMMANDS DEFINE DEFINE/KEY Qualifiers /SET_STATE </a> </h3>
<pre>
  /SET_STATE=name
  
  DEFINE/KEY keyname string /SET_STATE=NAME.

  Sets the key driver to state NAME.

</pre>
<a name="291">
<h3 Align=center><a href="dix_help_idx_6.html#290" target="index">DIX INTERACTIVE_COMMANDS DEFINE DEFINE/KEY Qualifiers /IF_STATE </a> </h3>
<pre>
  /IF_STATE=name

  DEFINE/KEY keyname string /IF_STATE=NAME
  
  If the user enters "keyname", the string "string" will only be returned
  if a previous key has put the key driver in the "NAME" state.
  Name is NOT case sensitive.
  
</pre>
<a name="292">
<h3 Align=center><a href="dix_help_idx_6.html#291" target="index">DIX INTERACTIVE_COMMANDS DEFINE DEFINE/KEY Qualifiers /TERMINATE </a> </h3>
<pre>
 
  After the /TERMINATE, the result will be given to DIX.

</pre>
<a name="293">
<h3 Align=center><a href="dix_help_idx_6.html#292" target="index">DIX INTERACTIVE_COMMANDS DEFINE DEFINE/KEY Qualifiers /ECHO </a> </h3>
<pre>

  Echo the translated strings

</pre>
<a name="294">
<h3 Align=center><a href="dix_help_idx_6.html#293" target="index">DIX INTERACTIVE_COMMANDS DEFINE DEFINE/KEY Qualifiers /LOCK_STATE </a> </h3>
<pre>

 DEFINE/KEY keyname string/SET_STATE=NAME/LOCK
  
  Normally the state is removed after the typing of the next key.
  If you define the key (and the SET_STATE) with the /LOCK, the state
  will remain "NAME" until another state is entered.

</pre>
<a name="295">
<h3 Align=center><a href="dix_help_idx_4.html#242" target="index">DIX INTERACTIVE_COMMANDS DEFINE DEFINE/SKEY </a> </h3>
<pre>
   DEFINE/KEY skey function [/qualifiers]

   Define a key combination for the screen mode of DIX.
   skey     : the keyboard key : Almost all keys can be used for keydefinitions.
   function : the DIX function 
   See the help about [DIX/help] key_mapp DIX_functions for allowed functions

</pre>
<a name="296">
<h3 Align=center><a href="dix_help_idx_5.html#290" target="index">DIX INTERACTIVE_COMMANDS DEFINE DEFINE/SKEY qualifiers </a> </h3>
<pre>
</pre>
<a name="297">
<h3 Align=center><a href="dix_help_idx_6.html#296" target="index">DIX INTERACTIVE_COMMANDS DEFINE DEFINE/SKEY qualifiers /SET_STATE </a> </h3>
<pre>
  /SET_STATE=name

  The parameter "" must be present but the contents are not used.
  SMGKEY will set a new state (GOLD and BLUE are used by default, but you
  may redefine the states if you redefine all keys)
  Statenames may not contain a - (hyphen)

  example
  DEFINE/SKEY PF1/SET=GOLD ""
  DEFINE/SKEY UPPERCASE_A/IF_STATE=GOLD key_print

  If the user enters PF1-A, the function key_print is executed.
 
  For a list of allowed functions, see the help about [DIX/help] KEY_MAPPING

</pre>
<a name="298">
<h3 Align=center><a href="dix_help_idx_6.html#297" target="index">DIX INTERACTIVE_COMMANDS DEFINE DEFINE/SKEY qualifiers /IF_STATE </a> </h3>
<pre>
 /IF_STATE=NAME
  
   Specifies a state that must be in effect for the key definition 
   to work. The state name is an alphanumeric string. States are 
   established with the /SET_STATE qualifier
   Statenames may not contain a - (hyphen)

  DEFINE/SKEY PF1/SET=GOLD ""
  DEFINE/SKEY F20/IF_STATE=GOLD key_print
  DEFINE/SKEY F20 key_swap_dis

  If the user enters PF1-F20, the function key_print is executed.
  It the user enters F20, the function  key_swap_dis is executed.

  For a list of allowed functions, see the help about [DIX/help] KEY_MAPPING

</pre>
<a name="299">
<h3 Align=center><a href="dix_help_idx_6.html#298" target="index">DIX INTERACTIVE_COMMANDS DEFINE DEFINE/SKEY qualifiers /CONTEXT_SCREEN </a> </h3>
<pre>
  /CONTEXT_SCREEN=Screen_context

  Define this key only for a specific screen. Default is that the
  key is valid in all screens
   Valid screens are
      DISPLAY_ALL		Display data in all formats
      SELKEY                    Select data for a key value
      EDIT                      Edit description 
      SELFILES                  Select one file when multiple files match
      EDITFILES                 Select a file (or add one)
      SELDESCRIPTIONS           Select a description (or add one)
      YESNO                     Yes/No screen
      VIEW                      View all kinds of data
      HELP                      Help screen(s)
      EDITMULTIPLE              Edit multiple lines (in show description)
      EDITLINE                  Edit a single line
      SELFIELD                  Select a field
      SHOWRAW                   Show data in raw format
      SHOWDES                   Show data in description format
      SELDEMO                   The select demo screen
      DISPLAY_SUBF              Display all subfields display	

</pre>
<a name="300">
<h3 Align=center><a href="dix_help_idx_3.html#146" target="index">DIX INTERACTIVE_COMMANDS DELETE </a> </h3>
<pre>
  
  DELETE/KEY name[/state=name]
                  Delete SMG key definitions for interactive mode

  DELETE/SKEY/ALL Delete all (default)keydefinitions for screen mode
  DELETE/SKEY skey [/STATE=NAME] 
                  Delete the key definition for skey (possibly with state NAME)

  DELETE/SYMBOL   See deeper help
  DELETE/SYMBOL/LOG[/all]   Mask   Delete symbol
  DELETE/SYMBOL/LOCAL[/all] Mask   Only delete local symbol

  DELETE/RECORD        Delete the current record (if the file is indexed or
                       relative and you have opened it with /MODIFY)
                       This will set the record context to the next record

  DELETE/FUNCTION[/log] mask : Delete functions

  DELETE/SEARCH [pattern]/LOG/CONFIRM Delete search patterns

  DELETE/VALUE     pattern[/log]/global/level=n Delete values 
  DELETE/TYPE      pattern[/log]/global/level=n Delete types
  DELETE/PARAMETER pattern[/log]/global/level=n Delete parameters
  
</pre>
<a name="301">
<h3 Align=center><a href="dix_help_idx_4.html#244" target="index">DIX INTERACTIVE_COMMANDS DELETE DELETE_SYMBOL </a> </h3>
<pre>

   DELETE/SYMBOL MASK  Delete the symbols matching MASK
   
   If the symbol is an indexed-symbol you can delete elements of the symbol
    delete/symbol indsym("A*")  Delete all values of indexed symbol indsym
                                matching A*. If you specify ("*") all values
                                will be deleted, but the (indexed-)symbol 
                                will not be deleted (it will have 0 values)
                                See also the /EXACT qualifier below
    delete/symbol indsym        Delete the whole symbol

   Supported qualifiers
  
   /EXACT    : If the symbol is an indexed symbol, and you specify the 
                /exact qualifer, the contents will be used exact, so the the
                * and % character in the element selection will not be 
                treated as a wildcard character, so the above example will
                delete indsym("A*")
   /LOG      : Display the symbols deleted
   /LEVEL=n  : Delete symbols from level n (0=global,1..depth=absolute level
                                            -1..-depth) is relative level
   /GLOBAL   : Delete global symbols, is the same as /level=0
   /LOCAL    : Delete local symbols, is the same as /LEVEL=DEPTH
   /ALL      : Delete all symbols, is the same as MASK= *
</pre>
<a name="302">
<h3 Align=center><a href="dix_help_idx_3.html#147" target="index">DIX INTERACTIVE_COMMANDS DEBUG </a> </h3>
<pre>

  This command is only allowed in a command procedure.
  The (DIX-)debugger will be started.

  You can also use the command "on control_c debug"

   If you then type a ^c during execution of a command procedure, the
   debugger will be started.

  You can use the  command "on error/warning debug"
   If a command returns an error/warning , the debugger will be started

  
  You can also start a command procedure with /debug

  Example
   Suppose the script file (examp.dix) contains
      on control_c debug
      k=1
   10:k=k+1
      goto 10
   got_l1:say "Seen ^C"
      goto 10

    DIX&GT; @examp
    ^C
    %DIX-I-DEBUG, Entering debug mode
         6:goto 10		!DIX tells you the current statement
    Dixdbg&GT; eval k              !see how we got
    172469
    Dixdbg&GT; go                  !keep going
    ^c
    %DIX-I-DEBUG, Entering debug mode
       6:goto 10                !Again this is where we are
    Dixdbg&GT;eval k		!ask for k again
    613507
    Dixdbg&GT; quit                !skip the test, back to interactive mode
    DIX&GT;


    DIX&GT;@example/debug          !start in debug mode
    Dixdbg&GT;



</pre>
<a name="303">
<h3 Align=center><a href="dix_help_idx_3.html#148" target="index">DIX INTERACTIVE_COMMANDS DEPOSIT </a> </h3>
<pre>

   DEPOSIT fieldnamemask=value.
   DEPOSIT offset=value
  
  Modify a field to the given value.                

  DEPOSIT fieldname = value
  DEPOSIT/RAW offset[.bit_offset] = value
  DEPOSIT/VFC Deposit data in VFC buffer or record
 
  The entered data is first 'unsymbolized' (see substitution)
  and then translated according to the field definition, and deposited in the
  data-record.

  You can modify more than one field in one statement, but all the
  used fields must have the same type.
  If you modify more than one field, the /CONFIRM may be useful.

  DEPOSIT will save the contents of the record before the modification
  You can undo the changes for this DEPOSIT with the UNDO/LAST

  You may also go back to the original record with the UNDO

  The value specified is converted to the binary equivalent. This
  will do what you expect, but there are some extensions 
  See the CONVERSION subtopic.

  You may also assign values to fieldnames via the assign (val=expr) command

  The differences are
  deposit
     allows wildcarding of the name (a text match is done)
     the text after the = is interpreted as text, and will be converted 
         according the fieldname type.
  assign
     Does not allow wildcarding of the name, but it does support
      wildcarding in the lowest dimension
     The piece after the = is evaluated as an expression, and must
      deliver a result of the same (or compatible) type as the field    

  Examples

  DEPOSIT /word 10=5           !modify the word (16 bits) at offset 10 to 5.
  DEPOSIT *COUNTER*=0          !Modify all fields matching *COUNTER* to 0
                               ! you may undo this with UNDO/LAST
  DEPOSIT *PRIME*{*DAY*}=false !modify all subfields matching *DAY* of
                               !all fields matching *PRIME* to false

  DEPOSIT UAF$Q_LASTLOGIN=1-JAN-2012:12:12 
                               !set the lastlogin field (type date) to the date
                               !Dix will convert the string to a date format
</pre>
<a name="304">
<h3 Align=center><a href="dix_help_idx_4.html#247" target="index">DIX INTERACTIVE_COMMANDS DEPOSIT Qualifiers </a> </h3>
<pre>
</pre>
<a name="305">
<h3 Align=center><a href="dix_help_idx_5.html#296" target="index">DIX INTERACTIVE_COMMANDS DEPOSIT Qualifiers /BINARY </a> </h3>
<pre>

  Interpret the data in binary mode
  this is a shorthand for /radix=2
</pre>
<a name="306">
<h3 Align=center><a href="dix_help_idx_5.html#297" target="index">DIX INTERACTIVE_COMMANDS DEPOSIT Qualifiers /BITS </a> </h3>
<pre>
  /BITS=number_of_bits
  For raw mode you can set any bitsize of 1 up to 64.

</pre>
<a name="307">
<h3 Align=center><a href="dix_help_idx_5.html#298" target="index">DIX INTERACTIVE_COMMANDS DEPOSIT Qualifiers /BYTE </a> </h3>
<pre>

  Modify data in bytes.  Valid only in /RAW mode.

</pre>
<a name="308">
<h3 Align=center><a href="dix_help_idx_5.html#299" target="index">DIX INTERACTIVE_COMMANDS DEPOSIT Qualifiers /CONFIRM </a> </h3>
<pre>

  DIX will ask you if the modification should be done. THis may be useful
  if you specify a wildcard in the fieldname.
 
  If conform is set. DIX will ask before every modification 
  MODIFY field to value
     [y]/q/a/q :
  You may answer 
   Y : Modify this one and keep asking for the next
   N : Do not modify this one and keep asking for the next
   Q : Do not modify this one and stop processing
   A : Modify this one and stop asking (as if confirm was off)
 
</pre>
<a name="309">
<h3 Align=center><a href="dix_help_idx_5.html#300" target="index">DIX INTERACTIVE_COMMANDS DEPOSIT Qualifiers /DECIMAL </a> </h3>
<pre>

 Interpret the data in radix 10.
  This is only possible for [u]integer fields
  this is equal to /radix=10   

</pre>
<a name="310">
<h3 Align=center><a href="dix_help_idx_5.html#301" target="index">DIX INTERACTIVE_COMMANDS DEPOSIT Qualifiers /FORMAT </a> </h3>
<pre>
  /FORMAT=option

  Normally all "character"-like fields will not contain unprintable data.
  These field types are CHARACTER,xSTRING.
  If the data does contain unprintables (hex 0:1f,7f,80:9f or ff) the
  /FORMAT qualifier determines how this data should be displayed.
  Default is the current format setting (set/show format)

   Option can be
    DOT   :All unprintables are replaced by a ".". This encoding is not
            reversible, after an unprintable value is replaced by a ".", 
            DIX cannot know what the unprintable value was. This may
            be a problem in the screen mode.
    HEX   :All unprintable data is displayed as %Xdd, a hexadecimal display.
            A % in the data will be displayed as %%. This display is reversible,
            so DIX can reconstruct the original unprintable value.
            If you are in this mode, on input a % must be entered as %%
    PASSALL:DIX will not change the unprintable data. The data is displayed as
            it is. THis mode will not work in screen mode, and maybe poorly
            when the output device is a terminal.
    DUMP   :Unprintable bytes are represented by a 2 or 3 letter mnemonic
            like &LT;DEL&GT; or &LT;CR&GT;. A &LT; in the text will be displayed as &LT;&LT;.
            This display is reversible, so DIX can reconstruct the original 
            unprintable value.
            If you are in this mode, on input a &LT; must be entered as &LT;&LT;

</pre>
<a name="311">
<h3 Align=center><a href="dix_help_idx_5.html#302" target="index">DIX INTERACTIVE_COMMANDS DEPOSIT Qualifiers /LONG </a> </h3>
<pre>

  Display data in longwords. This is the default in /RAW mode.
  Valid only in /RAW mode.

</pre>
<a name="312">
<h3 Align=center><a href="dix_help_idx_5.html#303" target="index">DIX INTERACTIVE_COMMANDS DEPOSIT Qualifiers /RECOVER </a> </h3>
<pre>
  /RECOVER     Default
  /NORECOVER 

  If you specify /recover, DIX allows you to rollback the changes made
  in this deposit by using UNDO/LAST

  If you specify /NORECOVER, DIX will not save the previous context, this
  may be useful in a script, when you are sure you will never UNDO the change.
  
</pre>
<a name="313">
<h3 Align=center><a href="dix_help_idx_5.html#304" target="index">DIX INTERACTIVE_COMMANDS DEPOSIT Qualifiers /UNSIGNED </a> </h3>
<pre>
  Integers are converted as unsigned.

</pre>
<a name="314">
<h3 Align=center><a href="dix_help_idx_5.html#305" target="index">DIX INTERACTIVE_COMMANDS DEPOSIT Qualifiers /WORD </a> </h3>
<pre>

  Modify data in words (16 bit values). Valid only in /RAW mode.

</pre>
<a name="315">
<h3 Align=center><a href="dix_help_idx_5.html#306" target="index">DIX INTERACTIVE_COMMANDS DEPOSIT Qualifiers /HEX </a> </h3>
<pre>

  Interpret the value in HEX mode.
  This is a shorthand for /radix=16

</pre>
<a name="316">
<h3 Align=center><a href="dix_help_idx_5.html#307" target="index">DIX INTERACTIVE_COMMANDS DEPOSIT Qualifiers /OCTAL </a> </h3>
<pre>

 Interpret the value in OCTAL mode
  This is a shorthand for /radix=8

</pre>
<a name="317">
<h3 Align=center><a href="dix_help_idx_5.html#308" target="index">DIX INTERACTIVE_COMMANDS DEPOSIT Qualifiers /RADIX </a> </h3>
<pre>
  /RADIX=nn
  
  Interpret the data in a given radix. nn must be between 2 and 36
  For /radix=16,8,2 are shorthands defined as /HEX,/OCTAL and /BINARY
  A radix which is not a power of 2 (so not 2,4,8,16,32) can only be
  used on [u]integer fields
  Ror radix 36 the characters 0..9 and A..Z will be used (so Z=35)
</pre>
<a name="318">
<h3 Align=center><a href="dix_help_idx_5.html#309" target="index">DIX INTERACTIVE_COMMANDS DEPOSIT Qualifiers /RAW </a> </h3>
<pre>
 Display data in raw (non description) mode. In this mode the qualifiers
  /WORD, /BYTE, /LONG, /HEX are significant. Default is the /LONG.
  Offset can be specified as byte_offset[.bit_offset]

</pre>
<a name="319">
<h3 Align=center><a href="dix_help_idx_4.html#248" target="index">DIX INTERACTIVE_COMMANDS DEPOSIT CONVERSION </a> </h3>
<pre>

  Normally the value will be converted to binary, but for some 
  field-types more options are available. See below
  (R)BITS fields
    DEPOSIT field=name1,name2,name3 Set bits name1,name2,name3
    DEPOSIT field=+name4            Leave the original value, and add
                                    name4
    DEPOSIT field=-name1            Leave the original value, and clear
                                    name1
  INTEGER*n with n=1,2
    Only normal integer conversion is tried
  INTEGER*4,*8
    First try integer conversion.
    Then try %Xnnnn, the %Onnnn, %Bnnnn, %Dnnnn conversions
         (hex,octal,binary,decimal)
    Then try 'dddd'X, 'dddd'O, 'dddd'B 'ddddd'D conversions
         (hex,octal,binary,decimal)
    Try to convert as date*4,*8
    Try to convert as IDENTIFIER
    Try to convert as UIC
    Try to convert as 'xxxx ascii
   On VAX INTEGER*8 is only partial supported and is expressed 
     as INT*4.INT*4

  VFC
    The format is "DD text"
    The DD are 2 hexadecimal chars. Not all combinations are valid. 
    The text field is ignored.
    Only  0..7F  : 0.127 linefeeds
         80..9F  : C0 control codes 00..1f
         E0..EF  : VFU codes 00..0F
     See the OpenVMS-manuals about VFC formats.

</pre>
<a name="320">
<h3 Align=center><a href="dix_help_idx_3.html#149" target="index">DIX INTERACTIVE_COMMANDS DEMO </a> </h3>
<pre>
  
   DEMO [whichdemo [startscreen]]
   DEMO/FILE=demofile
   DEMO/LIST  Show the possible demo's

   Jump to demo mode. The parameters are
    whichdemo   : The name of the DEMO, as found in DEMO/LIST (or show demo)
    startscreen : The start screen in the demo, defualt is MAIN

  Supported qualifiers are
</pre>
<a name="321">
<h3 Align=center><a href="dix_help_idx_4.html#250" target="index">DIX INTERACTIVE_COMMANDS DEMO /SCREENNAME </a> </h3>
<pre>
  /SCREENNAME    Default
  /NOSCREENNAME

  Show the name of the screen at the top op the display
  If you specify /noheader, the screenname will not be visible.
 
</pre>
<a name="322">
<h3 Align=center><a href="dix_help_idx_4.html#251" target="index">DIX INTERACTIVE_COMMANDS DEMO /HEADER </a> </h3>
<pre>
  /HEADER       Default
  /NOHEADER

  Display a header line, containing the demo name, and the screen name.

</pre>
<a name="323">
<h3 Align=center><a href="dix_help_idx_4.html#252" target="index">DIX INTERACTIVE_COMMANDS DEMO /UPPERCASE </a> </h3>
<pre>

  All keyinput will be upcased.

</pre>
<a name="324">
<h3 Align=center><a href="dix_help_idx_3.html#150" target="index">DIX INTERACTIVE_COMMANDS DIRECTORY </a> </h3>
<pre>

   DIRECTORY filemask [/qualifiers] [,filemask...] [filemask]

  This looks like the normal OpenVMS directory, except that DIX will only
  display the highest version, unless you type ;*

  Filemask is a normal OpenVMS filespecification with wildcards (like directory)
  or a library specification: modulemask@librarymask or librarymask(modulemask)

    There are 2 special librarynames
     DIX_SYS : The systemwide library dix_des.tlb 
     DIX_USR : The user library dix_user.tlb 

  Directory can also do a fast search (using /fast). In this case DIX will
   try to open the device:[0000000]indexf.sys (like DFU). You must have read
   access to this file.

  If you specify /fast or use a library specification, and you do not
   specify a /[NO]SORT command, DIX will automatically add a sort over the 
   whole dev/dir/filename/type/ver[/module]

  All type file files/methods can be mixed.
  DIRECTORY support upto 8 parameters, each as a list.

  DIX will allow you to place a wildcard in the device part. If you do that
   DIX will do a scan of all disk (devices of class DC$_DISK) that are
   mounted and not members of a shadowed disk (so the DSAdd is searched but
   not the members of that shadow set).

   Then a match will be done with the fulldevnam, and if that fails the 
   volumelabel.

  DIX can also show the current open memfiles 
   DIX&GT; DIR MEM:mask
 
 The following qualifiers are supported
</pre>
<a name="325">
<h3 Align=center><a href="dix_help_idx_4.html#254" target="index">DIX INTERACTIVE_COMMANDS DIRECTORY examples </a> </h3>
<pre>

  DIX&GT;DIRECTORY *.CLD   Display all fortran files
  Directory: USER50:[STUBBF.PROGRAMS.DIX.SOURCE]

  DIX_CLD.CLD;332

  Total of 1 file

  DIX&GT;DIRECTORY SYS$LIBRARY:*V*.olb,starlet(*ACC*)
  Directory: SYS$COMMON:[SYSLIB]

  RDBVMSLIB72.OLB;2
  Library: STARLET.MLB;1
   $ACCDEF             $ACCESSDEF          $CHECK_ACCESS       $CHECK_ACCESSDEF
   $CHECK_ACCESS_G     $CHECK_ACCESS_S     $ICC_ACCEPT         $ICC_ACCEPTDEF
   $ICC_ACCEPT_G       $ICC_ACCEPT_S       $MTACCESS           $MTACCESSDEF
   $MTACCESS_G         $MTACCESS_S         $SNDACC             $SNDACCDEF
   $SNDACC_G           $SNDACC_S
  Total of 18 modules
  VAXCCURSE.OLB;1     VAXCRTL.OLB;2       VAXCRTLD.OLB;2      VAXCRTLDX.OLB;2
  VAXCRTLT.OLB;2      VAXCRTLTX.OLB;2     VAXCRTLX.OLB;2
  VMS$VOLATILE_PRIVATE_INTERFACES.OLB;2

  Total of 18 modules, 9 files
  

  DIX&GT;dir sys$sysdevice:*imagelib*.OLB/fast
  Directory: sys$sysdevice:[VMS$COMMON.SYSLIB]

  CXML$IMAGELIB_GS.OLB;1                  CXML$IMAGELIB_TS.OLB;1
  IMAGELIB.OLB;1

  Total of 3 files

  DIX&GT;dir *@dix_sys    !display all modules in the dix_des.tlb
  Directory: FEKKO$DKA300:[STUBBF.PROGRAMS.DIX]

  Library: DIX_DES.TLB;148
   $AREA     $BUCKET   $DEFAULT  $KEY      $LINE     $PROLOGUE
   *DAF*.DAT           .AUDIT$JOURNAL      .BCK|.SAV           .CRF_CROSS
   .CRF_FILE_NAMES     .CRF_MOD_NAMES      .DIR      ACCOUNTNG           ACMSDDF
   ACMSUDF   ACU_PORTS           ACU_USERS           BSO_APPLICATIE
   BSO_VERSIE          DEMO#CREATE_DES     DEMO#DIX_GENERAL    DEMO#GENERAL_DES
   DEMO#GENERAL_RAW    DEMO#MODIFY         DEMO#SEARCH         DOCDB     FILECAB
   INDEXF    KEYS-*.IND          KEYS-*.VAL          LMF$LURT  MNU_USERS
   MONITOR   NET$PROXY           NETPROXY  NETWORK   PARTITION           PENDING
   PROFILE   QUOTA.SYS           RESERVATIONS        RIGHTSLIST
   SWITCHFILE          SYSUAF    TCPIP$HOST          USERTYPE_MYTYPE
   VIEW#.CRF_CROSS     VIEW#.DIR           VMS$PASSWORD_HISTORY
   VMS$SYSTEM_IMAGES.IDX         VMSMAIL_PROFILE
  Total of 52 modules

  DIX&GT;DIR dsa*:[dir]file.type   !Search all dsa devices for file [dir]file.type

  If some disks have a volumelabel USERnn, 
  DIX&GT;DIR USER*:[dir]file.type   !Search all devices with 
                                 !volume label USER* for file [dir]file.type
   
</pre>
<a name="326">
<h3 Align=center><a href="dix_help_idx_4.html#255" target="index">DIX INTERACTIVE_COMMANDS DIRECTORY qualifiers </a> </h3>
<pre>

</pre>
<a name="327">
<h3 Align=center><a href="dix_help_idx_5.html#318" target="index">DIX INTERACTIVE_COMMANDS DIRECTORY qualifiers /backup </a> </h3>
<pre>

  If you specify a /before or /sinc, the date will be checked against
  the backup date
</pre>
<a name="328">
<h3 Align=center><a href="dix_help_idx_5.html#319" target="index">DIX INTERACTIVE_COMMANDS DIRECTORY qualifiers /before </a> </h3>
<pre>

   /before=date

  Display only files younger than 'date'
  See the info about /create /expired /modified and /backup

  date can be a normal OpenVMS-date (including  today, yesterday,tomorrow) 
   or one of the keywords created/expired/modified/backup

</pre>
<a name="329">
<h3 Align=center><a href="dix_help_idx_5.html#320" target="index">DIX INTERACTIVE_COMMANDS DIRECTORY qualifiers /by_owner </a> </h3>
<pre>

  /BY_OWNER=owner

  SElect only files with this owner

</pre>
<a name="330">
<h3 Align=center><a href="dix_help_idx_5.html#321" target="index">DIX INTERACTIVE_COMMANDS DIRECTORY qualifiers /columns </a> </h3>
<pre>
  /COLUMNS=n

  Normally DIX uses the width of the filename to determine the number
  of columns. If you specify /columns=n, DIX will use this value
</pre>
<a name="331">
<h3 Align=center><a href="dix_help_idx_5.html#322" target="index">DIX INTERACTIVE_COMMANDS DIRECTORY qualifiers /created </a> </h3>
<pre>

  If you specify a /before or /sinc, the date will be checked against
  the creation date
</pre>
<a name="332">
<h3 Align=center><a href="dix_help_idx_5.html#323" target="index">DIX INTERACTIVE_COMMANDS DIRECTORY qualifiers /date </a> </h3>
<pre>

  /DATE=(keyword[,keyword...)

  Display the date(s) of the file

  Keywords are
 
  CREATED    Creation date
  MODIFIED   Modification date
  EXPIRED    Expiration date
  BACKUP     BAckup date
  ALL        All dates


</pre>
<a name="333">
<h3 Align=center><a href="dix_help_idx_5.html#324" target="index">DIX INTERACTIVE_COMMANDS DIRECTORY qualifiers /exclude </a> </h3>
<pre>
   /EXCLUDE=(filespec[,...])

   Excludes the specified files. You can use wildcards in
   the directory, name and type. The device part is ignored.

</pre>
<a name="334">
<h3 Align=center><a href="dix_help_idx_5.html#325" target="index">DIX INTERACTIVE_COMMANDS DIRECTORY qualifiers /expired </a> </h3>
<pre>

  If you specify a /before or /sinc, the date will be checked against
  the expiration date
</pre>
<a name="335">
<h3 Align=center><a href="dix_help_idx_5.html#326" target="index">DIX INTERACTIVE_COMMANDS DIRECTORY qualifiers /extent </a> </h3>
<pre>

  /extent
  /extent=full

  Display info about the number of header/extents of the file
  in the format "headers\extents" to differentiate with the size
    "eof/alloc"

  if /extent is given without the full parameter DIX will display the
   number of extents in the format \extents

  if /extent=full is specified, or if the /FHDRS qualifier is also given
   DIX will show both the header count and the number of extents 
   in the format headers\extents

  See also the /FHDRS qualifier

</pre>
<a name="336">
<h3 Align=center><a href="dix_help_idx_5.html#327" target="index">DIX INTERACTIVE_COMMANDS DIRECTORY qualifiers /FHDRS </a> </h3>
<pre>

  Display the number of fileheaders in the format headers\

 See also the help about /extent

</pre>
<a name="337">
<h3 Align=center><a href="dix_help_idx_5.html#328" target="index">DIX INTERACTIVE_COMMANDS DIRECTORY qualifiers /FAST </a> </h3>
<pre>

  Directory can also do a fast search (using /fast). In this case DIX will
  try to open the device:[0000000]indexf.sys (like DFU). You must have read
  access to this file

  Directory /fast device:[directory]filenamemask

  By default dix will sort the resulting files by directory/filename to get
  a nice display (files per directory). But this may take some time (first 
  all files must be processed before the fitst output appears).
  If you specify /nosort DIX will print the files as soon as they are found
  but the display is set to /nohead/notrail, since files are no longer sorted
  by directory.

</pre>
<a name="338">
<h3 Align=center><a href="dix_help_idx_5.html#329" target="index">DIX INTERACTIVE_COMMANDS DIRECTORY qualifiers /FILEID </a> </h3>
<pre>

  Display the fileid of the file
</pre>
<a name="339">
<h3 Align=center><a href="dix_help_idx_5.html#330" target="index">DIX INTERACTIVE_COMMANDS DIRECTORY qualifiers /full </a> </h3>
<pre>

  Display full info of a file
</pre>
<a name="340">
<h3 Align=center><a href="dix_help_idx_5.html#331" target="index">DIX INTERACTIVE_COMMANDS DIRECTORY qualifiers /grand_total </a> </h3>
<pre>

  Display a line containing the grand total (over all directories), 
  but no files, and also no directory names
</pre>
<a name="341">
<h3 Align=center><a href="dix_help_idx_5.html#332" target="index">DIX INTERACTIVE_COMMANDS DIRECTORY qualifiers /header </a> </h3>
<pre>

  Display the headers (one for each new directory)
</pre>
<a name="342">
<h3 Align=center><a href="dix_help_idx_5.html#333" target="index">DIX INTERACTIVE_COMMANDS DIRECTORY qualifiers /modified </a> </h3>
<pre>

  If you specify a /before or /sinc, the date will be checked against
  the modification date
</pre>
<a name="343">
<h3 Align=center><a href="dix_help_idx_5.html#334" target="index">DIX INTERACTIVE_COMMANDS DIRECTORY qualifiers /nice </a> </h3>
<pre>
  If the filename is ods-5 with ^* escapes, DIX will transform the
  ^* escapes to the real meaning. This transform is done before the
  possible sorting.
</pre>
<a name="344">
<h3 Align=center><a href="dix_help_idx_5.html#335" target="index">DIX INTERACTIVE_COMMANDS DIRECTORY qualifiers /organization </a> </h3>
<pre>

    Display the fileorganization

</pre>
<a name="345">
<h3 Align=center><a href="dix_help_idx_5.html#336" target="index">DIX INTERACTIVE_COMMANDS DIRECTORY qualifiers /output </a> </h3>
<pre>
   /output=filename

  Redirect the output to a file
</pre>
<a name="346">
<h3 Align=center><a href="dix_help_idx_5.html#337" target="index">DIX INTERACTIVE_COMMANDS DIRECTORY qualifiers /owner </a> </h3>
<pre>
  Display the owner of the file

</pre>
<a name="347">
<h3 Align=center><a href="dix_help_idx_5.html#338" target="index">DIX INTERACTIVE_COMMANDS DIRECTORY qualifiers /paged </a> </h3>
<pre>

  Display the data one page at the time

</pre>
<a name="348">
<h3 Align=center><a href="dix_help_idx_5.html#339" target="index">DIX INTERACTIVE_COMMANDS DIRECTORY qualifiers /record_format </a> </h3>
<pre>

    Display the recordformat


</pre>
<a name="349">
<h3 Align=center><a href="dix_help_idx_5.html#340" target="index">DIX INTERACTIVE_COMMANDS DIRECTORY qualifiers /screen </a> </h3>
<pre>

  Display the data in screen mode

</pre>
<a name="350">
<h3 Align=center><a href="dix_help_idx_5.html#341" target="index">DIX INTERACTIVE_COMMANDS DIRECTORY qualifiers /select </a> </h3>
<pre>
  
  /SELECT=(sel_item[,sel_item...])
 
  Sel_item can be

    size=min=blocks		Select on file size (allocated)
    size=max=blocks
    size=unused[=size]          Select file where alloc-eof&GT;size
                                 size is default the disk cluster size
    version=min=version_number  Select on version number
    version=max=version_number
    organization=org            Org=IDX,REL, SEQ                        
    record_format=fmt           fmt=UDF,FIX,VAR,VFC,STREAM,STREAM_LF,STREAM_CR
    headers=min=count           Select on the number of headers
    headers=max=count
    extents=min=count           Select on the number of (mapping-)extents 
    extents=max=count
    aces=count=min=count        Select on number of aces
    aces=count=max=count
    aces=size=min=count         Select on size of aces
    aces=size=max=count
    aces=ident=(id1[:access][,id2[:access]..)     
                                Select on files that have aces with identifier 
                                id1,id2.. Any id will match (or). If you also
                                specify aces=all, all ID's must be present.

                                Access can be specified as any combination of 
                                RWDEC. All the letters specified must be in 
                                the ACE and no more. If you append an *, you
                                select all aces the have at least the letters.
                                  
    aces=all                    In combination with the above. Match only if
                                all ids are present in the acl
    lbn=(start[,ent])           Select files that are mapped on lbns between
                                start and end. If end is not specified, end=start

    flag=(flag[,flag]..)
      Flag can be
         nobackup               select files flagged as NOBACKUP
         locked                 select files flagged as locked
         nomovefile             select files flagged as movefile disabled
         wbcache                select files flagged as write back cache
         readverify             select files flagged as readcheck
         writeverify            select files flagged as writecheck
         badacl                 select files flagged as having a bad acl 
         badblock               select files flagged as containing a bad block
         nocharge               select files flagged as not charged to quota
         erase                  select files flagged as erase on delete
         directory              select files flagged as directory file
         markdelete             select files flagged as marked for delete

    file=option             (do not) Display parts of the filename
         Option can be [no]node
                       [no]device
                       [no]directory
                       [no]name
                       [no]type
                       [no]version

  For the extents and headers you need read access to the [000000]indexf.sys

  Examples for the aces

   /SELECT=ACES=(IDENT=(ID1,BATCH),ALL) 
          Select only files that have an ace with ID1 AND an ace with BATCH
   /SELECT=ACES=IDENT=(ID1,BATCH) 
          Select only files that have an ace with ID1 OR an ace with BATCH
   /SELECT=ACES=COUNT=MIN=10
          Select only files that have at least 10 aces

   /SELECT=ACES=(IDENT=ID1:RWE)  
          Select all files that have an ace (ID=ID1,ACCESS=R+W+E)
           files that have other access fields enabled are not selected.
   /SELECT=ACES=(IDENT=ID1:R*)
          Select all files that have an ace ID=ID1 with an ACCESS string
           that has at least a READ specified, ohter access are allowed.

</pre>
<a name="351">
<h3 Align=center><a href="dix_help_idx_5.html#342" target="index">DIX INTERACTIVE_COMMANDS DIRECTORY qualifiers /since </a> </h3>
<pre>
   /since=date

  Display only files older than 'date'
  See the info about /create /expired /modified and /backup

  date can be a normal OpenVMS-date (including today, yesterday,tomorrow) 
   or one of the keywords created/expired/modified/backup

</pre>
<a name="352">
<h3 Align=center><a href="dix_help_idx_5.html#343" target="index">DIX INTERACTIVE_COMMANDS DIRECTORY qualifiers /SIZE </a> </h3>
<pre>
   /SIZE=(keyword[,keyword...])

  Support keywords are

	all         Display used size and allocated size
	allocation  Display only allocated size
	used        Display only used size, default if only /SIZE
	bytes       Display the size not in blocks but in xB (x=K,M,G)
        exact       Display the size in bytes, exact for sequential files
   The normal DCL syntax 
     /size=units=bytes
     /size=units=blocks
     /size=units=exact  Are also supported

</pre>
<a name="353">
<h3 Align=center><a href="dix_help_idx_5.html#344" target="index">DIX INTERACTIVE_COMMANDS DIRECTORY qualifiers /sort </a> </h3>
<pre>
  /sort=(field[,field..]])
  Sort the files according to the selected items

  field can be
     ascending             The following sorts will be in ascending order
     descending            The following sorts will be in descending order
     case_blind            Txt compares will case blind
     directory             Sort on directory
     file                  Sort on the filename only
     type                  Sort on the filetype
     version               Sort on the file version
     date[=created|expired|maodified|backup]   Sort on one of the dates
                              created is default
     id                    Sort on fileid
     owner                 Sort on UIC
     organization          Sort on file organization (SEQ,REL,IDX)
     record_format         Sort on record format
                            (DIX,STREAM,STREAM_LF,STREAM_CR,VAR,VFC,UDF)
     size[=allocated|used] Sort on size, default is used
     headers               Sort on the number of headers
     extents               Sort on the number of extents

    For header/extents you need read access to the index file

  If the /header or /trailer is active (default), the sort is done
  within each directory. If you specify /noheader/notrailer, the sort
  is done over all files (including the directory)

  If you have specified /fast, you can also specify /nosort to prevent DIX
   from sorting the files (and thus print the files sooner).

   DIX uses a special compare routine for the sort operation and this is
   incompatible with the hypersort utility. 
   If you receive the message %SORT-E-NYI, functionality is not yet implemented 
   when using directory/sort , make sure that the logical sortshr does not
   exist or points to sys$share:sortshr

   Example
    directory/sort=(ascending,type,descending,date=create) *.*

   Sort first on file type (ascending) and within equal types sort on
      creation date in descending order)
</pre>
<a name="354">
<h3 Align=center><a href="dix_help_idx_5.html#345" target="index">DIX INTERACTIVE_COMMANDS DIRECTORY qualifiers /statistics </a> </h3>
<pre>

  Show some statistics after the command completes
  If you have a specified /SORT, DIX will display sort statistics too.

</pre>
<a name="355">
<h3 Align=center><a href="dix_help_idx_5.html#346" target="index">DIX INTERACTIVE_COMMANDS DIRECTORY qualifiers /symbols[=name] </a> </h3>
<pre>

  Define the result of the directory command in sybols

  Name if the first part of the symbolname, default is DIRECTORY$

  In interactive mode these will be DIX symbols, in all other cases
   DCL symbols 

   The following symbols will be defined (assuming name=DIRECTORY$)

   DIRECTORY$FILES         Files found
   DIRECTORY$DIRECTORIES   Directories found
   DIRECTORY$MODULES       Modules found
   DIRECTORY$LIBRARIES     Libraries found
   DIRECTORY$SIZE_ALLOC    Total Allocated size (in the selected size mode)
   DIRECTORY$SIZE_EOF      Total EOF size (in the selected size mode)

  The last two symbols are only defined it you specified the
   /size=(eof,alloc) qualifier.
</pre>
<a name="356">
<h3 Align=center><a href="dix_help_idx_5.html#347" target="index">DIX INTERACTIVE_COMMANDS DIRECTORY qualifiers /total </a> </h3>
<pre>

  Display a line containing the total (per directory), but no files

</pre>
<a name="357">
<h3 Align=center><a href="dix_help_idx_5.html#348" target="index">DIX INTERACTIVE_COMMANDS DIRECTORY qualifiers /trailer </a> </h3>
<pre>

  Display the headers (one for each directory)

</pre>
<a name="358">
<h3 Align=center><a href="dix_help_idx_5.html#349" target="index">DIX INTERACTIVE_COMMANDS DIRECTORY qualifiers /versions </a> </h3>
<pre>

  /versions=n

  Determines houw many versions of a file DIX will show
  Default is /versions=1 . DCL would print all versions by default.

</pre>
<a name="359">
<h3 Align=center><a href="dix_help_idx_5.html#350" target="index">DIX INTERACTIVE_COMMANDS DIRECTORY qualifiers /width </a> </h3>
<pre>

  /WIDTH=(field=value[,field=value...])

  Specify the filewidths of the various parts
  Keywords are
    auto       : Let dix compute the max width of each displayed field
               : All other keyhwords are ignored
  if auto not specified
    file       : the filename, default=20
    size       : the size, default=8
    date       : dates, default=23
    owner      : owner , default=20
    id         : fileid, default=15

  Specifing /width without values is the same as /width=auto

</pre>
<a name="360">
<h3 Align=center><a href="dix_help_idx_3.html#151" target="index">DIX INTERACTIVE_COMMANDS DISABLE </a> </h3>
<pre>
 
   DISABLE something

   For more help see also the SET xxx command

   Something can be

    AUTOSAVE                  Clear autosave mode
    COUNT                     Clear count mode
    DCL_COMPATILE             Clear DCL compatible mode and fallback
    DCL_FALLBACK              Clear DCL fallback mode
    MOUSE                     Clear mouse usage enabled
    LOW_FIRST                 Clear low dimension first
    OVERFLOW                  Clear overflow detection
    QUOTED                    Clear examine to quoted mode
    CASE_SENSITIVE            Clear case sensitive mode  
    PIPE_MODE                 Set automatic pipe mode. If a ; is in the
                                  command line, DIX will assume PIPEing.
    EXPRESSION_PARSE          Set parsing to try expression after
                                  command parsing error

</pre>
<a name="361">
<h3 Align=center><a href="dix_help_idx_3.html#152" target="index">DIX INTERACTIVE_COMMANDS DISPLAY </a> </h3>
<pre>
  Display is a synonym for EXAMINE

</pre>
<a name="362">
<h3 Align=center><a href="dix_help_idx_3.html#153" target="index">DIX INTERACTIVE_COMMANDS DO </a> </h3>
<pre>

   DO repeatcount [;] command [;command [;.,..]]

  DO the following command 'repeatcount' times
  If during the execution of a repeat DIX encounters an error or
  severe error, the repeat count is terminated.
  Multiple commands are enabled if you start the command list with a ;

  During the execution of this statement, the special symbol 
  $DOINDEX contains the value of the loop index (1..repeatcount)

  f.e.  do 10 ;next rec ; exa field
        do 5 ; exam field($doindex) 
 
</pre>
<a name="363">
<h3 Align=center><a href="dix_help_idx_3.html#154" target="index">DIX INTERACTIVE_COMMANDS DUMP </a> </h3>
<pre>
   DUMP [/qualifiers] [filetag]

  Dump one or more records. Can be used to display one or more records, 
  and also to output data in CSV (comma Separater Values) mode.


  By default the current file is dumped, but you may specify filetag to 
   use a different file of even an file that is not open.

  If you specify an opened file, DIX will restore the file to the
   current position.

</pre>
<a name="364">
<h3 Align=center><a href="dix_help_idx_4.html#260" target="index">DIX INTERACTIVE_COMMANDS DUMP Qualifiers </a> </h3>
<pre>
</pre>
<a name="365">
<h3 Align=center><a href="dix_help_idx_5.html#356" target="index">DIX INTERACTIVE_COMMANDS DUMP Qualifiers /OUTPUT </a> </h3>
<pre>
 /OUTPUT=filename
 /OUTPUT=sys$output   (default)

  Set the output file
</pre>
<a name="366">
<h3 Align=center><a href="dix_help_idx_5.html#357" target="index">DIX INTERACTIVE_COMMANDS DUMP Qualifiers /COUNT </a> </h3>
<pre>
 /COUNT=n
  
  determines the number of records displayed. Default is all records 
</pre>
<a name="367">
<h3 Align=center><a href="dix_help_idx_5.html#358" target="index">DIX INTERACTIVE_COMMANDS DUMP Qualifiers /CSV </a> </h3>
<pre>
   /CSV=(Csv_option[,csv_option...])

  Csv_option can be
   HEADER    : Print a header line before all data
   NOQUOTES  : Do not 'quote' fields (see below)
   ALL_QUOTES: User quotes around all fields
   SEPARATOR=COMMA    : Use COMMA as separator	   (default)
   SEPARATOR=TAB      : Use TAB char as separator
   SEPARATOR=COLON    : Use COLON (:) a separator
   SEPARATOR=SEMICOLON: Use SEMICOLON (;) as separator
   SEPARATOR=BAR      : Use | as a separator
   SEPARATOR=CHARACTER=%Xdd:  Use %Xdd as separator
   QUOTE=DOUBLEQUOTE   : Use the " character for quotes around fields (default)
   QUOTE=QUOTE         : Use the ' character for quotes around fields
   QUOTE=CHARACTER=%Xdd: Use the %Xdd character for quotes around field

  If you want quoting (DEFAULT) , DIX will insert the "quotecharacter" 
  around text fields and field that contain the "separatorcharacter" or space

  If you specify ALL_QUOTES, DIX will insert the "quotecharacter"
  around all fields.

  If you specify NOQUOTES, DIX will never insert the "quotecharacter"

  The header fields are regarded as "text" fields.

  See also the /SELECT qualifier for help about selection of fields

  Example

  DIX/FILE/CSV=(header,all_quotes,quote=quote,separator=semicolon) file
    Output is a file with all fields quoted, using ' as quote and ; as
    separator with a header line.

  DIX/FILE/CSV=(header,noquote,separator=char=32) file   or
  DIX/FILE/CSV=(noquote,separator=char=%X20) file
    Output is a file with no fields quoted, and SPACE as separator

</pre>
<a name="368">
<h3 Align=center><a href="dix_help_idx_5.html#359" target="index">DIX INTERACTIVE_COMMANDS DUMP Qualifiers /DISPLAY </a> </h3>
<pre>
  /DISPLAY=(displayitem[.,displayitem...])


  This qualifier decides what parts of the record are to be displayed

  Displayitem can be

  [NO]DATA    : Display the data part of the record
  [NO]VFC     : display the VFC part of the record (if present)
  [NO]RECNR   : Display the recordnumber (only if record not found via keyed access) 
  [NO]RECLEN  : Display the recordlength
  [NO]RFA     : Display the RFA of the record
  ALL         : Print all parts
  WHOLE_RECORD: Do not try to format, just dump the whole record. In this case
                 all other flags are cleared, and the /FORMAT is ignored. You
                 may specify display=(whole,[recnr],[recsize],[rfa]) to add
                 an additional record with this info.
 
  The default is the current display setting (show display)

</pre>
<a name="369">
<h3 Align=center><a href="dix_help_idx_5.html#360" target="index">DIX INTERACTIVE_COMMANDS DUMP Qualifiers /FOLLOW </a> </h3>
<pre>

  /FOLLOW=None
  /FOLLOW=(end[,skipkeys])
  /FOLLOW=(field[,skipkeys])

  For file mode only (and also the dump command in interactive mode)
  
  If you have a file with a description that contains a link to another file
  DIX can automatically include the fields from that file.
  If you specify /FOLLOW=END, DIX will first display all fields of the
     current description, and then the follow fields.
  If you specify /FOLLOW=FIELD, DIX will follow the link directly after
     the follow field is found.
  If you ADD the skipkeys keyword, DIX will not print the keyfields of
     the followed file, sinc that value will probably also be a field
     in the follow field.

  Examples
   This example is a set of thee files that make a (simple) crossref
   system
  
   File 1. name.CRF_CROSS
    Contains records with 2 numbers. 
      First the (module-)number of the caller
      And then the (Module-)number of the callee
                                        
        integer*2 /file=.crf_mod_names caller_nr !link to mod_names
        integer*2 /file=.crf_mod_names called_nr !link to mod_names

   File 2. name.CRF_MOD_NAMES
    Contains the module number and the name and a link to the filename
     There is a key on the mod_nr

        integer*2    mod_nr
        character*32 mod_name
        integer*2    /file=.crf_file_names file_nr !link to file_names

   File 3. name.CRF_FILE_NAMES
    Contains the file number and the file name
     There is a key on the file_nr

        integer*2    file_nr
        character*60 file_name

    DIX&GT; open name.CRF_CROSS	

    DIX&GT; DUMP/COUNT=1/CSV=HEADER           !DIX will not follow the links
    "CALLER_NR","CALLED_NR"
    738,-262

    DIX&GT; DUMP/COUNT=1/CSV=HEADER/FOLLOW=END
    "CALLER_NR","CALLED_NR",
       "MOD_NR","MOD_NAME","FILE_NR",
             "FILE_NR","FILE_NAME",
       "MOD_NR","MOD_NAME","FILE_NR",
             "FILE_NR","FILE_NAME"
    738,-262,				!both caller and callee
       738,"CHECK_ALLOWED_USER",66,     !info about caller number
              66,"REM_SERVER_CHECK_ACCESS",  !and its file
       -262,"SYS$VERIFY_PROXY",69,      !info about callee
              69,"SYSTEM"                    !and its file

     The indentation is only to show the actions.

    $DIX&GT; DUMP/COUNT=1/CSV=HEADER/FOLLOW=FIELD
     "CALLER_NR",
       "MOD_NR","MOD_NAME","FILE_NR",
         "FILE_NR","FILE_NAME",
     "CALLED_NR",
       "MOD_NR","MOD_NAME","FILE_NR",
         "FILE_NR","FILE_NAME"
     738,				!caller number
        738,"CHECK_ALLOWED_USER",66,     !its name
           66,"REM_SERVER_CHECK_ACCESS",  !and it file
     -262,                              !callee number
        -262,"SYS$VERIFY_PROXY",69,      !its name
           69,"SYSTEM"                    !and its file

     Again, the indentation is only to show the actions.

     You will see that the mod_nr and file_nr are specified twice
     If you had added a SKIPKEYS, the display would have been

    $DIX&GT; DUMP/COUNT=1/CSV=HEADER /FOLLOW=(FIELD,skip)
     "CALLER_NR",
       "MOD_NAME","FILE_NR",
         "FILE_NAME",
     "CALLED_NR",
       "MOD_NAME","FILE_NR",
         "FILE_NAME"
     738,			    !caller number
        "CHECK_ALLOWED_USER",66,      !its name
           "REM_SERVER_CHECK_ACCESS",  !and it file
     -262,                          !callee number
        "SYS$VERIFY_PROXY",69,        !its name
           "SYSTEM"                     !and its file

       The display of the MOD_NR/FILE_NR for the second and third 
        level files are now gone, since they are the key values
</pre>
<a name="370">
<h3 Align=center><a href="dix_help_idx_5.html#361" target="index">DIX INTERACTIVE_COMMANDS DUMP Qualifiers /REWIND </a> </h3>
<pre>

  Only useful for currently opened files.
  If you  specify /REWIND, DIX will rewind the file to the first record
  before dumping, allowing you to dump the whole file. 
  After the DUMP DIX will restore the file to the  current position.
</pre>
<a name="371">
<h3 Align=center><a href="dix_help_idx_3.html#155" target="index">DIX INTERACTIVE_COMMANDS ECHO </a> </h3>
<pre>

  Syntax:
  ECHO[/qualifier] textstring 

  Display a text to the output file. This can be useful in batch-jobs.
  One qualifier is supported 
    /CONSOLE  : Print the output to the terminal regardless of the 
                /output setting.
    /UPDATE   : Only in screen/decwindow mode: Overwrite the last message


 Example

 DIX&GT; ECHO We reached record 20
 ECHO:We reached record 20

</pre>
<a name="372">
<h3 Align=center><a href="dix_help_idx_3.html#156" target="index">DIX INTERACTIVE_COMMANDS EDIT </a> </h3>
<pre>

  Edit various items

   EDIT [/FILE] filename [/fdl=fdlname]] [/log] Edit a general file
                      The /file is optional
   EDIT /DESCRIPTION Edit the current description of the current file
   EDIT /VIEW        Edit the current view of the current file
   EDIT /SEARCH      Edit the search string(s)

    For the edit /description , /view and /file you can specify
    which editor you want to use
     /internal     A small smg based editor (native to DIX)
     /tpu          The normal edit/tpu
     /edt          The normal edit/edt
    If the terminal does not support smg, editing is set to /edt

   The EDIT /FILE has an additional qualifier /FDL
   This qualifier will be ignored for sequential files
   For all other files:

    Specifying /nofdl will leave the edited file sequential

     If /FDL is specified without a value, DIX will
        make a temporary FDL file of the sourcefile.
     If /FDL has a value, DIX will use that FDL file.

     After editing DIX will use one of the fdl files to
      convert the file. In this way you can edit an indexed
      file and leave it indexed.

</pre>
<a name="373">
<h3 Align=center><a href="dix_help_idx_3.html#157" target="index">DIX INTERACTIVE_COMMANDS ENABLE </a> </h3>
<pre>
 
   ENABLE something

   For more help see also the SET xxx command

   Something can be

    AUTOSAVE                  Set autosave mode
    COUNT                     Set count mode
    DCL_COMPATIBLE            Set DCL compatible mode (not dcl_fallback)
    MOUSE                     Set mouse usage enabled
    LOW_FIRST                 Set low dimension first
    OVERFLOW                  Set overflow detection
    QUOTED                    Set examine to quoted mode
    CASE_SENSITIVE            Set case sensitive mode  
    PIPE_MODE                 Set automatic pipe mode. If a ; is in the
                                  command line, DIX will assume PIPEing.
    EXPRESSION_PARSE          Set parsing to try expression after
                                  command parsing error
</pre>
<a name="374">
<h3 Align=center><a href="dix_help_idx_3.html#158" target="index">DIX INTERACTIVE_COMMANDS EXAMINE </a> </h3>
<pre>

 EXAMINE[/qualifiers] [fieldmask]                !mode 1
 EXAMINE/RAW offset[:end_offset]                 !mode 2
 EXAMINE/RAW offset[;length]                     !mode 3
 EXAMINE[/RAW] offset.bit/bits=n                 !mode 4
 EXAMINE[/RAW] offset[.bit]/type=datatype[*size] !mode 5
  
 If a description is present and /RAW and /BITS are not used, DIX
  interprets the mask as a fieldname mask (mode 1).

   Display all fields with the name matching 'fieldmask' . Default
    all names match.
   Fieldmask can contain references to other files/descriptions.
   The full format is
    [FILEMASK\[DESCRIPTIONMASK\]]FIELDNAMEMASK.

   The filemask and descriptionmask are matched against the file
   and descriptions tags. (see the show file [/all][/full]

   The qualifiers MUST be entered before the fieldmask or the offset

  If no description is present or /RAW is used, and /BITS is not used and
   mask does not contain a ., mode 2 is used.
 
   In this mode, the data starting from byte 'offset' will be displayed.
   If offset is absent, the whole record is dumped in raw mode.
   If end_offset is not present, only the line containing 'offset'
    is displayed.
  
 Mode 4 is used if :

   a. If a description is present you need to specify the /RAW or the /BITS
   b. You typed a . in the offset or you specified the /BITS=nn

   In this case DIX will  display the value of offset:offset+nbits-1. 
   This allows you to examine any bitstring within the record 
   If /BITS is not specified, DIX takes the current word size
    /BYTE, /WORD or /LONGWORD.

  Mode 5 allows you to force a specific datatype translation for a
   specific offset

  See also the FIND command.
</pre>
<a name="375">
<h3 Align=center><a href="dix_help_idx_4.html#265" target="index">DIX INTERACTIVE_COMMANDS EXAMINE QUALIFIERS </a> </h3>
<pre>
</pre>
<a name="376">
<h3 Align=center><a href="dix_help_idx_5.html#367" target="index">DIX INTERACTIVE_COMMANDS EXAMINE QUALIFIERS /ALL </a> </h3>
<pre>
  Display the selected fields or offset with all data formats
  See examples below

  $DIX/int sysuaf
  DIX&GT;exa/all *byt*
  560|UAF$L_BYTLM |Raw data   |40 0D 03 00 00 00 00 00 00 10 00 00 00 00 00 00 
                  |INTEGER*1  |64
                  |INTEGER*2  |3392
                  |INTEGER*4  |200000
                  |UINTEGER*1 |64
                  |UINTEGER*2 |3392
                  |UINTEGER*4 |200000
                  |REAL*4     |0.14791E-00030
                  |REAL*8     |0.18307E-00244
                  |REAL*16    |0.48925E-04942
                  |REALG*8    |0.18307E-00244
                  |REAL_IEEE*4|Overflow
                  |REAL_IEEE*8|Overflow
                  |LOGICAL*1  |False
                  |UIC        |[3,6500]
                  |CHARACTER*4|@...
                  |DATE*4     |4-APR-1859 21:20:00.00
                  |DATE*8     |17-NOV-1858 00:00:00.02
                  |PROTECTION |S:RWED, O:RWD, G:W, W:RWED
                  |RINTEGER   |222298115
                  |FILEID     |(3392,3,0)
                  |BITS       |BIT6
  564|UAF$L_PBYTLM|Raw data   |00 00 00 00 00 10 00 00 00 00 00 00 00 00 00 00 
                  |INTEGER*1  |0
                  |INTEGER*2  |0
                  |INTEGER*4  |0
                  |UINTEGER*1 |0
                  |UINTEGER*2 |0
                  |UINTEGER*4 |0
                  |REAL*4     |0.0000       
                  |REAL*8     |Overflow
                  |REAL*16    |0.11391E-04951
                  |REALG*8    |Overflow
                  |REAL_IEEE*4|0.0000       
                  |REAL_IEEE*8|Overflow
                  |LOGICAL*1  |False
                  |UIC        |[0,0]
                  |CHARACTER*4|....
                  |DATE*4     |17-NOV-1858 00:00:00.00
                  |DATE*8     |7-DEC-1858 08:40:18.60
                  |PROTECTION |S:RWED, O:RWED, G:RWED, W:RWED
                  |RINTEGER   |0
                  |FILEID     |(1048576,0,0)
                  |BITS       |
</pre>
<a name="377">
<h3 Align=center><a href="dix_help_idx_5.html#368" target="index">DIX INTERACTIVE_COMMANDS EXAMINE QUALIFIERS /BITS </a> </h3>
<pre>
  /BITS=n
  Force a bitstring examine. N can have any value between 1 and 64.

  Example
  
  DIX&GT; examine/bits=4 100.3  !examine 4 bits starting at byte offset 100
  100.3=2                    !bit 3, so but 3..6 are displayed

</pre>
<a name="378">
<h3 Align=center><a href="dix_help_idx_5.html#369" target="index">DIX INTERACTIVE_COMMANDS EXAMINE QUALIFIERS /DESCRIPTION </a> </h3>
<pre>

 Display the description info after the field value.

</pre>
<a name="379">
<h3 Align=center><a href="dix_help_idx_5.html#370" target="index">DIX INTERACTIVE_COMMANDS EXAMINE QUALIFIERS /DISPLAY </a> </h3>
<pre>
  /DISPLAY=(displayitem[,displayitem...])

  This qualifier decides what parts of the record are to be displayed

  The default display is used (see set/show display).

  Displayitem can be

  [NO]DATA         : Display the data part of the record
  [NO]VFC          : display the VFC part of the record (if present)
  [NO]RECNR        : Display the recordnumber (only if record not found 
                                               via keyed access) 
  [NO]RECLEN       : Display the recordlength
  [NO]RFA          : Display the RFA of the record
  [NO]FIELDNAMES   : Display the fieldnames
  [NO]NUMBER=value : Display the offset part : value can be Hex or Decimal
  [NO]ALL          : Print all parts
  [NO]WRAP         : If set, DIX will wrap output to the width of the terminal.
                     If clear, DIX will not wrap. Default is WRAP

  HEX              : Display in HEX
  DECIMAL          : Display in Decimal
  BINARY           : Display in Binary
  OCTAL            : Display in Octal
  OFFSET=HEX       : Display the offset field in HEX
  OFFSET=DECIMAL   : Display the offset field in Deiomal
  OFFSET=NONE      : Do not display the offset part
  NOOFFSET         : Do not display the offset part
  [NO]RAW          : Set or clear RAW mode display
  BYTE             : display raw data in byte mode
  WORD             : display raw data in word mode
  LONGWORD         : display raw data in longword mode
  UNSIGNED         : display raw data (if not in hex mode) as unsigned integers.
  [NO]EBCDIC       : Set the EBCDIC translation flag
  [NO]WRAP         : If set, DIX will wrap output to the width of the terminal.
                     If clear, DIX will not wrap. Default is WRAP
  [NO]BIT_OFFSET   : Force offsets to be displayed with the bitoffset part.
                     Normally DIX displayes bit_offsets only if somewhere in the
                     record a data field is not byte aligned.

  The separator is used between the offset/field/value

  SEPARATOR=NONE     : Do not use a separator
  SEPARATOR=BAR      : Use | as separator 
  SEPARATOR=COMMA    : Use COMMA as separator	  
  SEPARATOR=TAB      : Use TAB char as separator
  SEPARATOR=COLON    : Use COLON (:) a separator
  SEPARATOR=SEMICOLON: Use SEMICOLON (;) as separator
  SEPARATOR=CHARACTER=%Xdd:  Use %Xdd as separator


###
</pre>
<a name="380">
<h3 Align=center><a href="dix_help_idx_5.html#371" target="index">DIX INTERACTIVE_COMMANDS EXAMINE QUALIFIERS /EBCDIC </a> </h3>
<pre>
  
 /EBCDIC
 /NOEBCDIC

  Override the /EBCDIC setting for a field (in description mode)
  or the file (in raw mode).
  
  So if the file was opened with /EBCDIC, (DIX would convert text fields
   to ASCII), you may still view the original data in EBCDIC via the 
   EXAM/NOEBCDIC
  or if the /EBCDIC is not specified the file or field, you may want an 
   explicit convert.

</pre>
<a name="381">
<h3 Align=center><a href="dix_help_idx_5.html#372" target="index">DIX INTERACTIVE_COMMANDS EXAMINE QUALIFIERS /EXPAND </a> </h3>
<pre>

  Force new expansion of the current description. If the description
  has conditional fields, and one of the symbols used as a condition
  has changed, you can force DIX to reexpand the description and
  therefore re-evaluate the conditions.
</pre>
<a name="382">
<h3 Align=center><a href="dix_help_idx_5.html#373" target="index">DIX INTERACTIVE_COMMANDS EXAMINE QUALIFIERS /FORMAT </a> </h3>
<pre>
  /FORMAT=option

  Normally all "character"-like fields will not contain unprintable data.
  These field types are CHARACTER,xSTRING.
  If the data does contain unprintables (hex 0:1f,7f,80:9f or ff) the
  /FORMAT qualifier determines how this data should be displayed.
  Default is the current format setting (set/show format)

   Option can be
    DOT   :All unprintables are replaced by a ".". This encoding is not
            reversible, after an unprintable value is replaced by a ".", 
            DIX cannot know what the unprintable value was. This may
            be a problem in the screen mode.
    HEX   :All unprintable data is displayed as %Xdd, a hexadecimal display.
            A % in the data will be displayed as %%. This display is reversible,
            so DIX can reconstruct the original unprintable value.
            If you are in this mode, on input a % must be entered as %%
    PASSALL:DIX will not change the unprintable data. The data is displayed as
            it is. THis mode will not work in screen mode, and maybe poorly
            when the output device is a terminal.
    DUMP   :Unprintable bytes are represented by a 2 or 3 letter mnemonic
            like &LT;DEL&GT; or &LT;CR&GT;. A &LT; in the text will be displayed as &LT;&LT;.
            This display is reversible, so DIX can reconstruct the original 
            unprintable value.
            If you are in this mode, on input a &LT; must be entered as &LT;&LT;

</pre>
<a name="383">
<h3 Align=center><a href="dix_help_idx_5.html#374" target="index">DIX INTERACTIVE_COMMANDS EXAMINE QUALIFIERS /HEADER </a> </h3>
<pre>
  In raw mode the /HEADER will output a line with the byte offsets
  of the data below.
</pre>
<a name="384">
<h3 Align=center><a href="dix_help_idx_5.html#375" target="index">DIX INTERACTIVE_COMMANDS EXAMINE QUALIFIERS /OUTPUT </a> </h3>
<pre>
 /OUTPUT=filename
  Print the output to a file.

</pre>
<a name="385">
<h3 Align=center><a href="dix_help_idx_5.html#376" target="index">DIX INTERACTIVE_COMMANDS EXAMINE QUALIFIERS /SCREEN </a> </h3>
<pre>
 /SCREEN
 /NOSCREEN (Default)
  Display the data in an SMG window, that allows you to scroll through it.
  See also SET PAGED SCREEN

</pre>
<a name="386">
<h3 Align=center><a href="dix_help_idx_5.html#377" target="index">DIX INTERACTIVE_COMMANDS EXAMINE QUALIFIERS /SEARCH </a> </h3>
<pre>
 /SEARCH=searchmask

  Display only fields the have a value that matches "searchmask"
  See also the FIND command

</pre>
<a name="387">
<h3 Align=center><a href="dix_help_idx_5.html#378" target="index">DIX INTERACTIVE_COMMANDS EXAMINE QUALIFIERS /PAGED </a> </h3>
<pre>
 If the output is printed to the terminal, the output is printed
  per page, and the user must type a return to continue

</pre>
<a name="388">
<h3 Align=center><a href="dix_help_idx_5.html#379" target="index">DIX INTERACTIVE_COMMANDS EXAMINE QUALIFIERS /ORIGINAL </a> </h3>
<pre>
 Do not display the data from the current (possibly modified) data in memory
 but use the original contents of this record.
</pre>
<a name="389">
<h3 Align=center><a href="dix_help_idx_5.html#380" target="index">DIX INTERACTIVE_COMMANDS EXAMINE QUALIFIERS /SAVE_AREA </a> </h3>
<pre>
 Do not display the data from the current (possibly modified) data in memory
 but use the save area (see also CUT and PASTE).

</pre>
<a name="390">
<h3 Align=center><a href="dix_help_idx_5.html#381" target="index">DIX INTERACTIVE_COMMANDS EXAMINE QUALIFIERS /RAW </a> </h3>
<pre>
 Display data in raw (non description) mode. In this mode the qualifiers
  /WORD, /BYTE, /LONG, and /BITS are significant. Default is the
  value specified in the SET DISPLAY /long/word/byte value
  
</pre>
<a name="391">
<h3 Align=center><a href="dix_help_idx_5.html#382" target="index">DIX INTERACTIVE_COMMANDS EXAMINE QUALIFIERS /WORD </a> </h3>
<pre>

  Display data in words. Valid only in /RAW mode.
</pre>
<a name="392">
<h3 Align=center><a href="dix_help_idx_5.html#383" target="index">DIX INTERACTIVE_COMMANDS EXAMINE QUALIFIERS /BYTE </a> </h3>
<pre>

  Display data in bytes.  Valid only in /RAW mode.
</pre>
<a name="393">
<h3 Align=center><a href="dix_help_idx_5.html#384" target="index">DIX INTERACTIVE_COMMANDS EXAMINE QUALIFIERS /LONG </a> </h3>
<pre>

  Display data in longwords. This is the default for RAW mode.
  Valid only in /RAW mode.
</pre>
<a name="394">
<h3 Align=center><a href="dix_help_idx_5.html#385" target="index">DIX INTERACTIVE_COMMANDS EXAMINE QUALIFIERS /UNSIGNED </a> </h3>
<pre>
  Display integers as unsigned. Not used for /HEX.
</pre>
<a name="395">
<h3 Align=center><a href="dix_help_idx_5.html#386" target="index">DIX INTERACTIVE_COMMANDS EXAMINE QUALIFIERS /HEX </a> </h3>
<pre>

  DIsplay the data in HEX. Default is decimal.
  If this qualifiers is specified in /RAW mode, the data is displayed in HEX.
  This qualifier can also be used in /NORAW mode (description mode). The
  data will be displayed in HEX. See also the /OFFSET qualifier
  /HEX is a shorthand for /RADIX=16

</pre>
<a name="396">
<h3 Align=center><a href="dix_help_idx_5.html#387" target="index">DIX INTERACTIVE_COMMANDS EXAMINE QUALIFIERS /OCTAL </a> </h3>
<pre>

  DIsplay the data in octal. Default is decimal/interpreted.
  If this qualifiers is specified in /RAW mode, the data is displayed in octal.
  This qualifier can also be used in /NORAW mode (description mode). The
  data will be displayed in octal. See also the /OFFSET qualifier
  /HEX is a shorthand for /RADIX=8

</pre>
<a name="397">
<h3 Align=center><a href="dix_help_idx_5.html#388" target="index">DIX INTERACTIVE_COMMANDS EXAMINE QUALIFIERS /BINARY </a> </h3>
<pre>

  DIsplay the data in binary. Default is decimal/interpreted.
  If this qualifiers is specified in /RAW mode, the data is displayed in binary.
  This qualifier can also be used in /NORAW mode (description mode). The
  data will be displayed in binary. See also the /OFFSET qualifier
  /HEX is a shorthand for /RADIX=2

</pre>
<a name="398">
<h3 Align=center><a href="dix_help_idx_5.html#389" target="index">DIX INTERACTIVE_COMMANDS EXAMINE QUALIFIERS /RADIX </a> </h3>
<pre>
  /RADIX=nn
  
  Display the data in a given radix. nn must be between 2 and 36
  For /radix=16,8,2 are shorthands defined as /HEX,/OCTAL and /BINARY
  A radix which is not a power of 2 (so not 2,4,8,16,32) can only be
  used on [u]integer fields
  For radix 36 the characters 0..9 and A..Z will be used (so Z=35)
</pre>
<a name="399">
<h3 Align=center><a href="dix_help_idx_5.html#390" target="index">DIX INTERACTIVE_COMMANDS EXAMINE QUALIFIERS /OFFSET </a> </h3>
<pre>
 /NOOFFSET

  /OFFSET=DECIMAL  (default)
  /OFFSET=HEX      
  /OFFSET=OCTAL
  /OFFSET=BINARY

 Display byte offsets for each field. This is the default.

</pre>
<a name="400">
<h3 Align=center><a href="dix_help_idx_5.html#391" target="index">DIX INTERACTIVE_COMMANDS EXAMINE QUALIFIERS /COMPRESS </a> </h3>
<pre>
  /NOCOMPRESS

 Do not display empty fields (spaces for text, and nulls for binary).
  Default is /NOCOMPRESS. 
 In /RAW mode a line will not be displayed if all values on that line are 0/blank

</pre>
<a name="401">
<h3 Align=center><a href="dix_help_idx_5.html#392" target="index">DIX INTERACTIVE_COMMANDS EXAMINE QUALIFIERS /MARK </a> </h3>
<pre>
  /MARK=(option[,option...)
  
   Option can be BOLD,UNDERLINE,REVERSE,BLINK
   Default option in REVERSE
       
  /MARK   Default for output to terminals (=/mark=reverse)
  /NOMARK Default for output to files

  If you specify /MARK, DIX will display fieldnames, that are in
  the current key of an indexed file, in the specified mode

</pre>
<a name="402">
<h3 Align=center><a href="dix_help_idx_5.html#393" target="index">DIX INTERACTIVE_COMMANDS EXAMINE QUALIFIERS /TAG </a> </h3>
<pre>
  /TAG
  /NOTAG 

  Display data from multiple files with file\desc\ tag.
  The default value is taken from the default display setting
  See the SET DISPLAY and SHOW DISPLAY commands

  IF tag is true, and the user examines multiple file/descriptions
   the display will prefix the fieldname with the file\description\ tag.


  If tag is false, fieldnames will be printed normally, and all 
   files/descriptions are signalled. Only if no file\description\
   mask is present, there will be no display of file/description.

  Example
   Assume we have 3 files opened (tags file1, file2 and file3) and
   on file1 there is a descr1 description etc...
   File2 is the current file

   DIX&GT;examine/tag *\*\*txt*  !display all fields with the name containing
                              !txt if all files opened and all descriptions.
   18|file1\descr1\mytxting|My Text
   12|file2\descr4\yourtxtorso|Your test
   12|file3\descr1\histxtornot|His text

   If the /tag would not have been specified, the display would look like

   File:file1.dat
   Description:descr1
   18|mytxting|My Text
   File:file2.dat
   Description:descr4
   12|yourtxtorso|Your test
   File:file3.dat
   Description:descr1
   12|histxtornot|His text
  
</pre>
<a name="403">
<h3 Align=center><a href="dix_help_idx_5.html#394" target="index">DIX INTERACTIVE_COMMANDS EXAMINE QUALIFIERS /QUOTED </a> </h3>
<pre>
   /QUOTED   
   /NOQUOTED

   Temporary overrule the current quoted setting
   If quoted is set, DIX will enclose non-numeric fields in "",
   just as if you had set the set quoted enabled.
   See the help about DIX INTER SET QUOTED   
</pre>
<a name="404">
<h3 Align=center><a href="dix_help_idx_5.html#395" target="index">DIX INTERACTIVE_COMMANDS EXAMINE QUALIFIERS /VERTICAL </a> </h3>
<pre>

  For raw mode, DIX will normally display data in OpenVMS-dump format.
  If you specify /VERTICAL, DIX will display data in one line per value.
  /vertical is automatic if the offset is not on a byte boundary or if
  the /bits is specified.
 
  Example

  DIX&GT;exa/raw/hex 404:416		!OpenVMS dump format
              31C2FF 00A7C639 A61DF700 ..9..1        404

  DIX&GT;exa/raw/hex/vert 404:416          !vertical format
  404.0=A61DF700
  408.0=00A7C639
  412.0=0031C2FF


  DIX&GT;exa/raw/hex 404:410
   000000 0031C2FF 00A7C639 A61DF700 ..9..1....    404  !OpenVMS dump format

  DIX&GT;exa/raw/hex/vert 404:410	                             !vertical format
  404.0=A61DF700
  408.0=00A7C639


</pre>
<a name="405">
<h3 Align=center><a href="dix_help_idx_3.html#159" target="index">DIX INTERACTIVE_COMMANDS EVALUATE </a> </h3>
<pre>

  Evaluate expression

  Syntax:
    EVALUATE[/qualifiers] expression[,exporession...]
 
  Evaluate expression. An expression can contain integers, reals, 
  character strings,field values and parameters.

  A synonym for EVALUATE is SAY

  See the help about  [DIX/help] interactive expressions
![DIX inter expres]Help about expressions

  DIX supports a lot of functions, see the help about 
    [DIX/help] interactive functions
  in "interactive_Commands functions"

 Normally DIX will evalueate the line and print the output directly
  but yous can also build a line in multiple times using /noterminate 
  and then print the total.
  See the /TERMINATE qualifier for more help

![function]DIX inter functions

</pre>
<a name="406">
<h3 Align=center><a href="dix_help_idx_4.html#267" target="index">DIX INTERACTIVE_COMMANDS EVALUATE qualifiers </a> </h3>
<pre>
</pre>
<a name="407">
<h3 Align=center><a href="dix_help_idx_5.html#398" target="index">DIX INTERACTIVE_COMMANDS EVALUATE qualifiers /OUTPUT </a> </h3>
<pre>
 /OUTPUT=filename
  Print the output to a file.

</pre>
<a name="408">
<h3 Align=center><a href="dix_help_idx_5.html#399" target="index">DIX INTERACTIVE_COMMANDS EVALUATE qualifiers /SCREEN </a> </h3>
<pre>
 /SCREEN
 /NOSCREEN (Default)
  Display the data in an SMG window, that allows you to scroll through it.
  See also SET PAGED SCREEN

</pre>
<a name="409">
<h3 Align=center><a href="dix_help_idx_5.html#400" target="index">DIX INTERACTIVE_COMMANDS EVALUATE qualifiers /PAGED </a> </h3>
<pre>
 If the output is printed to the terminal, the output is printed
  per page, and the user must type a return to continue

</pre>
<a name="410">
<h3 Align=center><a href="dix_help_idx_5.html#401" target="index">DIX INTERACTIVE_COMMANDS EVALUATE qualifiers /format </a> </h3>
<pre>
  /format=value

  How DIX should display unprintable characters for this evaluation only
  This will override the default format set via the SET FORMAT command.
  Be aware that the TAB character is regarded as unprintable.

  value can be DOT, HEX, DUMP, PASSALL 
  For more info see the SET FORMAT help

</pre>
<a name="411">
<h3 Align=center><a href="dix_help_idx_5.html#402" target="index">DIX INTERACTIVE_COMMANDS EVALUATE qualifiers /index </a> </h3>
<pre>

  eval/index indexed_symbol

  The argument must be an indexed symbol

  Display an indexed symbol with both index and value
  You can also specify /table, /right_justify, /vertical and /[no]header 


</pre>
<a name="412">
<h3 Align=center><a href="dix_help_idx_5.html#403" target="index">DIX INTERACTIVE_COMMANDS EVALUATE qualifiers /hex </a> </h3>
<pre>
  Display the result in HEX.
</pre>
<a name="413">
<h3 Align=center><a href="dix_help_idx_5.html#404" target="index">DIX INTERACTIVE_COMMANDS EVALUATE qualifiers /octal </a> </h3>
<pre>
  Display the result in octal.
</pre>
<a name="414">
<h3 Align=center><a href="dix_help_idx_5.html#405" target="index">DIX INTERACTIVE_COMMANDS EVALUATE qualifiers /binary </a> </h3>
<pre>
  Display the result in binary.
</pre>
<a name="415">
<h3 Align=center><a href="dix_help_idx_5.html#406" target="index">DIX INTERACTIVE_COMMANDS EVALUATE qualifiers /CSV </a> </h3>
<pre>
  /CSV
   /CSV=(Csv_option[,csv_option...])
  Csv_option can be
   NOQUOTES  : Do not 'quote' fields (see below)
   ALL_QUOTES: User quotes around all fields
   SEPARATOR=COMMA    : Use COMMA as separator	   (default)
   SEPARATOR=TAB      : Use TAB char as separator
   SEPARATOR=COLON    : Use COLON (:) a separator
   SEPARATOR=SEMICOLON: Use SEMICOLON (;) as separator
   SEPARATOR=BAR      : Use | as a separator
   SEPARATOR=CHARACTER=%Xdd:  Use %Xdd as separator
   QUOTE=DOUBLEQUOTE   : Use the " character for quotes around fields (default)
   QUOTE=QUOTE         : Use the ' character for quotes around fields
   QUOTE=CHARACTER=%Xdd: Use the %Xdd character for quotes around field

  If you want quoting (DEFAULT) , DIX will insert the "quotecharacter" 
  around text fields and field that contain the "separatorcharacter" or space

  If you specify ALL_QUOTES, DIX will insert the "quotecharacter"
  around all fields.

  If you specify NOQUOTES, DIX will never insert the "quotecharacter"


</pre>
<a name="416">
<h3 Align=center><a href="dix_help_idx_5.html#407" target="index">DIX INTERACTIVE_COMMANDS EVALUATE qualifiers /interval </a> </h3>
<pre>

  /interval=n

  If you specify /interval=n, DIX will start printing at positions in the
  line that are a multiple of n. This can be used together with /noterm
  to print out a simple table format.
  If the resulting text is wider than the 'n', DIX will replace the text by **** 

  You may combine this qualifier with the /right_just to right justify the text
   in the field
  
  Example 

  DIX&GT; eval/noterm/inter=10 10  !store 10 in the buffer 
  DIX&GT; eval/noterm/inter=10  	!append 20
  DIX&GT; eval/noterm/inter=10 30  !and 30
  DIX&GT; eval/inter=10  40        !and 40 and now print out the line
  10        20        30        40


   DIX&GT;say/noterm/inter=10/right "aa"
   DIX&GT;say/noterm/inter=10/right "bb"
   DIX&GT;say/noterm/inter=10/right "12345678919011"	!too wide
   DIX&GT;say ""						!and finish off
        aa        bb**********
   DIX&GT;say/inter=10/right "aa","bb","cc"	!all in one statement
        aa        bb        cc

</pre>
<a name="417">
<h3 Align=center><a href="dix_help_idx_5.html#408" target="index">DIX INTERACTIVE_COMMANDS EVALUATE qualifiers /quoted </a> </h3>
<pre>
  Print output in a format that can be used for input again.
   So if a symbol has type string (characters) , the default
    display is only the contents of the string.
    If you use the /quoted qualifier , the string is enclosed in "", 
    and "'s within the string will be doubled.
    
  Examples
   DIX&GT;a="test"
   DIX&GT;say a
   test
   DIX&GT;say/quoted a
   "test"		!enclose in quotes

   DIX&GT;a="te""st"
   DIX&GT;say a
   te"st
   DIX&GT;say/quoted a
   "te""st"		!enclose in quotes and double the " in the string


   DIX&GT;a=#ACE"(ID=system,acc=r)"
   DIX&GT;say a
   (IDENTIFIER=[SYSTEM],ACCESS=READ)
   DIX&GT;say/quoted a
   #ACE"(IDENTIFIER=[SYSTEM],ACCESS=READ)"  !this layout can be used 
                                            !for input
</pre>
<a name="418">
<h3 Align=center><a href="dix_help_idx_5.html#409" target="index">DIX INTERACTIVE_COMMANDS EVALUATE qualifiers /named </a> </h3>
<pre>
  For symbols/values of description or structures types only

  If you specify /named and evaluate a value DIX will include the
   fieldnames in the resulting output

  Example

  DIX&GT;load/structure def_main.struct	 !load the structure
  DIX&GT;sh struc/fu def_main               !what does it look like
  DEF_MAIN, level 1                      !
  File USER50:[STUBBF.PROGRAMS.DIX.SOURCE]DEF_MAIN.STRUCT;2
  INTEGER*4              INDEX
  CHARACTER*40           MYSTR
  REAL_X*16              REAL16VAL
  INTEGER*4              EXTRA_INT
  INTEGER*4              EXTRA2(2,3)
  DIX&GT;decl/stru=def_main val             !declare a symbol of this type

  DIX&GT;say val				 !normal evalute, only values
  [0,,0.0,0,[[0,0][0,0][0,0]]]

  DIX&GT;say/named val                        !eval with field names
  [INDEX=0,MYSTR=,REAL16VAL=0.0,EXTRA_INT=0,[[EXTRA2(1,1)=0,EXTRA2(2,1)=0]
  [EXTRA2(1,2)=0,EXTRA2(2,2)=0][EXTRA2(1,3)=0,EXTRA2(2,3)=0]]]

</pre>
<a name="419">
<h3 Align=center><a href="dix_help_idx_5.html#410" target="index">DIX INTERACTIVE_COMMANDS EVALUATE qualifiers /position </a> </h3>
<pre>
 
  /position=number

  If you use /position, DIX will insert the text at position 'number' 
   in the line. This can also be combined with the /noterm qualifier

  Example

  DIX&GT; eval/noterm "Result:"    !Store Result: (and do not print yet)
  DIX&GT; eval/positio=20 123      !and print 123 at pos 20 in the line
  Result:            123


</pre>
<a name="420">
<h3 Align=center><a href="dix_help_idx_5.html#411" target="index">DIX INTERACTIVE_COMMANDS EVALUATE qualifiers /right_justify </a> </h3>
<pre>

  if you print a table or index symbol you can specify the witch of each
  value/index. If the text does not fit in the fieldsize, DIX will print *'s

</pre>
<a name="421">
<h3 Align=center><a href="dix_help_idx_5.html#412" target="index">DIX INTERACTIVE_COMMANDS EVALUATE qualifiers /table </a> </h3>
<pre>

  /table=width    The field width
  /table=8        Default

   If table is negative, the dimensions are reversed in the display
     The result is the same as when you change the LOW_FIRST setting

  If the value results in a table on screen
  If other values are present on the line, the output line
    is flushed before and after the tables(s)

  DIX&GT;decl a(3,3)			!declare a table
  DIX&GT;a=[[1,2,3][4,5,6][7,8,9]] 	!fill it
  DIX&GT;say a                     	!normal inline display
  [[1,2,3][4,5,6][7,8,9]]
  DIX&GT;say/table  a              	!table display 
  (x,y)
        x       1       2       3
       y+------------------------
       1|       1       2       3
       2|       4       5       6
       3|       7       8       9
  DIX&GT;say/table=-8  a           	!reversed table display
  (y,x)
        x       1       2       3
       y+------------------------
       1|       1       4       7
       2|       2       5       8
       3|       3       6       9

  See also the /vertical qualifier and the /right_justify

</pre>
<a name="422">
<h3 Align=center><a href="dix_help_idx_5.html#413" target="index">DIX INTERACTIVE_COMMANDS EVALUATE qualifiers /terminate </a> </h3>
<pre>

  /terminate     The default
  /noterminate

  If you use the /noterminate, DIX will not print the expression directly
  but remember it for the next evaluate command. In this way you can
  buildup a whole line, and then finally print it

  Example
  DIX&GT; eval/noterm 10  !store 10 in the buffer 
  DIX&GT; eval/noterm 20  !append 20
  DIX&GT; eval/noterm 30  !and 30
  DIX&GT; eval  40        !and 40 and now print out the line
  10203040


  You can also use this with the /interval or the /position qualifier

  DIX&GT; eval/noterm/inter=10 10  !store 10 in the buffer 
  DIX&GT; eval/noterm/inter=10  !append 20
  DIX&GT; eval/noterm/inter=10 30  !and 30
  DIX&GT; eval/inter=10  40        !and 40 and now print out the line
  10        20        30        40

  DIX&GT; eval/noterm "Result:"    !Store Result: 
  DIX&GT; eval/positio=10 123      !and print 123 at pos 10 in the line
  Result:  123

</pre>
<a name="423">
<h3 Align=center><a href="dix_help_idx_5.html#414" target="index">DIX INTERACTIVE_COMMANDS EVALUATE qualifiers /vertical </a> </h3>
<pre>

  If you specify /vertical (and also /table), DIX will print each values
   on a new line. This is useful if the value is of type string.

  Example
   DIX&GT; a=f$read("test.txt",1,4)	!read the first 4 lines of test.txt
   DIX&GT; say/table/vert a
   (1)=First line
   (2)=Second line
   (3)=Third line
   (4)=Fourth line

</pre>
<a name="424">
<h3 Align=center><a href="dix_help_idx_5.html#415" target="index">DIX INTERACTIVE_COMMANDS EVALUATE qualifiers /type </a> </h3>
<pre>
 
  /type=enum_type

   Try to display the output using the enumeration_type

  example
  DIX&GT; ADD TYPE DAYS="0=sun,1=mon,2=tue,3=wed,4=thu,5=fri,6=sat"
  DIX&GT; integer/type=#days weekday
  DIX&GT; weekday=wed
  DIX&GT; Show symbol weekday
  WEEKDAY=sat
  DIX&GT; evaluate weekday		!the eval will always return the binary
  6
  DIX&GT; evaluate/type=#days weekday
  sat				!now display according to the enum type

</pre>
<a name="425">
<h3 Align=center><a href="dix_help_idx_3.html#160" target="index">DIX INTERACTIVE_COMMANDS EXIT </a> </h3>
<pre>
   EXIT [exit_status]

  Leave DIX or the current command level to a lower level.

  QUalifiers are
  /AUTO    Override the current auto setting
  /NOAUTO  "" ""

</pre>
<a name="426">
<h3 Align=center><a href="dix_help_idx_3.html#161" target="index">DIX INTERACTIVE_COMMANDS Expressions </a> </h3>
<pre>

  Expressions can use the following operators
  Arithmetic :    +,-,/,*,**(=exponentiation), //(string append)
  shift      :    &GT;&GT; (shift right), &LT;&LT; (shift left) and &GT;&AMP; (shift right arithmetic)
  Logical    :    &AMP;(=and),and,|(=or),or,^(=not),not operator.
  Comparison :    &LT;,&LT;=,=,&GT;=,&GT; or &LT;&GT;
                  LT,LE,EQ,GE,GT,NE
                  In DCL compat mode the following are also supported
                   .LT. ,.LE. ,.EQ. ,.GE. ,.GT. ,.NE.
                   .LTS.,.LES.,.EQS.,.GES.,.GTS.,.NES.

  Special    :    For character ranges like "A":"Z"
  
  Priority : : Character range (highest)
             **          8
             *,/         7
             +,-         6
             &GT;&GT;,&LT;&LT;,&GT;&AMP;    5
             Comparison  4
             ^,not       3
             &AMP;,and       2
             |,or        1
  
  Within a group parsing is done from left to right
  Brackets can be used to change priority of the operator.
  The operands can be 

  1. Numbers (integer or real) 
      Integers can be specified as just numbers
      or 'dddd'F with F=D(ecimal),H(ex),O(ctal),B(inary),or Rn[n]
              or %Rdddd  with R as above except the Rn[n].

      Reals as [sign]dd.dd[Xexponent[sign]dd]
           X  can be E(32 bits), D(64 bits) or Q(128 bits)
           example -1.0q-12   : 128 bits real
           If you do not specify a specific size (E,D,Q) DIX
            will use the best fitting real, so 1.2 will be real*4
            and 1.23456789 will be a real*8 (too many digits)

      Complex as (real_part,imaginary_part)
        The real and imaginary part must be specified as reals or integers

  2. character strings. They start and end with a ". For the + operator all
       type of strings can be added , also [x]string, not only char
  3. Logical constants (true or false)
  4. Symbols (with their types)
  5. Parameters/values
  6. Special functions. See the help about  [DIX/help] interactive functions
![DIX inter function]Help about functions
  7. All other data types #datatype[*size]"validstring"
     datatype can be any of the known types
     x=#ACE"(id=system,acc=r+w)"
     This syntax can also be used to select a field from a type definition
      Example
       DIX&GT; ADD TYPE DAYS="0=sun,1=mon,2=tue,3=wed,4=thu,5=fri,6=sat"
       DIX&GT; monval = #days"mon"
  8. Fields of the record.
     The full syntax of the fieldname is
     filetag\descriptiontag\fieldname. The filetag defaults to the
                                       currentfile.
                                       The descriptiontag defaults to the
                                       current description of the selected file.
     If there is only one tag, it is regarded as a filetag, so
      name\fieldname searches for field "fieldname" in the current description 
      of the file with tag "name".
     If there is no tag, the search will be for the fieldname in the current
      description of the current file.
     For some type of fields (f.e. bit values) a subfield({}) can be used
      See the help [DIX record_format field subfields]

  Names can refer to fieldnames, symbols, parameters, functions

  The normal order of evaluation is
     1. Functions
     2. Symbols
     3. Parameter/values
     4. Fieldnames

   But the order can be changed using the set evaluation_order command

  Preceding the name with a %F, %P, %S allows you to force a specific
  lookup. So if you have a fieldname, parameter and symbol with the name
  TEST:
   TEST   will find the SYMBOL (or the function if TEST was a valid 
                                   function name)
   %FTEST Will find the fieldname (and not the function,parameter or symbol)
   %PTEST will find the parameter (and not the function,parameter or fieldname)
   %STEST will find the symbol    (and not the function,fieldname or symbol)



   If the result of all above is again a table, you may specify a dimension
       again to subset the result value
     Example : suppose now is 2-APR-2009:10:11:12.13
       DIX&GT; say f$numtim()       will deliver [2008,3,2,10,11,12,13] : 
                                  a table of 7 integers
       DIX&GT; say f$numtim()(3)    will deliver 2 : the third element of the table
       DIX&GT; say f$numtim()(1:3)  Will deliver [2008,4,2] 
                                  a table of 3 integers (1..3)

  The operators have the normal meaning with some extensions
  for operations on character strings
  1. integer*character   will result in a string that contains
                         integer times the source
                         e.g. 10*"A" =&GT; "AAAAAAAAAA"
                              5*"AB" =&GT; "ABABABABAB"
  2. character/character will remove all occurrences of the second
                         string from the first
                         e.g. "ABABABAB"/"A"   =&GT; "BBBB"
                              "ABABCABAB"/"AB" =&GT; "C"
  3. date1-date2         The result will be a delta time, and thus 
                         date2 must be &GT;date1, or date2 must be a delta time
                         and the result will be a delta time.
  4. date1+date2         Date1 or date2 (or both) must be delta times
  5. "A":"Z"             Character range: This delivers a string of 26
                         characters "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  6. integer*deltatime   A new deltatime
     Deltatime*integer   A new deltatime
  7. Deltatime/integer   A new deltatime


</pre>
<a name="427">
<h3 Align=center><a href="dix_help_idx_3.html#162" target="index">DIX INTERACTIVE_COMMANDS FIND </a> </h3>
<pre>

  FIND[/qualifiers] searchmask

  Search data in record (not a record search).
  Display those fields that contain the sear-string. The compare is done
  in ascii mode with the normal OpenVMS wildcards (* and %).

  The output is the same as examine/search=searchmask *
  
</pre>
<a name="428">
<h3 Align=center><a href="dix_help_idx_4.html#271" target="index">DIX INTERACTIVE_COMMANDS FIND qualifiers </a> </h3>
<pre>
</pre>
<a name="429">
<h3 Align=center><a href="dix_help_idx_5.html#420" target="index">DIX INTERACTIVE_COMMANDS FIND qualifiers /RAW </a> </h3>
<pre>
 Display data in raw (non description) mode. In this mode the qualifiers
  /WORD, /BYTE, /LONG, /HEX are significant. Default is the /LONG.
  Offset can be specified as byte_offset[.bit_offset]
  
</pre>
<a name="430">
<h3 Align=center><a href="dix_help_idx_5.html#421" target="index">DIX INTERACTIVE_COMMANDS FIND qualifiers /WORD </a> </h3>
<pre>

  Display data in words. Valid only in /RAW mode.
</pre>
<a name="431">
<h3 Align=center><a href="dix_help_idx_5.html#422" target="index">DIX INTERACTIVE_COMMANDS FIND qualifiers /BYTE </a> </h3>
<pre>

  Display data in bytes.  Valid only in /RAW mode.
</pre>
<a name="432">
<h3 Align=center><a href="dix_help_idx_5.html#423" target="index">DIX INTERACTIVE_COMMANDS FIND qualifiers /LONG </a> </h3>
<pre>

  Display data in longwords. This is the default in /RAW mode.
  Valid only in /RAW mode.

</pre>
<a name="433">
<h3 Align=center><a href="dix_help_idx_5.html#424" target="index">DIX INTERACTIVE_COMMANDS FIND qualifiers /UNSIGNED </a> </h3>
<pre>
  Display integers as unsigned. Not used for /HEX.
</pre>
<a name="434">
<h3 Align=center><a href="dix_help_idx_5.html#425" target="index">DIX INTERACTIVE_COMMANDS FIND qualifiers /HEX </a> </h3>
<pre>

  Interpret the value in HEX mode.
</pre>
<a name="435">
<h3 Align=center><a href="dix_help_idx_5.html#426" target="index">DIX INTERACTIVE_COMMANDS FIND qualifiers /COMPRESS </a> </h3>
<pre>

  Do not display fields with "empty" values (0 for binaries and space for text)
</pre>
<a name="436">
<h3 Align=center><a href="dix_help_idx_5.html#427" target="index">DIX INTERACTIVE_COMMANDS FIND qualifiers /OUTPUT </a> </h3>
<pre>
 /OUTPUT=Filename

  Print the output to a file.
</pre>
<a name="437">
<h3 Align=center><a href="dix_help_idx_5.html#428" target="index">DIX INTERACTIVE_COMMANDS FIND qualifiers /SCREEN </a> </h3>
<pre>
 /SCREEN
 /NOSCREEN (Default)
  Display the data in an SMG window, which allows you to scroll through it.
  See also SET PAGED SCREEN
</pre>
<a name="438">
<h3 Align=center><a href="dix_help_idx_5.html#429" target="index">DIX INTERACTIVE_COMMANDS FIND qualifiers /PAGED </a> </h3>
<pre>
 If the output is printed to the terminal, the output is printed
  per page, and the user must type a return to continue
  
</pre>
<a name="439">
<h3 Align=center><a href="dix_help_idx_3.html#163" target="index">DIX INTERACTIVE_COMMANDS FOLLOW </a> </h3>
<pre>
 
   FOLLOW[/LOG][/automatic][/READ][/WRITE] fieldname

   This allows you to switch to a new record in a (new) file
   
   If you do not use any of the following qualifiers, the field has
    to defined with link info (/FILE,/KEY,/RECORD,/COMPUTE) 

   You may override the values defined in the field by using any of
    the qualifier below
    /FILE="filename"  or part of it, the current file is used as 
                       default filename)
    /DESCRIPTION=name if you want to override the default decription 
                       to be used)
    /COMP_LINE="expr" computation done on the fieldvalue
    /IF_LINE="expres" conditional string
    /KEY=keynr        field value is keyvalue for key 'keynr'
    /MATCH=LT|LE|EQ|GE|GT Match for keyed searches
    /RECORD           field value will be the record number of the file
    /RFA              field value will be the RFA of the file
    /BYTEOFFSET       field value will be a byetoffset in the file
 
   So either the field has link information or you override it,
    but the link information must be present.

   If that file is not already opened in DIX and you specified /automatic,
   DIX will try to open the file. If you do not specify /AUTOMATIC, you will
   be asked if you want to open the file.

   If the file can be opened and the record can be found, DIX will display the
   new record. If the file cannot be opened or the record cannot be found
   DIX will signal the error, and you stay in the current file/record.
   DIX will open the file in the same mode (read/write) as the source file,
   unless you overide with the /READ of /WRITE qualifier.

   See the help about [DIX/help] RECORD_FORMAT FIELD_DECL
   See also the  [DIX/help] interactive BACK command
![DIX DISPLAY RECORD_FORMAT FIELD_DECL]Help about /file
</pre>
<a name="440">
<h3 Align=center><a href="dix_help_idx_3.html#164" target="index">DIX INTERACTIVE_COMMANDS FOR_ENDFOR </a> </h3>
<pre>

 For has two syntaxes
  case 1: The normal integer syntax
    FOR symbol=first,last[,increment]
    ENDFOR

      first,last and increment must be integer. 
      last can be &LT; first, but then increment must be negative.

      The local Symbol is initialized with 'first', and checked against 'last'
      If first &LT;= last (and increment is &GT;0) or
         first &GT;= last (and increment is &LT;0) 

      The expressions first,last and increment are evaluated only once, at
      the FOR command. It is possible to execute the loop 0 times.

  Case 2: The enumeration variant
   FOR SYMBOL IN expression
   ENDFOR
   
     The expression may be a table of any kind.
     so you may specify
       FOR K IN [1,45,90]      Three iterations with K(integer)=1,45,90 
       FOR K IN ["A","X"]      Two iteration with K(Char) = "A", "X"
       FOR K IN "TEST"{*}      Four iterations with K(char)="T","E","S","T"
                               See the help about subfields

  the statements up to the ENDFOR will be executed, and then
    Case 1: Increment will be added to first and the check repeated.
    Case 2: The next enumeration element will be used

  If the condition does not match, the statement following
  ENDFOR will be executed.

  See the help about [DIX/help] interact expressions
  After the for loop finishes, or if you jump out of the loop 
  with a GOTO statement the symbol is no longer defined.

  It is not allowed to change the value of the FOR variable in
  the FOR loop (attempts are signalled and ignored).

  See also the help about the LEAVE and the CYCLE command 

  If you type the command from the terminal (instead from a command file)
  DIX will prompt you for more lines until the ENDFOR command is found,
  and then will execute the commands.
 
![DIX inter expression]help about expressions
 Example for a FOR construct

 FOR k=10,1,-2
  say "The value of K = ''k'"
 ENDFOR
 will deliver the output
  The value of K = 10
  The value of K = 8
  The value of K = 6
  The value of K = 4
  The value of K = 2
  

</pre>
<a name="441">
<h3 Align=center><a href="dix_help_idx_3.html#165" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS </a> </h3>
<pre>
  DIX supports functions during the evaluation of the input.

  Functions are defined with arguments.
  More info about these functions is in the deeper topics.
  The () are required, even if no arguments are present.
  Function names starting with F$ can be abbreviated if the name is unique
  other functionnames must be specified exactly.

  arithmetic functions

             arg1     Arg2      Arg3  Arg4 Output
  ABS     int/real/cpx                     Int/real : Abcolute value
  AND         Int      Int                 Int : Anded value
  OR          Int      Int                 Int : Ored  value
  NOT         Log                          Log : Reverse logical value
  EVEN        Int                          Log : True if arg1 is even
  ODD         Int                          Log : True if arg1 is odd
  ASHIFT      Int      Int                 Int : arg1 shifted arithm arg2 to right
  RSHIFT      Int      Int                 int : arg1 shifted arg2 to right
  LSHIFT      Int      Int                 int : arg1 shifted arg2 to left
  CSHIFT      Int      Int     Int         Int : arg1 shift circular by arg2/arg3
  MOD         Int      Int                 Int : mod(arg1,arg2)
  MAX       Int/real Int/real  Int/real    same: max value 
  MIN       int/real Int/real  Int/real    same: min value 
  AVERAGE   Int/real Int/real  Int/real    same: Average value 
  SUM       Int/real Int/real  Int/real    same: sum value 
  DOT_PRODUCT Int/real Int/real              same: the dot_product
  MINIDX      all                          Int: Table with min index of arg1
  MAXIDX      all                          Int: Table with max index of arg1
  BTEST       Int      Int                 Log : Return true if bit 'arg2' of arg1 is set
  IBSET       Int      Int                 Int : arg1 with bit 'arg2' set
  ILEN        Int                          Int : Length in bits of value
  IBCLR       Int      Int                 Int : arg1 with bit 'arg2' cleared
  SQRT        Int/real/cmplx               Real/cplx: Square root
  SIN/COS/TAN
            Int/real/cpx                   Real : Trigonometric function
  TAN/ASIN/ACOS/ATAN/SINH/COSH/TANH
              Int/real                     Real : Trigonometric function
  LOG10     Int/real/cpx                     Real : the 10LOG value
  LOG       Int/real/xpc                     Real : the eLOG value
  FAC         Int                          Int/real: Faculty 
  COMBINATIONS  Int    Int                 Int/real: #Combination
  PERMUATATIONS Int    Int                 Int/real: #permuntations
  EXP       Int/real/cplx                  same: The exponent value e**arg

  Conversion functions

  INT      Int/real/char/date/cpx          Int : Converted to int
  LOGICAL  Int                             Log : Converted to Logical
  NINT     Int/real/char/cpx               Int : Nearest integer
  REAL     Int/real/cpx                    Real: converted to real
  IMAG     cpx                             Real: Get the imag part
  STRING   All        Log                  Char: Converted to char (in hex mode)
  CONJG    cpx                             cpx : (a,b) returns (a,-b)
  CMPLX  Int/real INt/real                 cpx : the complex value

  Lexical functions
              arg1    arg2   arg3 arg4     Result 

  F$ADD       Many    Many    Int          Char: add text numeric string
  F$APPEND    Table   Table   ...          Table: Append two of more tables
  F$AREA      int     char    char         int/log: Info about an area
  F$BASE64    chr     many                 chr : convert to/from base64
  F$BITS      int     char/log cjar        int: List of set/clear bits
  F$CHAR      int                          char: make a string of 1 char
  F$CHECKSUM  int     int        char char Int : The checksum (4 args)
  F$COLLAPSE  char                         char: remove all spaces
  F$CONCAT    Any                          char: Return a string of all vals concatenated
  F$CONTEXT   char    symbol  char chr/int char 
                                           Char : empty string
  F$CONTROL   int                          int : control-t data
  F$CONVERT   char    char                 any : convert string to any other type
  F$CORRELATE int/real int/real            real: Correlation 
  F$CRC       Int     Int     Char         Int : the computed crc
  F$CRC_TABLE Int                          Int : the crc table (16 INT*4)
  F$CSID      symbol log/char              int: Clusternode -id
  F$CUNITS    Int      char                int: converion blocks/bytes
  F$CVTIME   char     char      char      date/int: Date conversion
 
  F$DATE      int/real/date  String        date: Create a date symbol
  F$DCL_PRESENT Chr   Symbol               Int : present/absent/negated
  F$DCL_GET_VALUE Chr Symbol               Chr : get the value of a qualifief/param
  F$DECIMAL   Int/chr                      Deci: Convert data to decimal type
  F$DESCRIPTION Int                        char: Name of description file
  F$DEVICE    Char int int sym log         char : the f$device function of DCL
  F$DIRECTORY None                         Char: the current directory
  F$DIVIDE    char    char  int int        char: ascii divide

  F$EDIT    String    String               char: Like DCL 
  F$ELEMENT   int      char      char      char: Return the n'th element
                                                 if n &LT;0 return the last+1+'n'
                                                 element
  F$ENUMERATE int     char                 char: Returns field/symbol/parameter names
  F$ENVIRON   char   int                   various : Info about the current environment
  F$EXISTS    char                         char: True or false for symbols
  F$EXTRACT   Int      Int      Char       char: Like DCL F$EXTRACT
                                                 if int&LT;0 return data from the
                                                 end of the string
  F$EXTV      int    int       any         int : Extract some bits (sign ext) from p3
  F$EXTZV     int    int       any         int : Extract some bits (zero ext) from p3
  F$FAO       char    allsorts             char: F$FAO of DCL
  F$FEXISTS   char                         char: True or False for fields
  F$FFT       Int/real/cplx                int/real/cplx : Fast Fourier transform
  F$FID_TO_NAME Char  Char/FID             Char: Convert disk/fid to filename
  F$FIELD     char    char                 char: return info about a field
  F$FILE      char                         chr/int: Attributes of the file
  F$FIS       char    char     char        int : First_in_set
  F$FLOAT     real   int     int    int    char: Convert a float to fixed format
  F$FNIS      char    char     char        int : First_not_in_set
  F$FTYPE     char                         char: The type of the field
  F$GETDVI    char    char                 various : See f$getdvi help
  F$GETJPI    Char/int Char/int            various : see the f$getjpi help
  F$GETQUI    Char   Char     Char chr/int Various : see the f$getqui help
  F$GETSYI    Char    int                  char/int
  F$GETUAI    Char    int                  char/int
  F$HASH_PASSWORD
              char  char int/char int char integer*8 hashed password
  F$HTONL/S   int                          Int : Convert integer to network byte order
  F$ICHAR     char                         Int : Return integer val of string of 1 length
  F$IDENTIFIER char/int char               int/char:Convert identifiers
  F$INDEX     any   any char char          any : query indexed symbols
  F$INTEGER   char/real/date               int : Convert to integer
  F$INSV      int    int      int    any   any : Insert bits in arg4
  F$KEY       int     char    char  Int    int/log: Info about a key
  F$LEFT      char                         char: Left justify string
  F$LENGTH    char    [log]                Int : Length of string/other value
  F$LOCATE    char    char     Char  char  Int : Find char1 in char2
  F$LOWCASE   char                         Char: Return lowercase string
  F$MATCHWILD char    char     Char  char  log : Check if arg2 matches wild in 
  F$MATCH_COND Int    Int   ...int         Int : index of condtion code matching
  F$MESSAGE   int     int/chr  char        char: The message text of operand
  F$MODE      NOne                         Char : Return the mode of the process
  F$MORSE     Char    char                 Char : Conversion to and from morse code
  F$MUL       Many    Many    Int          Char: multiply text numeric string
  F$NUMTIM    Date                         Inttable : the sys$numtim function
  F$PARSE     Char    Char    CHar Char    Char: like the DCL f$parse
  F$PID       symbol                       Char : process id
  F$PRIVILEGE char                         log: does the process have privs
  F$RAD50     Int/chr/rad50                Char/int: Convert text to rad50 and vv
  F$RADIX     Int     Int     Char         Char: Convert integer to any radix
  F$RANDOM   int/real                      Int/real : A random value
  F$READ      Char    Int      Int         Chr table: Table of all records
  F$REPLACE   char    char    char  char   chr table : replace text in string
  F$REVERSE   all                          All : reverse byte order of values
  F$RFA       int                          rfa : convert byteoffset to rfa
  F$RIGHT     char                         char: Right justify string
  F$SEARCH    Char    CHar    Char         Char: Like the DCL f$search
  F$SETPRV    Char/priv                    Priv : set/clear privs
  F$SORT      ANY     int     char         any : sort table
  F$SPLIT     Char                         Char : Table of partial char strings
  F$STRING    any                          char : convert to text
  F$SUB       Many    Many    Int          Char: subtract text numeric string
  F$SUM       int/real                     int/real: The sum of all elements of a table
  F$SYMBOL    char    char   int           any: Get info about symbol
  F$TABLE     char  int      int char      int: Table of record values
  F$TIME      char     Time                Char: See help about f$time 
  F$TRANSLATE char   char     char         char : translate (str$translate)
  F$TRIM      char                         Char: Delete trailing spaces
  F$TRNLNM    char    various              char/int: Like DCL
  F$TYPE      char                         char: The type of the symbol
  F$UPCASE    char                         Char: return uppercase string
  F$USER      None                         Char : the UIC
  F$VECTIM    Int                          Date: the lib$cvt_vectim
  F$VERIFY    int/log                      Log : Get and change the verify setting

 
  Data dependent functions

  FILECOUNT   None                         Int : Return the number of files open
  %DATA       char char                    Char: A string with the record contents
  %LOC        char char                    Int : The location of the field(s) in the data
  %BLOC       char char                    Int : The bitlocation of the field(s) in the data
  %RECORDSIZE char Char                    Int : The current recordsize
  %EOF        char                         Log : return true if file is at end of file
</pre>
<center>
<a href="dix_help_data_1.html#top_1" target="data">next</a>
</center>
<a name="bottom_0">
</body>
</html>
