<html>
<head>
<title>Help about dix_help
</title>
<body>
<a name="top_1">
<center>
<a href="dix_help_data.html#bottom_0"target="data">previous</a>
</center>
<a name="442">
<h3 Align=center><a href="dix_help_idx_4.html#275" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS ABS </a> </h3>
<pre>

  result=ABS(input)

  Return the absolute value of input

  Input can be integer, complex or real, and result will have the same type

</pre>
<a name="443">
<h3 Align=center><a href="dix_help_idx_4.html#276" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS AND </a> </h3>
<pre>

  AND (Value1,value2) delivers the ANDed value

  All arguments are integer
  The result is integer
</pre>
<a name="444">
<h3 Align=center><a href="dix_help_idx_4.html#277" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS ASHIFT </a> </h3>
<pre>

  ASHIFT (Value1,value2) delivers value1 right shifted by value2
   the shift is an arithmetic shift, the sign bit will shifted in from the left.

  All arguments are integer
  The result is integer
</pre>
<a name="445">
<h3 Align=center><a href="dix_help_idx_4.html#278" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS AVERAGE </a> </h3>
<pre>

   result = average(arg1[,arg2[,arg3...)

   argn   : (table) of (u)int or anyreal
   result : real value containing the average of all values of argn
            If all argn are u(int), result will be real*4, else the
            data type is the same as the greatest real size of all argn

   So average(1,1q1) will be real*16 (since 1q1 is a real*16)

</pre>
<a name="446">
<h3 Align=center><a href="dix_help_idx_4.html#279" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS BTEST </a> </h3>
<pre>

  BTEST (intval,bitnr[,"all"|"any"])

  Return true if bit 'bitnr' of intval is set. The lowest bit is 0.
  Intval may be a table, the result is a logical table of the 
    same dimension as intval

  Bitnr may be a table, 
   If ALL is specified, the result is true if all bits from bitnr are set in intval
   If ANY is specified, the result is true if any bit from bitnr is set in intval
  ANY is the default

   Args are integer, result is logical

  Example
   BTEST(2,1)           will be True
   BTEST(2,3)           will be false
   BTEST([4,2,1],1)     will be [false,true,false]
  
   BTEST(6,[1,2])       will be true (bit 1 and 2 are set)
   BTEST(6,[1,3])       will be true (bit 1 is set)
   BTEST(6,[1,3],"ALL") will be false, since bit 3 is not set
</pre>
<a name="447">
<h3 Align=center><a href="dix_help_idx_4.html#280" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS COMB </a> </h3>
<pre>

</pre>
<a name="448">
<h3 Align=center><a href="dix_help_idx_4.html#281" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS COMBINATION/PERMUTATION </a> </h3>
<pre>

   res=combinations(n,m)

   Returns the number of combinations with n and m
           result = n!/(m!*(n-m)!)
   Input : N,M : Integer , N must be &GT;=0, M must be &GT;=0 and &LT;=N
   Output: Res : Integer (or real if number too large)

   res=permutations(n,m)

   Returns the number of permutations with n and m
           result = n!/(n-m)!
   Input : N,M : Integer , N must be &GT;=0, M must be &GT;=0 and &LT;=N
   Output: Res : Integer (or real if number too large)

</pre>
<a name="449">
<h3 Align=center><a href="dix_help_idx_4.html#282" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS CMPLX </a> </h3>
<pre>

  Result=cmplx(real_value)		!imag will be 0
  Result=cmplx(,imag_value)           !real will be 0
  Result=cmplx(real_value,imag_value)	!both specified


  real_value, image_value may be real or integers
  The result will be a complex variable

  Real and imag values may be tables, but
   either Both tables have the same number of values
       or One table has only one element

</pre>
<a name="450">
<h3 Align=center><a href="dix_help_idx_4.html#283" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS CONJG </a> </h3>
<pre>
  
  Result=conjg(value)

  The conjugate function

  For complex values only
   if value = (val_real,val_imag), conjg(value) will be (val_real,-val_imag)
</pre>
<a name="451">
<h3 Align=center><a href="dix_help_idx_4.html#284" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS CSHIFT </a> </h3>
<pre>

  CSHIFT (Value1,value2[,size]) delivers value1 circular shifted by value2
  
  If value2 is &GT;0, the shift is to the left else to the right
  Size is the number of bits involved. 
  If not specified, it is the size of value1

  All arguments are integer
  The result is integer

</pre>
<a name="452">
<h3 Align=center><a href="dix_help_idx_4.html#285" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS DOT_PRODUCT </a> </h3>
<pre>

  The dot product operator on tables(matrices)

  result=dot_product(arg1,arg3)

  arg1 and arg2 are 1 or 2 dimensional table of reals/integers
  The result is 
   if arg1 and arg2 have 1 dimension (simple tables):
    arg1(n) and arg2(m) then n must be equal to m 
      and the result is scalar

    DIX&GT;say dot([1,2,3],[4,5,6])
    32

   If arg1 and arg2 are 2 dimension tables:
    arg1(n,m) and arg2(m,q) then the m's must be te same
      and the result is a table (n,q)

    DIX&GT;int a(2,3)=[[1,2][3,4][5,6]]
    DIX&GT;int b(3,4)=[[1,2,3][5,6,7][9,10,11][13,14,15]]
    DIX&GT;c=dot(a,b)
    DIX&GT;sh symb c
    C=table(2,4)
    DIX&GT;say c
    [[22,28][58,76][94,124][130,172]]

   If arg1 has one dimension and arg2 has two:
    arg1(m) arg2(m,q) then the m's must be equal 
      and the result is a 1-dim table (q)

    DIX&GT;int b(3,4)=[[1,2,3][5,6,7][9,10,11][13,14,15]]
    DIX&GT;say dot([1,2,3],b)
    [14,38,62,86]
  
   If arg1 has two dimensions and arg2 has one
    arg1(n,m) arg2(m) then the m's must be equal 
      and the result is a 1-dim table (n)

    DIX&GT;int a(3,4)=[[1,2,3][5,6,7][9,10,11][13,14,15]]
    DIX&GT;say dot(a,[1,2,3,4])
    [90,100,110]


</pre>
<a name="453">
<h3 Align=center><a href="dix_help_idx_4.html#286" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS EVEN </a> </h3>
<pre>

  EVEN (Value1) delivers true if value1 is EVEN

  The argument is integer
  The result is logical
</pre>
<a name="454">
<h3 Align=center><a href="dix_help_idx_4.html#287" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS EXP </a> </h3>
<pre>
  
  Syntax:  result=exp(input)
   
  The exponent function 

  Input may be : Integer
                 Real
                 Complex

  Output will be Real (for integer and real input) or complex for complex input

</pre>
<a name="455">
<h3 Align=center><a href="dix_help_idx_4.html#288" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS FAC </a> </h3>
<pre>

   result = fac(n)

    Compute the faculty n*n-1*n-2*n-3....*1

   N must be (a table) of type integer

   Result is (a table) of

    Integer*4 if    n&LT;13
    Integer*8 if 12&LT;n&LT;20
    Real*16   if    n&GT;=20

</pre>
<a name="456">
<h3 Align=center><a href="dix_help_idx_4.html#289" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS FILECOUNT </a> </h3>
<pre>

  Filecount()

  Return the number of files opened. No arguments may be specified, but
  the () must be present.
</pre>
<a name="457">
<h3 Align=center><a href="dix_help_idx_4.html#290" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS HEX </a> </h3>
<pre>
   result = hex(input)

  Make a string containing the hex value of the input
  Input can be all formats, output is a string

</pre>
<a name="458">
<h3 Align=center><a href="dix_help_idx_4.html#291" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS IBCLR </a> </h3>
<pre>

  IBCLR (intval,bitnr)

  Return intval with bit 'bitnr' cleared

  intval may be a table, the result is a table of the same dimension
  bitnr may be a table, all bits from bitnr  will be cleared

   Args are integer, result is integer
</pre>
<a name="459">
<h3 Align=center><a href="dix_help_idx_4.html#292" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS IBSET </a> </h3>
<pre>

  IBSET (intval,bitnr)

  Return intval with bit 'bitnr' set

  intval may be a table, the result is a table of the same dimension
  bitnr may be a table, all bits from bitnr  will be set

  Args are integer, result is integer
</pre>
<a name="460">
<h3 Align=center><a href="dix_help_idx_4.html#293" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS ILEN </a> </h3>
<pre>

  ILEN(ival)

  Returns the length (in bits) of the integer
  The result type is integer
 
 Examples:

 ILEN (4) has the value 3.
 ILEN (-4) has the value 2.

</pre>
<a name="461">
<h3 Align=center><a href="dix_help_idx_4.html#294" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS IMAG </a> </h3>
<pre>

  value = imag(argument)
  
  Return the imagnary part of a complex variable.
  
  Argument is complex
  return value is real

</pre>
<a name="462">
<h3 Align=center><a href="dix_help_idx_4.html#295" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS INT </a> </h3>
<pre>

  INT(datatype[,"QUIET|SIGNAL"]) will return an integer value


  datatype can be

   Integer : just a noop
   Real    : any real
   Complex : any complex
   Date    : convert to integer
   Udate   : Convert to integer
   Char    : Convert to integer

   If QUIET is specified, an overflow will result in a return of the value 0. 
</pre>
<a name="463">
<h3 Align=center><a href="dix_help_idx_4.html#296" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS LOGICAL </a> </h3>
<pre>

  Converts the integer to a logical (low bit)
  Argument is integer or logical, return value is logical
  You may abbreviate LOGICAL to LOGI

</pre>
<a name="464">
<h3 Align=center><a href="dix_help_idx_4.html#297" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS LOG </a> </h3>
<pre>
 
   result = LOG(value)

   Return the eLOG of the value
 
  Value can be 
   INTEGER 
     Result will be a REAL*4  (if less than 23 bits precision), or 
                      REAL*8  (if integersize=4), or 
                      REAL*16 (if integersize=8)
   Or any REAL type.
     Result is the the same real type as value
     If the real type is not a native real type for the platform 
     the output will be a native real with the same precision
   Or any COMPLEX type.
     Result is the the same real type as value
   
</pre>
<a name="465">
<h3 Align=center><a href="dix_help_idx_4.html#298" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS LOG10 </a> </h3>
<pre>
 
   result = LOG10(value)

   Return the 10LOG of the value
 
  Value can be 
   INTEGER 
     result will be a REAL*4  (if less than 23 bits precision), or 
                      REAL*8  (if integersize=4), or 
                      REAL*16 (if integersize=8)
   Or any REAL type.
     Result is the the same real type as value
     If the real type is not a native real type for the platform 
     the output will be a native real with the same precision
   Or any COMPLEX type.
     Result is the the same real type as value
        

</pre>
<a name="466">
<h3 Align=center><a href="dix_help_idx_4.html#299" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS LSHIFT </a> </h3>
<pre>

  LSHIFT (Value1,value2) delivers value1 left shifted by value2
  All arguments are integer
  The result is integer
</pre>
<a name="467">
<h3 Align=center><a href="dix_help_idx_4.html#300" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS MAX </a> </h3>
<pre>

  MAX (Value1,value2[,value3]) delivers MAX of value1,2,3

  You may mix integer and reals, the min value determines the type
  for all other datatypes all value'n; must have the same type 
  If one of the value'n' is a table, all elements are compared

  input : int/real/char/date
  Output : same type in input, except with the int/real rule (see above)

</pre>
<a name="468">
<h3 Align=center><a href="dix_help_idx_4.html#301" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS MIN </a> </h3>
<pre>

  MIN (Value1,value2[,value3]) delivers MIN of value1,2,3

  You may mix integer and reals, the min value determines the type
  for all other datatypes all value'n; must have the same type 
  If one of the value'n' is a table, all elements are compared

  input : int/real/char/date
  Output : same type in input, except with the int/real rule (see above)

</pre>
<a name="469">
<h3 Align=center><a href="dix_help_idx_4.html#302" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS MINIDX </a> </h3>
<pre>

   MINIDX(arg)

   Will return a table with dimension 1..ndim(arg). Arg must be a table
   The result is a list of integers designating the index of the 
    minimum value of arg

  input : int/real/char/date
  output: int 

  Example
    DIX&GT; a=[[6,2][3,4]]
    DIX&GT; say minidx(a) 
    [2,1]				!min idx is at element [2,1]
</pre>
<a name="470">
<h3 Align=center><a href="dix_help_idx_4.html#303" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS MAXIDX </a> </h3>
<pre>

   MAXIDX(arg)

   Will return a table with dimension 1..ndim(arg). Arg must be a table
   The result is a list of integers designating the index of the
    minimum value of arg

   input : int/real/char/date
   output: int 

  Example
    DIX&GT; a=[[18,2][13,4]]
    DIX&GT; say maxidx(a) 
    [1,1]				!max idx is at element [1,1]

</pre>
<a name="471">
<h3 Align=center><a href="dix_help_idx_4.html#304" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS MOD </a> </h3>
<pre>

  MOD (Value1,value2) delivers value1 MOD value2
                                             
  All arguments are integer.
  The result is integer
</pre>
<a name="472">
<h3 Align=center><a href="dix_help_idx_4.html#305" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS NINT </a> </h3>
<pre>

  NINT(real) will return an int value rounded

  Argument is character, real or complex
  return value is integer
</pre>
<a name="473">
<h3 Align=center><a href="dix_help_idx_4.html#306" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS NOT </a> </h3>
<pre>

  NOT (Value1) delivers the negated value

  The argument is logical
  The result is logical
</pre>
<a name="474">
<h3 Align=center><a href="dix_help_idx_4.html#307" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS ODD </a> </h3>
<pre>

  ODD (Value1) delivers true if value1 is ODD

  The argument is integer
  The result is logical

</pre>
<a name="475">
<h3 Align=center><a href="dix_help_idx_4.html#308" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS OR </a> </h3>
<pre>

  OR (Value1,value2) delivers the ORed value

  All arguments are integer
  The result is integer
</pre>
<a name="476">
<h3 Align=center><a href="dix_help_idx_4.html#309" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS REAL </a> </h3>
<pre>

  REAL(input) will return a real value
 
  Argument is integer, complex, real or character, return value is real
  F$REAL is an alias for this function

</pre>
<a name="477">
<h3 Align=center><a href="dix_help_idx_4.html#310" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS RSHIFT </a> </h3>
<pre>

  RSHIFT (Value1,value2) delivers value1 right shifted by value2
   the shift is a Logical shift, 0's will shifted in from on the left.

  All arguments are integer
  The result is integer
</pre>
<a name="478">
<h3 Align=center><a href="dix_help_idx_4.html#311" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS SQRT </a> </h3>
<pre>

   SQRT(value)   Will return a real of the current real size
            
   The value returned is the square root of the input value (=value**0.5)

   Value may be integer, complex or real

   If value is not complex, it must be &GT;=0 , so sqrt(-1) gives an error
   but sqrt((1,0)) does deliver the complex value

   DIX&GT; say sqrt(-1)
   %DIX-E-SQROONEG, Square root of negative value
   DIX&GT; say sqrt((-1,0))
   (0.0,1.0)

</pre>
<a name="479">
<h3 Align=center><a href="dix_help_idx_4.html#312" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS SUM </a> </h3>
<pre>

   result = sum(arg1[,arg2[,arg3...)

   argn   : (table) of (u)int or anyreal
   result : value containing the sum of all values of argn
            If all argn are u(int), result will be integer, else the
            data type is the same as the greatest real size of all argn

   If adding integers will result in an overflow, result will be real

   So sum(1,1q1) will be real*16 (since 1q1 is a real*16)


</pre>
<a name="480">
<h3 Align=center><a href="dix_help_idx_4.html#313" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS STRING </a> </h3>
<pre>

  STRING(allformats[,hex]) will return a string value

  Argument can be of all defined symbol types.
  hex can be true or false (or not present)

  The return value is char

</pre>
<a name="481">
<h3 Align=center><a href="dix_help_idx_4.html#314" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS TRIGONOMETRIC_functions </a> </h3>
<pre>

   result = function(value[,units])

  Units can be : DEGREES         value is 0..360
                 RADIANS Default value is 0..2*pi

    Function can be  SIN,SINH,COS,COSH,TAN,TANH,ASIN,ACOS,ATAN 

  Value can be (a table of)
    INTEGER 
     result will be a REAL*4  (if value has &LT;23 bits precision) or
                      REAL*8  (if integersize=4), or 
                      REAL*16 (if integersize=8)
    Or any REAL type.
     Result is the the same real type as value
     If the real type is not a native real type for the platform 
     the output will be a native real with the same precision
      For example on the ia64 the input real_f (vax float) 
                       will have output real_s (IEEE float)

    Or a complex type

   Value is by default expression in radians. 360 degrees is 2*PI radians

   Hint: You can get the value of PI via
     PI=4*ATAN(1.0)    !32 bit real
     PI=4*ATAN(1D0)    !64 bit real
     PI=4*ATAN(1Q0)    !128 bit real

</pre>
<a name="482">
<h3 Align=center><a href="dix_help_idx_4.html#315" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$ADD </a> </h3>
<pre>

    F$ADD(str1,str2[,width])

   Str1 and str may be integer, real, string, decimal values, result is a string

  F$ADD will add str1 to str2 and return the result
  If width is not specified, the result will be as long as needed
  If width &GT;0, the result will be blank filled in a string of length 'width' 
  If width &LT;0, the result will be zero filled in a string of length 'width' 
  If width&LT;&GT;0 and the result does not match, result will be a string
    of 'width' *
 
  Example
   SAY F$ADD("123","345")    Returns "468"
       F$ADD("123","345",6)  Returns "   468"
       F$ADD("123","345",-6) Returns "000468"
       F$ADD("123","345",2)  Returns "**"
       F$ADD(1,12.3)         Returns "13.3"
</pre>
<a name="483">
<h3 Align=center><a href="dix_help_idx_4.html#316" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$APPEND </a> </h3>
<pre>

   result = f$append(table,table...)

   Append the tables together

   The tables must have the same shape (equal number of dimensions, and
                                        equal number of elements/dimension)
     or differ only in one dimension (effectively one
        dimension is added with a value of 1 element (see below))

   The type of all tables must be the same.

   The setting of LOW_FIRST decides which dimension is taken for 1 if
   the the dimensions are different

   If LOW_FIRST disabled : (dim1[,dim2)) will be seen as (1,dim1[,dim2])
                 enabled : (dim1[,dim2]) will be seen as (dim1[,dim2],1)

   Example:

    DIX&GT;SAY F$APPEND([1,2,3,4,5],[6])	!equal dims
    [1,2,3,4,5,6]
    DIX&GT;SAY F$APPEND([1,2,3,4,5],6)	!One less
    [1,2,3,4,5,6]
    DIX&GT;say F$APPEND([[1,2,3][4,5,6]],[7,8])
    [[1,2,3,7][4,5,6,8]]
    DIX&GT;say F$APPEND([[1,2,3][4,5,6]],[[7,8][9,10]])
    [[1,2,3,7,8][4,5,6,9,10]]
    DIX&GT; A=[1,2,3]
    DIX&GT; say F$APPEND(a,15)
    [1,2,3,4,15]
    DIX&GT; say F$APPEND(4,5,[6,7],8)
    [4,5,6,7,8]

    A way to insert an element in the middle of a table

    DIX&GT; a = [1,2,3,4,5,6,7,8,9,10]
    DIX&GT; say f$append(a(1:5),20,a(6:10))
    [1,2,3,4,5,20,6,7,8,9,10]

  
</pre>
<a name="484">
<h3 Align=center><a href="dix_help_idx_4.html#317" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$AREA </a> </h3>
<pre>

   F$AREA(areanumber[,WHAT[,file]])

   Get info about an area
   Argument   type meaning
   areanumber Int  The area number (0..narea-1)
                   If areanumber not present, DIX will return a table
                   containing the requested value(s)
   WHAT       char What info do you wat, defaults to PRESENT
   file       char Which file , default the current
 

   What             Type Result
    PRESENT         log  True or false  (areanumber must be present)

    ALLOCATED       Int  The initially allocated blocks for this area
    BUCKET_SIZE     Int  Bucket size
    EXTENSION       Int  Extension size for this area
    USED            Int  How many blocks are used
    RECLAIM         Int  Reclaim bucket number
    NEXT            Int  Next block
    CURRENT_START   Int  Current start block
    BLOCKS          Int  Size of extent


</pre>
<a name="485">
<h3 Align=center><a href="dix_help_idx_4.html#318" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$BASE64 </a> </h3>
<pre>

   Result = F$BASE64(inp[,arg])
  
   Inp  : must be a string expression (may be a table)
   arg  : Char : TO or FROM convert from or to BASE64
          log  : To or FROM base64
         empty : To BASE64
 
   Result : Char a (table) of strings

  Examples

    DIX&GT;say f$base("DIX")			!Encode to base64
    RElY					!the result
    DIX&GT;say f$base(f$base("RElY"),"FROM")	!decode
    DIX                                         !or the orig string back
    DIX&GT;say f$base(f$base("DIX"),"FROM")	!encode/decode
    DIX                                         !result is the same

</pre>
<a name="486">
<h3 Align=center><a href="dix_help_idx_4.html#319" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$BITS </a> </h3>
<pre>

   Result = F$BITS(inp[,setclr][,Whattodo])

  Get a list of set or clear bits, or info about set/cleared bits
  
   Inp     : must be an (u)integer value
   setclr  : Char  : SET to get the set bits, CLEAR to get the clear bits
             log   : true to get the set bits, false to get the clear bits
             empty : The default is set bits
   whattodo: char  : Table/First/LAst/Count
                        Table : make a table of set /cleared bits (the default)
                        First : Find the first set/cleared bit, or -1
                        Last  : Find the last set/cleared bit, or -1
                        Count : Count the number of set/cleared bits
  Example
   DIX&GT; say f$bits(334)
   [1,2,3,6,8]

   DIX&GT; say f$bits(334,"C")
   [0,4,5,7,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31]

   DIX&GT; ; for k in f$bits(334) ; say "Bit ''k' is set" ;endfor
   Bit 1 is set
   Bit 2 is set
   Bit 3 is set
   Bit 6 is set
   Bit 8 is set

   DIX&GT; say f$bits(334,,"FIRST")
   1        !bit 1 is the first bit set (we start at 0)
   DIX&GT; say f$bits(334,,"LAST")
   8        !bit 8 is the last bit set
   DIX&GT; say f$bits(334,"CLEAR","LAST")
   31       !bit 31 is the last bit CLEAR   
   DIX&GT; say f$bits(334,"CLEAR","COUNT")
   27       !27 bits are cleared
   DIX&GT; say f$bits(-1,"CLEAR","LAST")
   -1       !all bits are set
</pre>
<a name="487">
<h3 Align=center><a href="dix_help_idx_4.html#320" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$CHAR_OR_CHAR </a> </h3>
<pre>

  F$CHAR(integer) of CHAR(integer) 

  Result is an character string with length 1 with the ascii-value of
  the argument.

  The argument is integer (must be between 0 and 255)
  The result is char

</pre>
<a name="488">
<h3 Align=center><a href="dix_help_idx_4.html#321" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$CHECKSUM </a> </h3>
<pre>

   F$CHECKUM(bpos,epos,[size],[alg],[filetag])  !for xor/sum checksuym
   F$CHECKUM([skip],[add],[flags],alg,filename/tag)  !for md5/sha* type

   alg  : char: Optional, XOR or SUM, MD5, 
                          SHA1,SHA224,SHA256,SHA384,SHA512 
                default is SUM. 
                The algorithm of  the checksum

   if alg is XOR or SUM
     bpos : int : starting position in data record (in bytes). The first
                byte in the buffer = 0
     epos : int : end position in the databuffer
     size : char: Optional, BYTE or WORD or LONGWORD, default is byte. 
                The size of the data elements
                May also be specified as integer with value 1,2 or 4

   If alg is MD5 or SHA*

     skip : Optional : Characters to skip from checksum
             Skip can be CR, LF, BOTH. On VMS dix will only count the record
             data. On windows (f.e.) the record separators will also be 
             checksummed.  By adding crlf after each record you
             can compare the checksums. 
     add  : Optional : Characters to add between records
             Add can be CR, LF, BOTH. On VMS dix will only count the record
             data. On windows (f.e.) the record separators will also be 
             checksummed.  By adding crlf after each record you
             can compare the checksums. 
     flags: Optional : (a list of)extra flags
             STRING : The filetag is a string to be checksummed and not a file.
             DEBUG  : Add extra (debug) info
             FULL   : Add more (debug) info
             EXACT  : For fixed files only. The last record can have less than
                      the fixed record length. RMS will always report the 
                      fixed record length. With this switch the checksum will
                      only be computed on the real file size.

     See also the help for the checksum command

   tag  : char  Optional file tag, default is current file
                or (for the md5 / sha* ) a filename
                or (for the md5 / sha* ) a string

   Result : for the XOR and SUM algorithm : integer
            for the MD5 and SHA algorithm : string

  examples: 
   for the XOR / SUM algorithm
    the indexf file has a checksum at the end of the record
             it is the "SUM" of the previous 255 words.
    des record
     ...
     ...
     integer*2 checksum (at offset 510)
    end record

    Can be computed with
      F$CHECKSUM(0,509,"WORD")
    or even more sophisticated 
      F$CHECKSUM(0,%LOC("CHECKSUM")-1,"WORD")


   For the MD5 or SHA algorithm
     say f$checksum(,,,"SHA",fname)             !print sha(256) checksum
     say f$checksum(,,"DEBUG","SHA512",fname)   !print sha512 checksum with
                                                 extra info
     say f$checksum(,,,"MD5",fname)             !print md5 checksum
     say f$checksum("LF",,,"SHA",fname)         !Exclude the LF characters
     say f$checksum(,"BOTH",,"SHA",fname)       !Add a CR LF after each record
     say f$checksum(,,"STRING","SHA","abcdefg") !show the checksum for 
                                                 string abcdefg
</pre>
<a name="489">
<h3 Align=center><a href="dix_help_idx_4.html#322" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$COLLAPSE </a> </h3>
<pre>

  F$COLLAPSE(string) will remove all blanks

  Input and result are character

</pre>
<a name="490">
<h3 Align=center><a href="dix_help_idx_4.html#323" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$CONCAT </a> </h3>
<pre>
 
   result = F$CONCAT(val[,val...])
 
   Return a string of all values concatenated.
   val can be any type. if val is a table, all fields of val are used.

</pre>
<a name="491">
<h3 Align=center><a href="dix_help_idx_4.html#324" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$CONTEXT </a> </h3>
<pre>

   Specifies selection criteria for use with the F$PID function.
   The F$CONTEXT function enables the F$PID function to obtain
   information about processes from any node in an OpenVMS Cluster
   system.

   Format

     F$CONTEXT(context-type, context-symbol, selection-item,

              selection-value, value-qualifier)
 

  Returns a null string ("").
 
</pre>
<a name="492">
<h3 Align=center><a href="dix_help_idx_5.html#483" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$CONTEXT Arguments </a> </h3>
<pre>
 

</pre>
<a name="493">
<h3 Align=center><a href="dix_help_idx_6.html#492" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$CONTEXT Arguments context-type </a> </h3>
<pre>

   Specifies the type of context to be built.

   At present, the only context type available is PROCESS, which is
   used in constructing selection criteria for F$PID. Privileges
   are not required to see processes for the same UIC. To see
   processes for another UIC in the same UIC group, you need the
   GROUP privilege, and to see processes systemwide, you need the
   WORLD privilege.
 

</pre>
<a name="494">
<h3 Align=center><a href="dix_help_idx_6.html#493" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$CONTEXT Arguments context-symbol </a> </h3>
<pre>

   Specifies a symbol that DCL uses to refer to the context memory
   being constructed by the F$CONTEXT function. The function F$PID
   uses this context symbol to process the appropriate list of
   process identification (PID) numbers.

   Specify the context symbol by using a symbol. The first time you
   use the F$CONTEXT function in a command procedure, use a symbol
   that is either undefined or equated to the null string. The
   symbol created will be a local symbol of type "PROCESS_CONTEXT".
   When the context is no longer valid-that is, when all PIDs have
   been retrieved by calls to the F$PID function or an error occurs
   during one of these calls-the symbol no longer has a type of
   "PROCESS_CONTEXT". Then you can use the F$TYPE function in the
   command procedure to find out if it is necessary to cancel the
   context.

   After setting up the selection criteria, use this context symbol
   when calling F$PID.
 

</pre>
<a name="495">
<h3 Align=center><a href="dix_help_idx_6.html#494" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$CONTEXT Arguments selection-item </a> </h3>
<pre>

   Specifies a keyword that tells F$CONTEXT which selection
   criterion to use. Use only one selection-item keyword per call
   to F$CONTEXT.

                                  NOTE

      Do not use the NEQ selection value on a list of items
      because it causes the condition to always be true.

      For example:

      EXAMPLE=f$context("PROCESS",CTX,"USERNAME","A*,B*","NEQ")

      This equation is parsed as "if the user name is not equal
      to A* or the user name is not equal to B*, then return the
      process of the users that meet the criteria." Because the
      operand is a logical or, the conditions will always be true
      (any name will be found to be not equal to A* or B*; ALFRED
      will not be equal to B*; BOB will not be equal to A*).

   The following table shows valid selection-item keywords for the
   PROCESS context type:

   Selection  Selection Value
   Item       Value    Qualifiers Comments

   ACCOUNT    String   EQL, NEQ   Valid account name or list of
                                  names. The asterisk (*) and
                                  the percent sign (%) wildcard
                                  characters are allowed.

   AUTHPRI    Integer  GEQ,       On Alpha, valid authorized base
                       GTR,       priority (0-63). On VAX, valid
                       LEQ,       authorized base priority (0-31).
                       LSS,
                       EQL, NEQ

   CANCEL                         Cancels the selection criteria for
                                  this context.

   CURPRIV    Keyword  ALL,       Valid privilege name keyword
                       ANY,       or list of keywords. For more
                       EQL, NEQ   information, see the HP OpenVMS
                                  Guide to System Security.

   GRP        Integer  GEQ,       UIC group number.
                       GTR,
                       LEQ,
                       LSS,
                       EQL, NEQ

   HW_MODEL   Integer  EQL, NEQ   Valid hardware model number.

   HW_NAME    String   EQL, NEQ   Valid hardware name or a list of
                                  keywords. The asterisk (*)  and
                                  the percent sign (%)  wildcard
                                  characters are allowed.

   JOBPRCCNT  Integer  GEQ,       Subprocess count for entire job.
                       GTR,
                       LEQ,
                       LSS,
                       EQL, NEQ

   JOBTYPE    Keyword  EQL, NEQ   Valid job-type keyword. Valid
                                  keywords are DETACHED, NETWORK,
                                  BATCH, LOCAL, DIALUP, and REMOTE.
                                  For more information, see the
                                  OpenVMS User's Manual.

   MASTER_    String   EQL, NEQ   PID of master process.
   PID

   MEM        Integer  GEQ,       UIC member number.
                       GTR,
                       LEQ,
                       LSS,
                       EQL, NEQ

   MODE       Keyword  EQL, NEQ   Valid process mode keyword. Valid
                                  keywords are OTHER, NETWORK,
                                  BATCH, and INTERACTIVE. For more
                                  information, see the OpenVMS
                                  User's Manual.

   NODE_      Integer  EQL, NEQ   Node's cluster ID number.
   CSID

   NODENAME   String   EQL, NEQ   Node name or list of node names.
                                  The asterisk (*)  and the percent
                                  sign (%)  wildcard characters are
                                  allowed. The default is your local
                                  node. To request all nodes, use
                                  the value "*".

   OWNER      String   EQL, NEQ   PID of immediate parent process.

   PRCCNT     Integer  GEQ,       Subprocess count of process.
                       GTR,
                       LEQ,
                       LSS,
                       EQL, NEQ

   PRCNAM     String   EQL, NEQ   Process name or list of process
                                  names. The asterisk (*)  and
                                  the percent sign (%)  wildcard
                                  characters are allowed.

   PRI        Integer  GEQ,       Process priority level number
                       GTR,       (0-63, on Alpha), (0-31, on VAX).
                       LEQ,
                       LSS,
                       EQL, NEQ

   PRIB       Integer  GEQ,       Base process priority level number
                       GTR,       (0-63, on Alpha), (0-31, on VAX).
                       LEQ,
                       LSS,
                       EQL, NEQ

   STATE      Keyword  EQL, NEQ   Valid process state keyword.
                                  For more information, see the
                                  description of the $GETJPI service
                                  in the HP OpenVMS System Services
                                  Reference Manual.

   STS        Keyword  EQL, NEQ   Valid process status keyword.
                                  For more information, see the
                                  description of the $GETJPI service
                                  in the HP OpenVMS System Services
                                  Reference Manual.

   TERMINAL   String   EQL, NEQ   Terminal name or list of names.
                                  The asterisk (*)  and the percent
                                  sign (%)  wildcard characters are
                                  allowed.

   UIC        String   EQL, NEQ   User identification code (UIC)
                                  identifier (that is, of the form
                                  "[group,member]").

   USERNAME   String   EQL, NEQ   User name or list of user names.
                                  The asterisk (*) and the percent
                                  sign (%) wildcard characters are
                                  allowed.
 

</pre>
<a name="496">
<h3 Align=center><a href="dix_help_idx_6.html#495" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$CONTEXT Arguments selection-value </a> </h3>
<pre>

   Specifies the value of the selection criteria. For example, to
   process all the processes running on node MYVAX, specify "MYVAX"
   with the "NODENAME" keyword. For example:

   X = F$CONTEXT("PROCESS", ctx, "NODENAME", "MYVAX", "EQL")

   Values that are lists are valid with some selection items. If you
   specify more than one item, separate them with commas (,).  The
   following example specifies a list of the nodes MYVAX, HERVAX,
   and HISVAX:

   X = F$CONTEXT("PROCESS",ctx,"NODENAME","MYVAX,HERVAX,HISVAX","EQL")

   You can use the asterisk (*) and the percent sign (%) wildcard
   characters for some values. Using wildcard characters for
   selection items is similar to using wildcard characters for file
   names.
 

</pre>
<a name="497">
<h3 Align=center><a href="dix_help_idx_6.html#496" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$CONTEXT Arguments value-qualifier </a> </h3>
<pre>

   Specifies qualifiers for selection values. You must qualify
   selection values.

   You can qualify a number, for example, by requesting that the
   selection be based on one of the following process values:

   o  LSS - less than the value specified in the call to F$PID

   o  LEQ - less than or equal to the value specified in the call to
      F$PID

   o  GTR - greater than the value specified in the call to F$PID

   o  GEQ - greater than or equal to the value specified in the call
      to F$PID

   o  EQL - equal to the value specified in the call to F$PID

   o  NEQ - not equal to the value specified in the call to F$PID

   You can qualify some lists with the ALL, ANY, EQL, or NEQ
   keywords. Such lists are usually masks such as the process
   privilege mask, which consists of the set of enabled privileges.

   o  ALL - requires that all items in the list be true for a
      process

   o  ANY - requests that any item in the list be part of the
      attributes of a process

   o  EQL - requires the values to match exactly (that is, values
      not specified must not be true of the process)

   o  NEQ - requires that the value must not match

   When using multiple selection values with a particular selection
   qualifier, a match on any one of the selection criteria is
   considered valid (as if an OR operand was in place); the
   selection values are not cumulative criteria (as if an AND
   operand was in place).

   The difference between ALL and EQL is that the values specified
   with ALL must exist, but other unspecified values can exist
   also. EQL requires that all values specified must exist, and
   all others may not. For example, to request those processes whose
   current privileges include TMPMBX (temporary mailbox) and OPER
   (operator), but may include other privileges, specify the ALL
   keyword. To request those processes whose current privileges are
   TMPMBX and OPER exclusively, specify the EQL keyword.
 

</pre>
<a name="498">
<h3 Align=center><a href="dix_help_idx_5.html#484" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$CONTEXT Examples </a> </h3>
<pre>

   1.!Establish an error and Ctrl/Y handler
     !
      ON ERROR THEN GOTO error
      ON CONTROL_Y THEN GOTO error
     !
      ctx = ""
      temp = F$CONTEXT ("PROCESS", ctx, "NODENAME", "*","EQL")
      temp = F$CONTEXT ("PROCESS", ctx, "USERNAME", "M*,SYSTEM","EQL")
      temp = F$CONTEXT ("PROCESS", ctx, "CURPRIV", "SYSPRV,OPER", "ALL")
     !
     !Loop over all processes that meet the selection criteria.
     !Print the PID and the name of the image for each process.
     !
     loop:
      pid = F$PID(ctx)
      IF pid .EQS. ""
      THEN
          GOTO endloop
      ELSE
          image = F$GETJPI(pid,"IMAGNAME")
          SHOW SYMBOL pid
          WRITE SYS$OUTPUT image
          GOTO loop
      ENDIF
     !The loop over the processes has ended.
     !
     endloop:
     !
      EXIT
     !
     !Error handler. Clean up the context's memory with
     !the CANCEL selection item keyword.
     !
     error:
      IF F$TYPE(ctx) .eqs. "PROCESS_CONTEXT" THEN -
       temp = F$CONTEXT ("PROCESS", ctx, "CANCEL")
     !
      EXIT

     In this example, F$CONTEXT is called three times to set up
     selection criteria. The first call requests that the search
     take place on all nodes in the cluster. The second call
     requests that only the processes whose user name either
     starts with an "M" or is "SYSTEM" be processed. The third
     call restricts the selection to those processes whose current
     privileges include both SYSPRV (system privilege) and OPER
     (operator) and can have other privileges set.

     The command lines between the labels "loop" and "endloop"
     continually call F$PID to obtain the processes that meet the
     criteria set up in the F$CONTEXT calls. After retrieving each
     PID, F$GETJPI is called to return the name of the image running
     in the process. Finally, the procedure displays the name of the
     image.

     In case of error or a Ctrl/Y operation, control is passed to
     error and the context is closed if necessary. In this example,
     note the check for the symbol type PROCESS_CONTEXT. If the
     symbol has this type, selection criteria must be canceled by
     a call to F$CONTEXT. If the symbol is not of the type PROCESS_
     CONTEXT, either selection criteria have not been set up yet
     in F$CONTEXT, or the symbol was used with F$PID until an error
     occurred or until the end of the process list was reached.

   2.f$context("process",ctx,"prcnam  ","symbiont*,mcote*","eql")

     f$context("process",ctx,"prcnam  ","symbiont*,mcote* ","neq")

     f$context("process",ctx,"prcnam  ","mcote* ","neq")
     f$context("process",ctx,"prcnam  ","symbiont*","neq")

     This example shows three sets of lexicals showing the
     difference between the EQL and the NEQ selection values. The
     first lexical function (with EQL) passes back all processes
     with symbiont and mcote in the process name. The second and
     third lexical functions (with NEQ) are equivalent in that they
     both will pass back all processes (processes that do not have
     symbiont in the process name, or processes that do not have
     mcote in the process name.)
 
</pre>
<a name="499">
<h3 Align=center><a href="dix_help_idx_4.html#325" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$CONTROL </a> </h3>
<pre>

   Get a 6 element table containing ELAPS,CPU,BUFIO,DIRIO,PAGEFLTS,COMMANDS

   res=F$CONTROL()       !return the data from the beginning of DIX
   res=F$CONTROL(b)      !return the data from b (must be a table of 6 integers)
   res=F$CONTROL(b,what) !return a specific field
         what 
         ELAPS        an integer(*8) containing the elaps time
         CPU          an integer containing the cpu time
         BUFIO        an integer containing the buffer io's
         DIRIO        an integer containing the direct io's
         PAGEFAULTS   an integer containing the pagefaults
         COMMANDS     an integer containing the number of commands executed
         ALL          a string containing 
   Elaps=0 00:02:53.75 CPU=0 00:00:00.08 BIO=79 DIO=3 PGFL=253 CMNDS=10

  You can use this for performance measurements
  DIX&GT;beg = f$control()
  DIX&GT;!!do something
  DIX&GT;diff = f$control() -beg
  DIX&GT;say f$control(diff,"ALL")
  Elaps=0 00:00:08.44 CPU=0 00:00:00.01 BIO=9 DIO=0 PGFL=0 CMNDS=1

</pre>
<a name="500">
<h3 Align=center><a href="dix_help_idx_4.html#326" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$CONVERT </a> </h3>
<pre>

    out_value=f$convert(inp_value,type)

     Convert a value(inp_value) to any type
     inp_value must be a character type

   Example
    suppose we have a file (tab separated) with N lines containing
    1. a name
    2. a birth date
    3. A title
   And you want a list of all ages of the people 

   You could do this as follows

   contents = f$read("file.txt")  !read the file contents in a table of N lines
   fields   = f$split(contents)   !fields will be table of N*3 fields
   dates    = fields(*,2)	  !dates is a table of N lines that contain dates
   bindates = f$convert(dates,"date") !make it datatype "date"
   now      = f$date("today")	  !get today
   ages     = now-bindates        !the the ages

   You could also have done it in one line:
  
   ages = f$date("today") - f$convert(f$read("tab.txt",,,"")(*,2),"date")

</pre>
<a name="501">
<h3 Align=center><a href="dix_help_idx_4.html#327" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$CORRELATE </a> </h3>
<pre>

    result=f$correlate(v1,v2)

   Return the correlation between v1 and v2
   Input  : v1,v2  : A table of integers/reals/dates. Both table must have the
                     same number of elements
   Output : result : Real*4 the correlation coefficient

</pre>
<a name="502">
<h3 Align=center><a href="dix_help_idx_4.html#328" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$CRC </a> </h3>
<pre>

   res = f$crc(crc_table,initial_value,string)

   crc_table     : a 16 int*4 table created by f$crc_table
   initial_value : Int*4 : The initial value for the crc (normally 0)
   String        : Chr   : the string to be crc'ed

   res : int*4 : the computed crc

   This function makes the LIB$CRC function available
  Example
 
    DIX&GT; Table = f$crc_table(%xa001)	!create a table
    DIX&GT; say f$crc(table,0,"TEST")
    59964

   Or in one line
    DIX&GT; say f$crc(f$crc_table(%xa001),0,"TEST")
    59964

 
</pre>
<a name="503">
<h3 Align=center><a href="dix_help_idx_4.html#329" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$CRC_TABLE </a> </h3>
<pre>

  crc_table=f$crc_table(poly_coefficient)

   Poly_coefficient : Int*4   
     A bit mask indicating which polynomial coefficients are to be
     generated by LIB$CRC_TABLE. 

   Crc_table : a 16 int*4 tabel that can be used by f$crc to compute crc's

   See the examples in f$crc
   This function makes the LIB$CRC_TABLE function available

</pre>
<a name="504">
<h3 Align=center><a href="dix_help_idx_4.html#330" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$CSID </a> </h3>
<pre>

   Return the nodeids of all node in the cluster. The output may be used
   in the f$getsyi
 
    a=f$csid(ctx[,val])

    ctx is a symbol name
    val is a dix extension
        Either a logical
        or a text string TABLE or LIST

   If val not present , or false or "list" , CTX must be present and
                          f$csid must be called in a loop to return a value
   If val is true or "TABLE" ctx may not be present, and the result is a 
                          table containing all csid's in  the cluster

   IF DIX is in DCL compat mode, the result is a string 
   If DIX is not in DCL mode, the result is integer

  Example
   lp:a=f$csid(ctx)
   if a&LT;&GT;"" then
     say f$getsyi("nodename",,a)
     goto lp
   endif

   a=f$csid(,true)	!make a table
   for k in a 		!go through all elements
     say f$getsyi("nodename",,k)
   end for

</pre>
<a name="505">
<h3 Align=center><a href="dix_help_idx_4.html#331" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$CUNITS </a> </h3>
<pre>
  
    Number = f$cunits(value,src,trg)
  
   Convert a value from and to blocks and bytes

   Value       : integer or char : the value to be converted
   src and trg : one of the following
       blocks      integer  size in blocks)   
       bytes       string   "abc[.def]Q"  Q may be K or M or G or not present
       exact       integer  size in bytes
       exstring    string   size in bytes nn.mm.dd, no Q present


</pre>
<a name="506">
<h3 Align=center><a href="dix_help_idx_4.html#332" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$CVTIME </a> </h3>
<pre>

    Value = f$cvtime(time,type,field)
 
   Time is a character or a date time variable
    if type is character it can be a
          absolute date
          Delta time
          abs+delta
          abs-delte
  
   Type 
       Absolute   : output is string in absolute time format
       Comparison : Ouput is string in comparison format
       Delta      : output is string in delta time
       DCL        : The same as absolute but with a : between the date and time
       Binary     : Ouput is date in "date" type
   Field :

 Return value is character

  Empty       Date/time
  DATETIME    The date/time
  DATE        The date
  TIME        The time
  MONTHASC    The name of the month

  Return value is integer for

  YEAR          The year
  MONTH         The month 
  DAY           The day
  HOUR          The hour
  MINUTE        The minute
  SECOND        The seconds
  HUNDREDTH     The hundredth
               
  MONTHOFYEAR   Month of the year
  DAYOFYEAR     Day of the year
  HOUROFYEAR    Hour of the year
  MINUTEOFYEAR  Minute of the year
  SECONDOFYEAR  Second of the year
  
  DAYOFMONTH    Day of the month
  HOUROFMONTH   Hour of the month
  MINUTEOFMONTH Minute of the month
  SECONDOFMONTH Second of the month

  DAYOFWEEK     Day of the week
  HOUROFWEEK    Hour of the week
  MINUTEOFWEEK  Minute of the week
  SECONDOFWEEK  Second of the week
  
  HOUROFDAY     Hour of the day
  MINUTEOFDAY   Minute of the day
  SECONDOFDAY   Second of the day
  
  MINUTEOFHOUR  Minute of the hour
  SECONDOFHOUR  Second of the hour
  
  SECONDOFMINUTE Second of the minute
  JULIANDATE    The Julian date
 
  DELTAWEEKS    Delta weeks
  DELTADAYS     Delta days
  DELTAHOURS    Delta hours
  DELTAMINUTES  Delta minutes
  DELTASECONDS  Delta seconds
</pre>
<a name="507">
<h3 Align=center><a href="dix_help_idx_4.html#333" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$DATE </a> </h3>
<pre>
  Syntax
   
   F$DATE(value[,what])

  Value can be
  1. a string containing a valid OpenVMS date-time
  2. an integer or real (table) and "what" decides what this value means.
     "what" can be 
       Weeks,days,hours,minutes,seconds,hundredth,cputicks : Deltatime 
       ticks : the 100nsec units, converted to a deltatime
       raw   : the 100nsec units, but not converted, so the result can
                be a deltatime(value&LT;0) or a normal time (val&GT;=0)
  3. A date/Udate (table) : 
      what can be DATE   : Return a date value (the default)
                  INTEGER: Return an integer value

  4. Nothing : this returns the current time/date

   F$DATE returns a symbol of type DATE, except in the case of the
     INTEGER tag in case 3. In that case F$DATE will be an integer(*8).

  examples

  DIX&GT;A = F$DATE("TODAY")
  DIX&GT;SHO SYMB A
  A=23-OCT-2003 00:00:00.00

  DIX&GT;A = F$DATE(1.3,"HOURS")
  DIX&GT;SHOW SYMB A
  A=0 01:17:59.99

</pre>
<a name="508">
<h3 Align=center><a href="dix_help_idx_4.html#334" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$DCL_PRESENT/GET_VALUE </a> </h3>
<pre>

   ival   = f$dcl_present("tag"[,symbolname])
   result = f$dcl_get_value("tag"[symbolname])

   After a command has been parsed using the PARSE command
    you can inquire if the qualifier/parameter is present
    and get the value of the qualifier/parameter

   Tag is the name of the qualifier/parameter.
   Symbolname is the name of the symbol used to parse the command
   ival : dix$_clipresent    : value is present
          dix$_cliabsent     : value is not present
          dix$_clinegated    : Value is negated
     For positional qualifiers, dix may also return
          dix$_clilocpresent : Value is locally present (after a parameter)
          dix$_clilocnegated : value is locally negated (after
 
    These parameters can be defined via the load/message command

   Example

   DIX&GT; LOAD/message  !define the dix$_* parameter values
   DIX&GT; VERB/COMPILE[/SYMBOL=symbolname] sys$update:acc.cld   !compile the .cld file

   DIX&GT; PARSE[/SYMBOL=symbolname][/STRICT] ACC x.dat,y.dat/full

   DIX&GT; if f$present("FULL") = DIX$_CLIPRESENT then say "Full present"
   DIX&GT; say f$dcl_get_value("INPUT")
   DIX&GT;say f$dcl_get_value("input")  !get the value of parameter p1 (label=input)
   X.DAT                  !first value of parameter 
   DIX&GT;say f$dcl_get_value("input")  !get the next value, it is a list type
   Y.DAT                  !second value of parameter 
   DIX&GT;say f$dcl_get_value("input")  !get the next value, it is a list type
                          !third value is empty
   DIX&GT;

   For more info see the command definition manual, and the cli_routinen help
   and the DIX help about the "verb/compile" and the "parse" commands
</pre>
<a name="509">
<h3 Align=center><a href="dix_help_idx_4.html#335" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$DECIMAL </a> </h3>
<pre>

   F$DECIMAL(stringvalue)
   F$DECIMAL(realvalue)
   F$DECIMAL(intvalue[,sign][,exponent])

   Convert an integer or string to the "decimal" type.
   If value is a string or a real, sign and exponent are not allowed

   If value is an integer, you may specify 
           sign     : charater string containing + or -
           Exponent : An integer containing the exponent

   The decimal type is a fixed decimal string

   Result: Decimal type

</pre>
<a name="510">
<h3 Align=center><a href="dix_help_idx_4.html#336" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$DESCRIPTION </a> </h3>
<pre>
  F$DESCRIPTION(index)
  
  Return info about the loaded descriptions
  Index is an integer
  Return value is the name of the loaded description (char)
</pre>
<a name="511">
<h3 Align=center><a href="dix_help_idx_4.html#337" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$DEVICE </a> </h3>
<pre>

   result  = f$device([namemask],[devclass],[devtype],[stream],[flag])

  namemask : A mask of device names e.g. *DSA*
  devclass : char : The device class like "DC$_DISK" or "DISK"
             DIX has predefined DISK,TAPE,SCOM,TERM,MAILBOX,WORKSTATION
             int  : the value of DC$_.. (see below)
  devtype  : Special device type  (the value of e.g. DT$_RA82, see below)
  stream   : In dcl mode a positive integer
             In non-dcl mode the name of a (non-existing) symbol
  flag     : If flag is specified (and stream is not present) DIX will
             return all matching values in a table.
             flag may be a logical or a string containing "TABLE"

  If you want to use the integer variants of devclass and devtype
  you can load the definitions via LOAD /MODULE=$DCDEF
  Now you have defined all parameters from the $DCDEF module and you
  can use them.

  Examples:
    DIX&GT; say f$device("*DSA*")
    _DSA0:                    	!the first match
    DIX&GT; say f$device("*DSA*")
    _DSA50:                     !the second match
    DIX&GT; say f$device("*DSA*")
    _DSA500:                    !the first match
    DIX&GT; say f$device("*DSA*")
                                !no more

    DIX&GT; say f$device("*DSA*",,,,true)
    [_DSA0:,_DSA50:,_DSA500:]    
    DIX&GT; devs = f$device("*DSA*",,,,true)
    DIX&GT; show symb/all devs
    DEVS(1)="_DSA0:"             !all 3 elements of the table devs(1..3)
    DEVS(2)="_DSA50:"
    DEVS(3)="_DSA500:"

</pre>
<a name="512">
<h3 Align=center><a href="dix_help_idx_4.html#338" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$DIRECTORY </a> </h3>
<pre>

 
    Name = F$DIRECTORY()

    Return the name of the current directory

</pre>
<a name="513">
<h3 Align=center><a href="dix_help_idx_4.html#339" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$DIVIDE </a> </h3>
<pre>
    F$DIVIDE(str1,str2[,width],[ndigits])


   Str1 and str may be integer, real, string, decimal values, result is a string

   F$DIVIDE will divide str1 by str2 and return the result. The result
      will be rounded.
  If width is not specified, the result will be as long as needed
  If width &GT;0, the result will be blank filled in a string of length 'width' 
  If width &LT;0, the result will be zero filled in a string of length 'width' 
  If width&LT;&GT;0 and the result does not match, result will be a string
    of 'width' *
  
  If ndigits is &GT;0, F$DIVIDE will insert 'ndigits' fractional digits. THe
  default value is the current setting of the set decimal/digits

  Example
   SAY F$DIVIDE("1234","2")    Returns "617"
       F$DIVIDE("1234","2",6)  Returns "   617"
       F$DIVIDE("1234","2",-6) Returns "000617"
       F$DIVIDE("1234","2",2)  Returns "**"
       F$DIVIDE("12","5")      Returns "2.4000000000"  !the default setting of
                                                       !set decimal/digits
       F$DIVIDE("12","5",,2)   Returns "2.40"          !overrule
       F$DIVIDE(12,3.2)        Returns "3.7500000000"


</pre>
<a name="514">
<h3 Align=center><a href="dix_help_idx_4.html#340" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$EDIT </a> </h3>
<pre>

   F$EDIT(string,"WHAT[,WHAT..]")
   Argument 1 : string  : The string to be edited
   Argument 2 : string  : The control string containing
                          COM[press]	replace all multiple blanks/tabs by one
                          COL[lapse]    Remove all blanks
                          T[rim]        Remove trailing blanks
                          UP[percase]   Make all chars uppercase
                          L[owercase]	Make all chars lowercase
                          UN[comment]	Remove comment "!" char
   If the string contains "s, then the part within "s is untouched.

   Result : string : The edited string 
</pre>
<a name="515">
<h3 Align=center><a href="dix_help_idx_4.html#341" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$ELEMENT </a> </h3>
<pre>

   F$ELEMENT(number,char,string)

  Return the 'number'th part of string "string" separated by "char"
  If number&LT;0 the result will be the last but 'number'th part
  The first element of the string has number 0.
  Example
  
  F$ELEMENT( 2,"|",A|B|C|D|E") returns C
  F$ELEMENT(-2,"|",A|B|C|D|E") returns D

  arg1 is integer
  arg2 is character (only first char used)
  arg3 is character
  Result is character
</pre>
<a name="516">
<h3 Align=center><a href="dix_help_idx_4.html#342" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$ENUMERATE </a> </h3>
<pre>
   F$ENUMERATE(index[,mask],[where],[level])

  index : Integer  : the index'th match is returned
  mask  : Character: Pattern match for the name
                       Supports * and %.
  Where : Character: DATA,VFC,BOTH(Default),SYMBOL,PARAMETER,VALUE

  Returns the 'index'th  field/symbol/parameter/value name that matches "mask"
 
  If the index is larger than the number of items, an empty string is returned

  For parameters and values you can also specify the command level where the
   parameter/value is defined. If you do not specify is, the current level
   is used. level=0 means the bo0lbal level
            level&GT;0 is the absolute command level
            level&LT;0 is the relative command level (-1 is one level up)
  
  Example return a list of fields matching *BYT*

   DIX&GT;index = 1
   DIX&GT;loop:value =F$ENUMERATE(index,"*BYT*")
   DIX&GT;if (value &LT;&GT; "") then
   DIX&GT;  say "Found name ",value
   DIX&GT;  index = index + 1
   DIX&GT;  goto loop
   DIX&GT;endif

  Return a list of all symbols
 
   DIX&GT;index = 1
   DIX&GT;loop
   DIX&GT;  value =F$ENUMERATE(index,,"SYMBOL")
   DIX&GT;testloop value&LT;&GT;""
   DIX&GT;  say "Found symvol name ",value
   DIX&GT;  index = index + 1
   DIX&GT;endloop
  
</pre>
<a name="517">
<h3 Align=center><a href="dix_help_idx_4.html#343" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$ENVIRONMENT </a> </h3>
<pre>
  F$ENVIRONMENT("What"[,level])

  Report some environment info

  What             Type   Meaning
  CASE_SENSITIVE   Log    Case sensitive mode enabled
  DEPTH            Int    Command procedure depth
  DEFAULT          Char   The current default disk/directory
  PROCEDURE        Char   Name of command procedure
  PROMPT           Char   The current Prompt string
  DCLCOMPAT        Log    The current value of the DCL compatible flag
  EVALUATION_ORDER Char   The current evaluation order
  INTERACTIVE      Log    Interactive mode
  MESSAGE          Char   The current message mode
  ON_SEVERITY      Char   The current on level
  ON_ACTION        Char   The current on action
  ON_OVERFLOW      Char   The current overflow action
  ON_CONTROLC      Char   The current control_c action
  OUTPUT_FILTER    Char   The current setting of the output filter (or empty)
  PRCNAM           Char   The current processname
  STRICT           Char   The current strict mode
  SUBSTITUTIONS    Char   The current substitutions settings
  VERIFY_PROCEDURE Log    The current procedure verify setting
  VERIFY_IMAGE     Log    The current image verify setting
  VERIFY_ALL       char   The current verify settings, can be used with set
                            set ver='f$envi("verify_all")'
  VERIFY_PREFIX    char   The current prefix setting
  VERSION          Char   The current version of DIX
  WILDCARD         Char   The current (default) wildcard settings
  SYMBOL_SCOPE     Char   The current setting of the symbol_scope
  MAX_DEPTH        Int    The max command depth (65535)  

  For most of the values the results can vary per level (@procedure level)
  If you do not specify level, the current level values will be returned,
   You may specify level as an abolute level (positive value) or a relative
   value (negative value)

  Example
 
   Suppose we are 3 deep nested
    f$envi("PROC")     returns the current procedure name
    f$envi("PROC",-1)  returns the procedure name of my caller
    f$envi("PROC",2)   returns the procedure name of level 2 (my caller)
 
</pre>
<a name="518">
<h3 Align=center><a href="dix_help_idx_4.html#344" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$EXISTS </a> </h3>
<pre>
  F$EXISTS(name)

  Name can be specified with or without quotes

  Deliver true if name is an existing symbol
</pre>
<a name="519">
<h3 Align=center><a href="dix_help_idx_4.html#345" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$EXTRACT </a> </h3>
<pre>

  F$EXTRACT(bpos,nkar,string)

  Extract part of the string (like DCL F$EXTRACT)
  If bpos is &LT;0 the bpos will be taken from the end of the string
  The first char of the string is at position 0 (and the last -1).

  Examples
  F$EXTRACT(2,3,"ABCDEF")   =&GT; CDE
  F$EXTRACT(-2,1,"ABCDEF")  =&GT; E

  arg1 is int
  arg2 is int
  arg3 is character
  result is character

</pre>
<a name="520">
<h3 Align=center><a href="dix_help_idx_4.html#346" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$EXTV </a> </h3>
<pre>
   F$EXTV(pos,size,base)

   Extract some bits (sign extended) from a source
   pos  (integer): the position from the base
   size (integer): Max number of bits (no more than 32)
   base (any)    : Source
   The result is an integer

</pre>
<a name="521">
<h3 Align=center><a href="dix_help_idx_4.html#347" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$EXTZV </a> </h3>
<pre>
   F$EXTZV(pos,size,base)

   Extract some bits (zero extended) from a source
   pos  (integer): the position from the base
   size (integer): Max number of bits (no more than 32)
   base (any)    : Source
   The result is an integer


</pre>
<a name="522">
<h3 Align=center><a href="dix_help_idx_4.html#348" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$FAO </a> </h3>
<pre>
  F$FAO(controlstring[,parameter[,paramter...]])

  Like the DCL F$FAO, format a string
  controlstring : char
  parameter     : either integer, character or date.
  Output        : char

</pre>
<a name="523">
<h3 Align=center><a href="dix_help_idx_4.html#349" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$FEXISTS </a> </h3>
<pre>
  F$FEXISTS(name[,where])

  Name can be specified with or without quotes, but if name contains
  dimensions, name must be enclosed in quotes

  Deliver true if name is an existing field
  Where can be
    NORMAL  : check the normal fields only
    VFC     : Check the VFC fields only
    BOTH    : Check both normal fields and vfc fields (default)

</pre>
<a name="524">
<h3 Align=center><a href="dix_help_idx_4.html#350" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$FFT </a> </h3>
<pre>
 
   Result = F$FFT(table[,DIRECTION],[RESULT][,METHOD])
  
   Compute a (Fast) Fourier transform of table
   Input : TABLE      : an integer/real or complex table table
           DIRECTION  : A character string specifying the direction
                        FORWARD(default)  or REVERSE
           RESULT     : A character string specifying the output
              BOTH    : Return a 2 dim table with REAL and IMAG data 
                         (default for a 2 dim or complex input table) 
                         if input is complex, the output will be complex
              REAL    : Return a 1 dim table with the real data
              IMAG    : Return a 1 dim table with the imaginary data
              ABS     : Return a 1 dim table with the absolute data 
                         =sqrt(real**2+imag**2) (default for a 1 dim 
                         input table) 
           METHOD     : A character string spcifying the algorithm   
              FAST    : Use the FFT algorithm. The number of elements in table
                        must be a power of 2.
              DISCRETE: Use the discrete algorithm. THe number of elements 
                        is not restricted (default for a not power of 2 table)
                        This method is much more cpu intensive.  
              AUTO    : Take the fast if input has power of 2 size, else take
                        the discrete method (this is the default setting)

   Table can be an integer,real table with one or two dimensions
     The first dimension is the number of data elements. If the 
     count is not a power of 2, DIX will switch to  DFT (Discrete Fourier 
     Transform). This will take a "little" longer to compute

     If table has one dimension, it is assumed to be a real value only.
       F$FFT will by default return the absolute of the FFT data 
        =SQRT(REAL**2+IMAG**2)

     If table has two dimensions, the second dimension must have 2 values
        Table(*,1) must contain the real data.
        Table(*,2) must contain the imag data.
       F$FFT will by default return a 2 dimensional table containing the 
        real and imaginary part of the result.


   Examples
    REAL data(1024)  !Only real data supplied
    !fill data with the values wanted
    RES=F$FFT(data)  !Return the absolute fft values. Res is a table (1024)

    REAL data(512,2) !Real and imaginary data supplied
    !fill data with the values wanted
    RES=F$FFT(data)  !Return real/imag values, RES is a table (512,2)
                     !res(*,1) is the the real data, res(*,2) the imag part

    REAL data(600)
    !fill data with the values wanted
    res=F$fft(data)  !do a DFT , since 600 is not a power of 2.
    res=f$fft(data,,,"FAST") !ReturnS aN error, cannot perform an FFT on 
                             ! a table with #elements not a power of 2
</pre>
<a name="525">
<h3 Align=center><a href="dix_help_idx_4.html#351" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$FID_TO_NAME </a> </h3>
<pre>

   filename = F$FID_TO_NAME(devnam,fid)

   Convert devnam/fid to filename
   devnam : char string containing the (disk-)device name
   fid    : Either a Fileid type or a character string including () (ddd,dd,dd)

   Result is char

   You need read access to the indexf.sys of the device
 
</pre>
<a name="526">
<h3 Align=center><a href="dix_help_idx_4.html#352" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$FIELD </a> </h3>
<pre>

  F$FIELD(name,what,[idx],["where"])

  Return info about a fieldname


  Name can be specified with or without quotes, but if name contains
  dimensions, name must be enclosed in quotes

  what can be
  EXISTS    : Return true or false whether the fieldname exists
  SIZE      : Returns the size (IN BITS) of the field
  OFFSET    : Return the byte offset
  BITOFFSET : Return the bit offset 
  TYPE      : The type of the field
  FIELD     : Return true if the field is in a bit-range.
  NDIM      : Number of dimensions 
  NAME      : the name of the 'idx' element

  Where can be
    NORMAL  : check the normal fields only
    VFC     : Check the VFC fields only
    BOTH    : Check both normal fields and vfc fields (default)


  For the next two items, a 3rd parameter can be used (the dimension index)
  F$FIELD(fieldname,what,idx[,"where"])
 
  LOWDIM    : the low value for dimension 'idx'
  HIGHDIM   : The high value for dimension 'idx'
  INCREMENT : The increment value for dimension 'idx'

</pre>
<a name="527">
<h3 Align=center><a href="dix_help_idx_4.html#353" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$FILE </a> </h3>
<pre>

  F$FILE("arg"[,index]) or F$FILE([index],"arg")

  Return info file 'index'
   Index can be : Not specified: DIX will use the current file
                : Integer      : The 'index'th opened file
                : char         : DIX will first try to locate an opened
                                  file with a tag 'index'. If that fails
                                  DIX will try to open file 'index' (and 
                                  close it after the f$file)

  Arg can be:

  arg             Meaning          Result Value
  ORG             Fileorganization Char   IDX REL SEQ 
  BLK             Open mode        Log    True or False 
  KEY             Currentkey       Int    Current key    (0 for nonindexed files)
  NAME            Filename         Char   Filename
  NOK             Numberofkeys     Int    Number of keys (0 for nonindexed files)
  TAG             Filenametag      Char   THe tag of this file
  RFA             RFA           Char/rfa  "(blocknr,byte)" in DCL mode or
                                          RFA (dix mode)
  RFABLOCK        RFA              int    The VBN part of the rfa
  RFAOFFSET or
  RFARECID        RFA              int    The OFFSEt/RECID part of the rfa
  RECORDLENGTH    Filerecordlength Int    The value of the fab.fab$w_mrs
  MAXRECORDLENGTH Filerecordlength Int    The value of the fab.fab$w_mrs
  MINRECORDLENGTH Filerecordlength Int    The value of XABKEY.XAB$W_MRL or 0
  EXACTSIZE       Filesize         Int    filesize in bytes including .ffb
  FID             Fileid           Fid    The fileid of the file
  DEVNAM          Devicename       Char   The devicename of the file
  PARFILEID       Fileid of parent FID    The fileid of the file's directory
  PARNAME         Name of parent   Char   The name of the file's directory
 
  NB_ACL          Byte size of acl Int    Number of bytes in aces
  ACLS            Acllist          Acl    A list of aces. THis may generate 
                                           an error if no acls are present
  HEADERS         Headercount      Int    Number of fileheaders
  EXTENTS         File extents     Int    Number of fileextents (may be 0)
  EXTLIST         File extents     Int    Table of n*2 elements. 
                                           The first is the logical blnr
                                           The second is the count
                                           This may generate an error if the
                                           file has no extents.

  For indexed files the following extra can be specified
  F$FILE("arg"[,index],[keyindex]) info for the 'keyindex'th key, default is
                                   the current

    KNAME       Char   NAme of the key
    KASCENDING  Log    Key is ascending
    KVALUE      Char   The value of the string type key
                [U]INT Value for integer type keys
    KSTRING     LOG    Key is string type
    KSEGMENT    Int    Number of key segments
    KTYPE       Char   Keytype
    KLENGTH     Int    Total keysize

  For keysegments there is a fourth parameter (the segment index)

    F$FILE("arg"[,index],[keyindex],[keysegment]) info for the 'keyindex'th key, 
                                                the 'keysegment'th segment

    KSPOS       Int    The position of the segment (or 0)
    KSSIZE      Int    The size of the segment (or 0)

  DESCRIPTION Description info

  For the description info two more arguments are allowed

  F$FILE("DESCRIPTION",[fileindex],[what],[desindex])
   what     : What information is returned
              NAME : The full name of the description
              TAG  : The tag of the description
   desIndex : The index of the description (default=current). 
              Desindex is either a number, or a string that will be matched 
              against the tag of the description
 
  Also all the DCL F$FILE arguments are supported

   Item       Type     Information Returned
   AI         Log/chr  TRUE if after-image (AI) journaling is
                       enabled; FALSE if disabled.
   ALQ        Integer  Allocation quantity.
   BDT        Date/chr Backup date/time.
   BI         Log/chr  TRUE if before-image (BI) journaling is
                       enabled; FALSE if disabled.
   BKS        Integer  Bucket size.
   BLS        Integer  Block size.
   CBT        Log/chr  TRUE if contiguous-best-try; otherwise FALSE.
   CDT        Date/chr Creation date/time.
   CTG        String   TRUE if contiguous; otherwise FALSE.
   DEQ        Integer  Default extension quantity.
   DID        Fileid   Directory ID string.
   DIRECTORY  Log/chr  Returns TRUE or FALSE. Returns TRUE if it is
                       a directory.
   DVI        String   Device name string.
   EDT        Date/chr Expiration date/time.
   EOF        Integer  Number of blocks used.
   ERASE      Log/chr  TRUE if a file's contents are erased before a
                       file is deleted; otherwise FALSE.
   FFB        Integer  First free byte.
   FID        Fileid   File ID string.
   FILE_      String   Record count and data byte count in the form
   LENGTH_             (n,m), where n is the record count and m is
   HINT                the data byte count. An invalidated count is
                       specified by a -1 for n or m.
   FSZ        Integer  Fixed control area size.
   GBC        Integer  Global buffer count.
   GBC32      Integer  Enhanced longword version of global buffer
                       count with a per-file maximum size of about
                       2.1 billion for indexed files.
   GBCFLAGS   String   Per-file management flags for sizing of
                       global buffer cache. Returns PERCENT if
                       global buffer count is expresses as a
                       percent, DEFAULT if global buffer size is
                       determined at runtime by an algorithm using
                       two global buffer SYSGEN parameters (GB_
                       CACHEALLMAX and GB_DEFPERCENT); or NONE if no
                       per-file management flags are enabled for the
                       file.
   GRP        Integer  Owner group number.
   JOURNAL_   Log/chr  TRUE if the file is a journal; otherwise
   FILE                FALSE.
   KNOWN      Log/chr  Known file; returns TRUE or FALSE to
                       indicate whether file is installed with the
                       Install utility (INSTALL). However, returns
                       NOSUCHFILE if a file does not exist (for
                       example, the file has been installed but
                       subsequently deleted).
   LOCKED     Log/chr  TRUE if a file is deaccessed-locked;
                       otherwise FALSE.
   LRL        Integer  Longest record length.
   MBM        Integer  Owner member number.
   MOVE       Log/chr  TRUE if movefile operations are enabled;
                       otherwise FALSE.
   MRN        Integer  Maximum record number.
   MRS        Integer  Maximum record size.
   NOA        Integer  Number of areas.
   NOBACKUP   Log/chr  FALSE if the file is marked for backup; TRUE
                       if the file is marked NOBACKUP.
   NOK        Integer  Number of keys.
   ORG        String   File organization; returns SEQ, REL, IDX.
   PRESHELVED Log/chr  TRUE if the file is preshelved; otherwise
   (Alpha/I64          FALSE.
   only)
   PRO        Protect  File protection string.
   PVN        Integer  Prolog version number.
   RAT        String   Record attributes; returns CR, PRN, FTN, "".
   RCK        Log/chr  TRUE if read check; otherwise FALSE.
   RDT        Date/chr Revision date/time.
   RFM        String   Record format string; returns the values VAR,
                       FIX, VFC, UDF, STM, STMLF, STMCR.
   RU         Log/chr  TRUE if recovery unit (RU) journaling is
                       enabled; returns TRUE or FALSE.
   RVN        Integer  Revision number.
   SHELVABLE  Log/chr  TRUE if the file is shelvable; otherwise
                       FALSE.
   SHELVED    Log/chr  TRUE if the file is shelved; otherwise FALSE.
   STORED_    Log/chr  ASCII string that represents stored
   SEMANTICS           semantics.
   UIC        UIC      Owner user identification code (UIC) string.
   VERLIMIT   Integer  Version limit number. The value 32767
                       indicates that no version limit was set.
   WCK        Log/chr  TRUE if write check; otherwise FALSE.


   In DCL mode the log/chr and the date/chr will return a string, 
    in DIX mode a logical or date
   this makes DIX more dcl compatible

  Examples 

  $DIX/int sysuaf/des=(sysuaf,.dir),alpha.dir/des=(.dir,profile)/mul
  %DIX-I-USINGFIL, Using file SYS$COMMON:[SYSEXE]SYSUAF.DAT;1/NOMOD
  %DIX-I-USINGDES, Using description DSA0:[STUBBE.PROGRAMS.DIX]DIX_DES.TLB;88(SYSU
  DIX&GT;sh file/all/des
  C TAG      Type    Filename                                       Size
  * SYSUAF   IDX     SYS$COMMON:[SYSEXE]SYSUAF.DAT;1                  48
   * SYSUAF  Descr   DIX_SYS(SYSUAF)
     DIR     Descr   DIX_SYS(.DIR)
    ALPHA    SEQ     SYS$SYSDEVICE:[STUBBE.PROGRAMS.DIX]ALPHA.DIR;1   15
   * DIR     Descr   DIX_SYS(.DIR)
     PROFILE Descr   DIX_SYS(PROFILE)
  * means the current file or description
  DIX&GT;say f$file("NAME")	  !returns the current file name
  SYS$COMMON:[SYSEXE]SYSUAF.DAT;1
  DIX&GT;say f$file("NAME",2) or
      say f$file("NAME","ALPHA")  !both return the name of the second file
  SYS$SYSDEVICE:[STUBBE.PROGRAMS.DIX]ALPHA.DIR;1
  DIX&GT;

</pre>
<a name="528">
<h3 Align=center><a href="dix_help_idx_4.html#354" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$FIS </a> </h3>
<pre>

  pos = F$FIS(string,setofchars[,"CASE_BLIND"])
  
  Get the first position of a character in string that
  matches any of the chars in setofchars. The first pos is 0.
  If all characters in string are not in setofchars 
  F$FIS will return the length of STRING.
  See also the help about STR$FIRST_IN_SET
    Only the result is one off to be more DCL compliant
  
  F$FIS("TESTSTRING","SR") will return 2.
  F$FIS("TESTSTRING","XYZ") will return 10 (not found)
  F$FIS("TESTSTRING","s")   will return 10 (not found)
  F$FIS("TESTSTRING","s","CASE_BLIND") will return 2  

</pre>
<a name="529">
<h3 Align=center><a href="dix_help_idx_4.html#355" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$FLOAT </a> </h3>
<pre>

   result=f$float(real_val,width,decimals[,exponent])

   Convert a real value/table to a fixed format
   This can be used in printing a table of real values.
 
   Input : real_val : any (table of) real type
           width    : Total width of the output value
           decimals : How many digits after the .
           exponent : How wide is the eponent part (optional)

   Output: a (table of) character*(width) 

   say f$float(12.34,10,3)
       12.340
   say f$float(12.34,10,0)
           12
   say f$float(1234.0,4,0)
   ****                        !does not fit
</pre>
<a name="530">
<h3 Align=center><a href="dix_help_idx_4.html#356" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$FNIS </a> </h3>
<pre>

  pos = F$FNIS(string,setofchars[,"CASE_BLIND"])
  
  Get the first position of a character in string that
  does not match any of the chars in setofchars. The first pos is 0.
  If all characters in string match setofchars 
  F$FNIS will return the length of STRING.
  See also the help about STR$FIRST_IN_SET
    Only the result is one off to be more DCL compliant

  F$FNIS("TESTSTRING","TE") will return 2.
  F$FNIS("TESTSTRING","TESTSTRING") will return 10 (not found).
  F$FNIS("TESTSTRING","t") will return 0.
  F$FNIS("TESTSTRING","te","CASE_BLIND") will return 2.

</pre>
<a name="531">
<h3 Align=center><a href="dix_help_idx_4.html#357" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$FTYPE </a> </h3>
<pre>
  F$FTYPE(name[,WHERE"])

  Name can be specified with or without quotes, but if name contains
  dimensions, name must be enclosed in quotes

  Where can be
   NORMAL : Look in the normal data
   VFC    : Look inn the VFC data
   BOTH   : Look in both (default)

  Deliver the type of an existing field
    many possibilities (see the help about [DIX/help] record field )

  This statement looks like the DCL F$TYPE, but it's argument may also be
  a string between quotes.

</pre>
<a name="532">
<h3 Align=center><a href="dix_help_idx_4.html#358" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$GETDVI </a> </h3>
<pre>

  Result = F$GETDVI(device,what,[fnr])
  Device : char string containing the device name
  what   : The item you want
  
  Result is depending on the what

   If you load the $DVIDEF module, you can ask any known device parameter
   You may then specify item as a name from one of these parameters
   See also the help about the LOAD command

  If what is a character string, dix will always have the following
   items defined

    What      Resulttype Explanation 
    ACP       Char       The acp type f11v1,f11v2,11v5
    MAXBLOCK  Integer    The size of the disk
    MAXFILES  Integer    Maximum number of files
    EXISTS    Logical    If the device exists TRUE else FALSE
    BLNRFILE  Integer    The record number of the fileheader-entry of the file
                          with fileid 0 in INDEXF.SYS. The record number in 
                          INDEXF.SYS of a file with fileid (12345,5,6) = 
                          F$GETDVI("disk","BLNRFILE") + 12345 
                          You must have READ access to the index file.
    FIDRECORD Integer    Is the same as BLNRFILE but the fnr is added to the
                          result. This allows you to return the recordnr
                          in the indexf.sys of the file with file "fnr"
                          fnr is the first number if the fileid (fnr,rev,volnr)
                          You must have READ access to the index file.

  If you have $DVIDEF loaded via the load/mod=$dvidef

   If what is text, DIX will try to find a parameter with the name text,
   or if that fails the parameter with the name "DVI$_text". 

   If what is integer, DIX will use that value to query $getdvi

   DIX&GT; LOAD/MODU=$DVIDEF            !this will read the $JPIDEF module from
                                     !STARLET.MLB and define the parameters
   DIX&GT; SAY F$GETDVI("SYS$SYSDEVICE","DVI$_UNIT")  !parameter found  via text
   13600
   DIX&GT; SAY F$GETDVI("SYS$SYSDEVICE","UNIT")       !parameter DVI$_* is 
                                                     found via text
   13600
   DIX&GT; SAY F$GETDVI("SYS$SYSDEVICE",JPI$_UNIT)    !the parameter is used
   13600



</pre>
<a name="533">
<h3 Align=center><a href="dix_help_idx_4.html#359" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$GETJPI </a> </h3>
<pre>

  Result = F$GETJPI([pid],what)
  
  PID is the pid 
           either an integer (probably expressed as %x20200101), 
           or a string containing the PID in hex

  what   : The item you want
           BUFIO         : the buffered io 
           DIRIO         : the direct io
           CPUTIM        : the cputime
           PAGEFLTS      : the pageflts
           PRCNAM        : The processname
           PRI           : The current priority
           PRIB          : The base priority
           USERNAME      : The username
           UIC           : The UIC

  Returns a value of various types (char/int/date/cpu)

  If you load the $JPIDEF module, you can ask any known system parameter
  you may then specify WHAT as a name from one of these parameters.
  See also the help about the LOAD command

  If WHAT is a string (and not one of the above), DIX will search for
  the parameter JPI$_'what' and if that fails for 'what'
  If one the parameter searches succeeds, DIX will use the value.
  
   DIX&GT; LOAD/MODU=$JPIDEF            !this will read the $JPIDEF module from
                                     !STARLET.MLB and define the parameters
   DIX&GT; SAY F$GETJPI(,"JPI$_WSSIZE")  !parameter found  via text
   13600
   DIX&GT; SAY F$GETJPI(,"WSSIZE")       !parameter JPI$_* is found via text
   13600
   DIX&GT; SAY F$GETJPI(,JPI$_WSSIZE)    !the parameter is used
   13600

   You can see which items are defined by loading the JPI* parameters and
   displaying them
    DIX&GT; LOAD /MOD=$JPIDEF
    DIX&GT; SHOW PARAM JPI$*

</pre>
<a name="534">
<h3 Align=center><a href="dix_help_idx_4.html#360" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$GETQUI </a> </h3>
<pre>

  Result = F$GETQUI(Function,[item],[object_id],[flags])

  Function is : Cancel_operation         Cancel context
                 Display_characteristics  Display a characteristic
                 Display_entry            Display things about an entry
                 Display_file             Display things about a file
                 Display_form             Display things about a form
                 Display_job              Display things about a job
                 Display_manager          Display things about a queue manager
                 Display_queue            Display things about a queue
       
  Item :        The following items are always defined
                 QUEUE_NAME
                 FORM_NAME
                 FILE_NAME
                 MANAGER_NAME
                 JOB_NAME

   If you load the $QUIDEF module, you can ask any known system parameter
   You may then specify item as a name from one of these parameters.
   See also the help about the LOAD command
 
   If ITEM is a string (and not one of the above), DIX will search for
   the parameter QUI$_'what' and if that fails for 'item'
   If one the parameter searches succeeds, DIX will use the value.
   
  Object_id :   A speciication of what to be searched

  Flags     :   Specific flags for the command

   ALL_JOBS         DISPLAY_JOB         Requests that F$GETQUI
                                        search all jobs included
                                        in the established queue
                                        context. If you do not
                                        specify this flag, F$GETQUI
                                        returns information only
                                        about jobs that have the
                                        same user name as the
                                        caller.

   BATCH            DISPLAY_QUEUE       Selects batch queues.
                    DISPLAY_ENTRY

   EXECUTING_JOBS   DISPLAY_ENTRY       Selects executing jobs.
                    DISPLAY_JOB

   FREEZE_CONTEXT   DISPLAY_            When in wildcard mode,
                    CHARACTERISTIC      prevents advance of wildcard
                    DISPLAY_ENTRY       context to the next object.
                    DISPLAY_FILE        If you do not specify
                    DISPLAY_FORM        this flag, the context is
                    DISPLAY_JOB         advanced to the next object.
                    DISPLAY_MANAGER
                    DISPLAY_QUEUE

   GENERIC          DISPLAY_ENTRY       Selects generic queues for
                    DISPLAY_QUEUE       searching.

   HOLDING_JOBS     DISPLAY_ENTRY       Selects jobs on
                    DISPLAY_JOB         unconditional hold.

   PENDING_JOBS     DISPLAY_ENTRY       Selects pending jobs.
                    DISPLAY_JOB

   PRINTER          DISPLAY_QUEUE       Selects printer queues.
                    DISPLAY_ENTRY

   RETAINED_JOBS    DISPLAY_ENTRY       Selects jobs being retained.
                    DISPLAY_JOB

   SERVER           DISPLAY_QUEUE       Selects server queues.
                    DISPLAY_ENTRY

   SYMBIONT         DISPLAY_QUEUE       Selects all output queues.
                    DISPLAY_ENTRY       Equivalent to specifying
                                        "PRINTER,SERVER,TERMINAL".

   TERMINAL         DISPLAY_QUEUE       Selects terminal queues.
                    DISPLAY_ENTRY

   THIS_JOB         DISPLAY_ENTRY       Selects all job file
                    DISPLAY_FILE        information about the
                    DISPLAY_JOB         calling batch job (entry),
                    DISPLAY_QUEUE       the command file being
                                        executed, or the queue
                                        associated with the calling
                                        batch job.

   TIMED_RELEASE_   DISPLAY_ENTRY       Selects jobs on hold until a
   JOBS             DISPLAY_JOB         specified time.

   WILDCARD         DISPLAY_            Establishes and saves a
                    CHARACTERISTIC      context. Because the context
                    DISPLAY_ENTRY       is saved, the next operation
                    DISPLAY_FORM        can be performed based on
                    DISPLAY_MANAGER     that context.
                    DISPLAY_QUEUE


  For further see the help for the dcl f$getqui 

</pre>
<a name="535">
<h3 Align=center><a href="dix_help_idx_4.html#361" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$GETSYI </a> </h3>
<pre>

  Result = F$GETSYI(what[,size])               !for the real_format 
  Result = F$GETSYI(what[,"node",[cluster_id]) !for all others
  
  what   : The item you want
            the following are always defined
             ARCHITECTURE  : the current arch VAX/Alpha/IA64
             HW_NAME       : The hardware name
             NODENAME      : The SCSNODE name
             VERSION       : The OpenVMS version
             REAL_FORMAT   : The floating point format used on this 
               size=4/8/16  bytes  architecture for the specified precision    
               or 32/61/128 bits   (size defaults to 4 bytes/32 bits)

  If you load the $SYIDEF module, you can ask any known system parameter
  You may then specify WHAT as a name from one of these parameters.
  See also the help about the LOAD command

  If WHAT is a string (and not one of the above), DIX will search for
  the parameter SYI$_'what' and if that fails for 'what'
  If one the parameter searches succeeds, DIX will use the value.
  
   DIX&GT; LOAD/MODU=$SYIDEF              !this will read the $SYIDEF module from
                                       !STARLET.MLB and define the parameters
   DIX&GT; SAY F$GETSYI("SYI$_BALSETCNT")  !parameter for via text
   351
   DIX&GT; SAY F$GETSYI("BALSETCNT")      !parameter SYI$_* is found via text
   351
   DIX&GT; SAY F$GETSYI(SYI$_BALSETCNT)   !the parameter is used
   351

   You can see which items are defined by loading the SYI* parameters and
   displaying them
    DIX&GT; LOAD /MOD=$SYIDEF
    DIX&GT; SHOW PARAM SYI$*

</pre>
<a name="536">
<h3 Align=center><a href="dix_help_idx_4.html#362" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$GETUAI </a> </h3>
<pre>

  Result = F$GETUAI(USERNAME,what)          

  Username : A character string containing the username. 
             If this argument is not specified, or contains only spaces,
             DIX will use the current user. Asking information of other 
             users may require privileges.
  what     : The item you want
              the following are always defined

               UIC       : the uic of the user
               DEVICE    : The default device ot the user
               DIRECTORY : The default directory of the user
               HOME      : DEVICE+DIRECTORY

  If you load the $UAIDEF module, you can ask any known UAI parameter
  You may then specify WHAT as a name from one of these parameters.
  See also the help about the LOAD command

  If WHAT is a string (and not one of the above), DIX will search for
  the parameter UAI$_'what' and if that fails for 'what'
  If one the parameter searches succeeds, DIX will use the value.
  
   DIX&GT; LOAD/MODU=$UAIDEF              !this will read the $UAIDEF module from
                                       !STARLET.MLB and define the parameters
   DIX&GT; SAY F$GETUAI("SYSTEM","UAI$_DEFDEV") !parameter found via text
   SYS$SYSROOT:
   DIX&GT; SAY F$GETUAI("SYSTEM","DEFDEV")      !parameter UAI$_* is found via text
   SYS$SYSROOT:
   DIX&GT; SAY F$GETUAI("SYSTEM",UAI$_DEFDEV)   !the parameter value is used
   SYS$SYSROOT:

   You can see which items are defined by loading the JPI* parameters and
   displaying them
    DIX&GT; LOAD /MOD=$UAIDEF
    DIX&GT; SHOW PARAM UAI$*

</pre>
<a name="537">
<h3 Align=center><a href="dix_help_idx_4.html#363" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$HASH_PASSWORD </a> </h3>
<pre>

   Result = F$HASH_PASSWORD(password,[algorithm],[salt],username)
    
   Password   : char : the password to be hashed
   algorithm  : char : AD_II , PURDY, PUDRY_S, PURDY_V, PREFERRED
                int  : a byte value 
                Default is the PREFERRED algorithm (127)
   salt       : Int  : the salt to be used
                Default is 0
   username   : char : The username to be used in the password hash
                       Trailing spaces are ignored.

   Result is an INTEGER*8 containing the hashed password
  
  Be aware that DIX will not change the case of any of the strings, and
  HASH_PASSWORD is case-sensitive. So you will get different answers
  if the case is different.

  For more info see the system_service documentation on $HASH_PASSWORD
   
 example

 DIX/INT SYSUAF
 DIX&GT;read/eq=myname
 DIX&GT;say/hex F$HASH("MYPWD",,UAF$W_SALT,UAF$T_USERNAME)  
 0F1025C0275A1D7A                               

 
</pre>
<a name="538">
<h3 Align=center><a href="dix_help_idx_4.html#364" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$HTONL/S </a> </h3>
<pre>

   oval=F$HTONL(ival)
   oval=F$HTONS(ival)

   Convert integers to network byte order (big endian)
   The byte order of all bytes is reversed
   This is a specific version (for integers only) of the the F$REVERSE
    functions   

   DIX&GT; SAY/HEX F$HTONS('01020304'X) 
   04030201

</pre>
<a name="539">
<h3 Align=center><a href="dix_help_idx_4.html#365" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$ICHAR_OR_ICHAR </a> </h3>
<pre>

  F$ICHAR(character)  or ICHAR(character)

  The argument must be exactly one character. 
  Result is an integer with the ascii-value of the argument.

</pre>
<a name="540">
<h3 Align=center><a href="dix_help_idx_4.html#366" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$IDENTIFIER </a> </h3>
<pre>

    int = f$identifier("NAME","NAME_TO_NUMBER")
    chr = f$identifier(65540,"NUMBER_TO_NAME")

   Convert id names to binary and reverse

</pre>
<a name="541">
<h3 Align=center><a href="dix_help_idx_4.html#367" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$INDEX </a> </h3>
<pre>
   
   value=F$INDEX(indexed_symbol,search,how,flag)
 
   Find values in indexed symbols 

    search : the value to be searched
    how    : LT,LE,GE,GT (symbol must be sorted) 
             EQ
             RECORD : search is record number
             ALL    : Return all values as a table 
    flag   : DATA|INDEX : return the data (default) or the index 

    If the value is not found a zero-length string will be returned
    and the $status will be set to error

    If you do not specify the search/how, DIX will return the next
    entry after the last search

  Example
   DIX&GT;integer/ind=char/sort jan
   DIX&GT;jan("A")=1
   DIX&GT;jan("Q")=2
   DIX&GT;jan("Z")=3
   DIX&GT;say f$index(jan,"K","EQ")  !not present
                                  !return empty string
   DIX&GT;show symb $status          !status is %RMS$E_RNF
   $STATUS=000182B2
   DIX&GT;say f$index(jan,"K","GE")
   2
   DIX&GT;say f$index(jan,"K","GE","I")
   Q
   DIX&GT;say f$index(jan,"K","LE")
   1
   DIX&GT;say f$index(jan,"K","LE","I")
   A
   DIX&GT;say  f$index(jan,2,"rec","I")
   Q

   DIX&GT;say f$index(jan)
   3
   DIX&GT;say f$index(jan)		  !read the next (not present)
                                  !Return the empty string
   DIX&GT;show symb $status          !status is %SYSTEM-W-ENDOFFILE
   $STATUS=00000870

   DIX&GT;say f$index(jan,,"ALL")		!return all data values
   [1,2,3]
   DIX&GT;say f$index(jan,,"ALL","INDEX")  !return all index values
   [A,B,Z]
   
</pre>
<a name="542">
<h3 Align=center><a href="dix_help_idx_4.html#368" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$INSV </a> </h3>
<pre>

    F$INSV(source,pos,size,base)

  Insert bits from source into base and return the changed value 
  (base is unchanged)
    source (integer) : the source of the bits
    pos  (integer)   : the position from the base
    size (integer)   : Max number of bits. There is no limit on the size,
                       only the size of the source (pos+siz&GT;=0 and
                       pos+siz&LT;sizeof(source)

    base (any)       : Original source (may be a table)

   The result is a the same type as base.

 Example
  k = 15
  newval = f$insv(15,4,4,k)
  Returns the value (type integer like k) of 255
</pre>
<a name="543">
<h3 Align=center><a href="dix_help_idx_4.html#369" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$INTEGER </a> </h3>
<pre>
  
   int = f$integer(char[,quiet])
   int = f$integer(real[,quiet])
   int = f$integer(date[,quiet])

  Convert other type to integer
 
  quiet :
    true/false          true is quiet mode
    "QUIET"/"SIGNAL"    "Quiet" is quiet mode

   If quiet is true/"QUIET" dix will not signal conversion errors and
    return 0 (like DCL). In DCL compatible mode QUIET is default
    In normal mode SIGNAL is default   

</pre>
<a name="544">
<h3 Align=center><a href="dix_help_idx_4.html#370" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$KEY </a> </h3>
<pre>
   F$KEY(keynumber[,WHAT],[file],[segmentidx])
   Get info about a key
   Argument   type meaning
   keynumber  Int  The key number (0..nkey-1) (or not present)
                   If not present, DIX will generate a table with the
                    requested info for all keyvalues.
   WHAT       char What info do you want, defaults to PRESENT
   file       char Which file (file tag) , default the current
   segmentidx Int  For SEGPOS,SEGSIZ the key segment (default=0)


   What             Type Result
    PRESENT         log  True or false  (keynumber must be present)

    ASCENDING       log  True if ascending key
    DATACOMPRESSED  log  True if the data in the data bucket is compressed
    DUPLICATE       Log  Does this key allowed duplicates
    INDEXCOMPRESSED log  True is the keys in the key buckets are compressed
    KEYCOMPRESSSED  log  True if the index in the data bucket is compressed
    NULL            Int  Null key value (-1 is no NULL key value)
    ROOT_LEVEL      Int  Depth of the index tree
    SEGPOS          Int  Start of keysegment segmentidx
    SEGSIZ          Int  Size of keysegment segmentidx
    SIZE            Int  The total keysize
    STRING          log  True is string type key
    TYPE            Chr  Key type
    VBNDATA         Int  The VBN of the data for this key (data or SIDR)
    VBNROOT         Int  The VBN of the root key bucket
</pre>
<a name="545">
<h3 Align=center><a href="dix_help_idx_4.html#371" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$LEFT </a> </h3>
<pre>
  F$LEFT(STRING) : Result is a left justified string
  Argument and result are character

</pre>
<a name="546">
<h3 Align=center><a href="dix_help_idx_4.html#372" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$LENGTH </a> </h3>
<pre>

  size=F$LENGTH(symbol[,what])
   What
    If what is not present or logical false or string "CHARACTER"
     "symbol" must be of type character
    If what is logical true or string "ALL"
     "symbol" can be any type

  F$LENGTH(string) will return the length of the symbol in bytes

</pre>
<a name="547">
<h3 Align=center><a href="dix_help_idx_4.html#373" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$LOCATE </a> </h3>
<pre>

  F$LOCATE(substring,sourcestring[,wildalgorithm][,case])

  Find a substring in a string
   Wildalgorithm can be STANDARD or EXTENDED or NONE
     NONE : No wildcard match
     STAN : *     : Matches all substrings (0 or more chars)
            %     : Matches exactly one char
     EXTE : *     : matches all substrings (0 or more chars)
            %     : matches exactly one char
            [abc] : Matches a "a" or a "b" or a "c"
            [-abc]: Matches anything except a,b,c
            [a-z] : Matches all letters (a-z)
            [-a-z]: Matches anything except letters
            'a    : Char "a" is not longer a special char ([*%' etc)
            ~     : If in front of the searchstring , the searchstring must be in the
                    beginning of the line, if at the end of the searchstring,
                    the searchstring must be at the end of the line
            !     : Matches one or more whitespace chars
  Case can be CASE_SENSITIVE or NOCASE_SENSITIVE

  sourcestring, substring and algorithm are strings
  Result is integer. The first position is 0.
                     If substring is not found F$LENGTH(sourcestring) is returned

</pre>
<a name="548">
<h3 Align=center><a href="dix_help_idx_4.html#374" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$LOWCASE </a> </h3>
<pre>

  F$LOWCASE(STRING) Result is a string with all letters (a-z) lowercased.

  argument and result are character


</pre>
<a name="549">
<h3 Align=center><a href="dix_help_idx_4.html#375" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$MATCHWILD </a> </h3>
<pre>

   F$MATCHWILD(Candidatestring,patternstring[,algorithm][,case])

   F$MATCH_WILD is an alias

   Algorithm can be STANDARD or EXTENDED
     STAN : *     : Matches all substrings (0 or more chars)
            %     : Matches exactly one char
     EXTE : *     : matches all substrings (0 or more chars)
            %     : matches exactly one char
            [abc] : Matches a "a" or a "b" or a "c"
            [-abc]: Matches anything except a,b,c
            [a-z] : Matches all letters (a-z)
            [-a-z]: Matches anything except letters
            'a    : Char "a" is not longer a special char ([*%' etc)
            ~     : If in front of the searchstring , the searchstring must be in the
                    beginning of the line, if at the end of the searchstring,
                    the searchstring must be at the end of the line
            !     : Matches one or more whitespace chars

  Case can be CASE_SENSITIVE or NOCASE_SENSITIVE

   See if candidatestring matches patternstring

   arguments are character, return value is logical

   Since there is als a F$MATCH_COND , the minimum length for the
   function is F$MATCHW

</pre>
<a name="550">
<h3 Align=center><a href="dix_help_idx_4.html#376" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$MATCH_COND </a> </h3>
<pre>

   idx = f$match_cond(match_cond_code,compare_cond_code,..)

  Check if match_cond_code matches any of the compare_cond_codes
  Input   : 2 or more integers
  Output  : Integer 0 is no match, 1..n is compare_con_code 1..m

  For more help see the help for the LIB$MATCH_CODE routine

   Since there is also a F$MATCHWILD , the minimum length for the
   function is F$MATCH_C


</pre>
<a name="551">
<h3 Align=center><a href="dix_help_idx_4.html#377" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$MESSAGE </a> </h3>
<pre>
   F$MESSAGE(integer[,fields],[filemask])

   Returns the message text from the integer
   The fields parameter is optional and selects the specific parts
   of the message.  It defaults to the current message mask.
   It may be specified as a bitmask

     bit 0  [1]: Text part
     bit 1  [2]: Identification
     bit 2  [4]: Severity
     bit 3  [8]: Facility
     bit 4 [16]: Executable specification if filemask is specified
     The value must be between 0 and 31.

   or as a (list of) text fields
     TEXT,IDENTIFICATION,SEVERITY,FACILITY,EXECUTABLE

   See also the "set message" and "show message" command for interactive mode.
     EXECUTABLE can only be specified if filemask is present
   On startup the message mask is set to 31.

   If files is not specified  DIX will search in its own message tables and
   the standard system messages. If filemask is  specified, DIX will 
   search all files specified in filemask (default file spec sys$message:*.exe)
   for the message code and return the text from that file.

   Example :

    DIX&GT; SAY F$MESSAGE(%XF98088)
    %DIX-W-NOMSG, Message number 00F98068       !message could not be found
    DIX&GT;say f$message(%xF98088,,"*")		!default flag=31
    RPG-W-NONASCKEY The record being written has a nonascending primary key
    value(in SYS$COMMON:[SYSMSG]RPG$MSG.EXE;1)  !message is found in rpg$msg.exe
    DIX&GT;say f$message(%xF98088,15,"*")		!do not display image
    RPG-W-NONASCKEY The record being written has a nonascending primary key
    value

   
  Examples
    DIX&GT;say f$message(12) 	!take the default mask
    %SYSTEM-F-ACCVIO, access violation, reason mask=!XB, virtual address=!XH,
    PC=!XH, PS=!XL
    DIX&GT;say f$mess(12,"se,id")	!include severity and identification
    %F-ACCVIO
    %SYSTEM-F-ACCVIO, access violation, reason mask=!XB, virtual address=!XH,
    DIX&GT;say f$mess(12,3)		!include text and identification
    %ACCVIO, access violation, reason mask=!XB, virtual address=!XH, PC=!XH, PS=!XL

</pre>
<a name="552">
<h3 Align=center><a href="dix_help_idx_4.html#378" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$MODE </a> </h3>
<pre>
  
   F$MODE()
   Deliver the mode of the current process

   INTERACTIVE/BATCH/NETWORK/OTHER

</pre>
<a name="553">
<h3 Align=center><a href="dix_help_idx_4.html#379" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$MORSE </a> </h3>
<pre>

  result = f$morse(string,"TO")   Convert text-string to morse code
  result = f$mores(string,"FROM") Convert morse code string to characters

  The input string may contain only A-Z or 0-9.
  Output string is a morse for each character, separated by spaces
  A space in the "TO" is translated to 4 spaces.
  Multiple spaces in the "FROM" are translated to 1 space.
  the "TO" field is optional so f$morse(string) is the same as
                                f$morse(string,"TO")
 Example
  DIX&GT; say f$mores("sos help","to")
  ... --- ...     .... . .-.. .--.
  DIX&GT; Say f$morse("... --- ...     .... . .-.. .--.","from")
  SOS HELP

  DIX&GT;;for kar in ("A":"Z" + "0":"9"){*} ; say kar," : ",f$morse(kar);endfor
  A : .-
  B : -...
  C : -.-.
  ....
  7 : --...
  8 : ---..
  9 : ----.

  DIX&GT;say f$replace(f$morse("SOS"),[".","-"],["bep ","beeeeep "])
  bep bep bep  beeeeep beeeeep beeeeep  bep bep bep

</pre>
<a name="554">
<h3 Align=center><a href="dix_help_idx_4.html#380" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$MUL </a> </h3>
<pre>
    F$MUL(str1,str2[,width],[ndigits])

   Str1 and str may be integer, real, string, decimal values, result is a string

  F$MUL will multiply str1 by str2 and return the result
  If width is not specified, the result will be as long as needed
  If width &GT;0, the result will be blank filled in a string of length 'width' 
  If width &LT;0, the result will be zero filled in a string of length 'width' 
  If width&LT;&GT;0 and the result does not match, result will be a string
    of 'width' *

  Example
   SAY F$MUL("123","12")    Returns "1476"
       F$MUL("123","12",6)  Returns "  1476"
       F$MUL("123","12",-6) Returns "001476"
       F$MUL("123","12",2)  Returns "**"
       F$MUL(1012.3)        Returns "123"
</pre>
<a name="555">
<h3 Align=center><a href="dix_help_idx_4.html#381" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$NUMTIM </a> </h3>
<pre>

   F$NUMTIM()
   F$NUMTIM(date)
   F$NUMTIM(string)
 
   Convert the date (or the current date) to an integer table of 7 values
   Input  is a date (or nothing ) or a character string containing a valid date
   Output is an integer table (7 long) containing year, month,day,hour,...

   Example
   
   DIX&GT; A=f$NUMTIM(#DATE"1-JAN-1008")
   DIX&GT; SH SYMB/FU A
   A(Integer*4,Level=1.0)= table(7)
   DIX&GT; SAY A
   [2008,1,1,0,0,0,0]


</pre>
<a name="556">
<h3 Align=center><a href="dix_help_idx_4.html#382" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$PARSE </a> </h3>
<pre>

   res = f$parse(fnam,[defnam],[relnam],[what],[parsetype])

   fnam     :Char: A  filename mask optionally containing * and %
   defnam   :Char: the default filename
   relnam   :Char: THe related filename string
   what     :Char: What item : Node/device/directory/name/type/version
                   Multiple items may be present, comma separated
                   If one of the items is preceeded by a -, all fields
                   except the named ones will be present 
                    f.e. -version will return the complete filename without the
                         version  
   parsetype:Char: Topic[,topic..]
                   Where topic can be
                     NO_CONCEAL : do not conceal device names
                     SYNTAX_ONLY: Perform parse without I/O
                     PASSWORD   : Do not conceal password
                     NICE       : Transform ods-5 names to readable
   Res :char: the found filename or the emtpy string

</pre>
<a name="557">
<h3 Align=center><a href="dix_help_idx_4.html#383" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$PID </a> </h3>
<pre>

   Returns a process identification (PID) number and updates the
   context symbol to point to the current position in the system's
   process list.

   Format

     F$PID(context-symbol)
 

  Returns

   In normal mode the return value is an integer containing the pid 

   In DCL mode the reurn value is a string containing the PID of a 
   process in the system's list of processes.
 

</pre>
<a name="558">
<h3 Align=center><a href="dix_help_idx_5.html#544" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$PID Argument </a> </h3>
<pre>
 

 context-symbol

   Specifies a symbol that DCL uses to store a pointer into the
   system's list of processes. The F$PID function uses this pointer
   to return a PID.

   Specify the context symbol by using a symbol. The first time you
   use the F$PID function in a command procedure, you should use
   a symbol that is either undefined or equated to the null string
   ("") or a context symbol that has been created by the F$CONTEXT
   function.

   If the context symbol is undefined or equated to a null string,
   the F$PID function returns the first PID in the system's process
   list that it has the privilege to access. That is, if you have
   GROUP privilege and if the context symbol is null or undefined,
   the F$PID function returns the PID of the first process in your
   group. If you have WORLD privilege, the F$PID function returns
   the PID of the first process in the list. If you have neither
   GROUP nor WORLD privilege, the F$PID returns the first process
   that you own. Subsequent calls to F$PID return the rest of the
   processes on the system you are accessing.

   If the context symbol has been created by the F$CONTEXT function,
   the F$PID function returns the first process name in the
   system's process list that fits the criteria specified in the
   F$CONTEXT calls. Subsequent calls to F$PID return only the PIDs
   of those processes that meet the selection criteria set up by
   the F$CONTEXT function and that are accessible to your current
   privileges.
 

</pre>
<a name="559">
<h3 Align=center><a href="dix_help_idx_5.html#545" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$PID Example </a> </h3>
<pre>

  CONTEXT = ""
  START:
      PID = F$PID(CONTEXT)
      IF PID .EQS. "" THEN EXIT
      SHOW SYMBOL PID
      GOTO START

     This command procedure uses the F$PID function to display a
     list of PIDs. The assignment statement declares the symbol
     CONTEXT, which is used as the context-symbol argument for the
     F$PID function. Because CONTEXT is equated to a null string,
     the F$PID function returns the first PID in the process list
     that it has the privilege to access.

     The PIDs displayed by this command procedure depend on the
     privilege of your process. When run with GROUP privilege, the
     PIDs of users in your group are displayed. When run with WORLD
     privilege, the PIDs of all users on the system are displayed.
     Without GROUP or WORLD privilege, only those processes that you
     own are displayed.
 
</pre>
<a name="560">
<h3 Align=center><a href="dix_help_idx_4.html#384" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$PRIVILEGE </a> </h3>
<pre>
  
   logical=F$PRIVILEGE(priv_status)
 
   Returns a string value of either TRUE or FALSE, depending on
   whether your current process privileges match those specified
   in the argument. You can specify either the positive or negative
   version of a privilege.

   DIX&GT; SAY F$PRIVILEGE("OPER,GROUP,TMPMBX,NONETMBX")
   False

     The F$PRIVILEGE function is used to test whether the process
     has OPER, GROUP, and TMPMBX privileges and not NETMBX privileges.

</pre>
<a name="561">
<h3 Align=center><a href="dix_help_idx_4.html#385" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$RAD50 </a> </h3>
<pre>

   Convert text to rad50 numbers and vice versa

   ival = f$rad50(text) or text = f$rad50(number)

   If argument is text (case 1) ival will be a rad50 number (0..63999)
    If the length of text is &GT;3, ival will be a table of rad50 numbers
    each containing 3 characters. If the stringlength is not a mulitple 
    of 3, the string is padded with spaces.

   If argument is a (table of) number(s) or rad50's, these numbers 
    will be converted to the original text (always padded with blanks
    to a multiple of 3 characters).

   Examples

    DIX&GT;say f$rad50("AB")       !string with length &LT;=3
    1680                        !returns a single number
    DIX&GT;say f$rad50(1680),":"   !and back to the source
    AB :                        !string length is 3

    DIX&GT;say f$rad50("ABCD")          !string length &GT;3, will return
    [1683,6400]                      !a table of numbers
    DIX&GT;say f$rad50([1683,6400]),":" !and back
    ABCD  :                          !string length is 6


</pre>
<a name="562">
<h3 Align=center><a href="dix_help_idx_4.html#386" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$RADIX </a> </h3>
<pre>
  
  F$RADIX(value,radix[,separator])

  Convert an integer value to any radix

  Argument value    : integer
           radix    : integer
           separator: the string to insert between the "digits", default is .
           Result   : string

  If separator is not specified (or is blank) 
    If radix &LT;=36, each "digit can be 0..9,a..z
    if radix  &GT;36  each "digit" will be expressed as decimal numbers 
                       separated by "separator"

  If radix is specified &LT;&GT; " " then
    All "digits" will be expressed as decimal numbers separated by "separator"


  Example 
  f$radix(33,16) will deliver "21"
  f$radix(37,37) will deliver "1.0"

  f$radix(33,16,".") will deliver "2.1"
  f$radix(37,37,"|") will deliver "1|0"

</pre>
<a name="563">
<h3 Align=center><a href="dix_help_idx_4.html#387" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$RANDOM </a> </h3>
<pre>
   F$RANDOM([argument])
   Return a random number

   Argument : integer : Return an integer value 0..argument-1
              Real    : Return a real value 0&LT;=result&LT;argument
   If argument is not specified it is defaulted as 1.0

</pre>
<a name="564">
<h3 Align=center><a href="dix_help_idx_4.html#388" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$REAL </a> </h3>
<pre>

  F$REAL is an alias for the function REAL

</pre>
<a name="565">
<h3 Align=center><a href="dix_help_idx_4.html#389" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$READ </a> </h3>
<pre>
    F$READ(file[,beginrec][,endrec][,separation][,how][,csvchar])
 
   Read all (or a subset of the records of file 'file' into a table
   Input
    file     : char: The name of a file handle or a filename
    beginrec : int : The starting record, default is the current (or the first)
    endrec   : int : The ending record, default is the last
                     If either recnr is negative , it will be counted
                     from EOF backward (so -2 is the one but last record)
 
    You may want to split the read lines like in the F$SPLIT function
       for more info see the F$SPLIT function help

    Separation : Separation char/table
    how        : how to align fields 
    csvchar    : character to use in csv file (deault=,)

   Output : A table of character elements. If separation or how
            is specified the result is a two-dimensional table.
  
   If file is the name of a file handle, the current file record will be
    restored

  example : If you want all usernames from sysuaf:

  DIX&GT; users= f$read("SYSUAF",,,[-4,12],"COMPRESS")  
        Read sysuaf (all records)
        Skip the first 4 bytes and take the next 12
        Will deliver a table of (compressed) usernames

</pre>
<a name="566">
<h3 Align=center><a href="dix_help_idx_4.html#390" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$REPLACE </a> </h3>
<pre>

   result=f$replace(input,search,[replace],[count],[case],[wildflag])

   input  : character (may be table)
   search : character (may be table), the string to be found
   replace: character (may be table), the string to replace search
             may be empty or not specified
   count  : The number of replacements in each element of input
             default is all occurrences of search. 
             If count is negative, the last -count are replaced
   case   : case_sens or nocase_sens : is the seach case sensitive
             default case_sensitive            
   wildflag: STANDARD or EXTENDED . Determines how search string is found

   If search is a table (of string), replace must be
    1. A single value: all search strings are replaced by replace
    2. A table, the number of strings must be the same as search
    3. not present , all search strings are removed

  Examples
   DIX&GT; say f$replace("XYZXYZ XYZ","X","x")  	      !replace X by x
   xYZxYZ xYZ
   DIX&GT; say f$replace("XYZXYZ XYZ",["X","Y"],"x")     !Replace X and Y by x
   xxZxxZ xxZ
   DIX&GT; say f$replace("XYZXYZ XYZ",["X","Y"],["x","y"])  !replace X by x
                                                         !and Y by y
   xyZxyZ xyZ
   DIX&GT; say f$replace("XYZXYZ XYZ",["X","Y"])          !replace X and Y by nothing
   ZZ Z
   DIX&GT; say f$replace("XYZXYZ XYZ","x")               !replace X by nothing
   XYZXYZ XYZ				              !nothing happens , case_sens
   DIX&GT; say f$replace("XYZXYZ XYZ","x",,,"NOCASE")    !replace X by nothing
   YZYZ YZ                                            !all X are removed
   DIX&GT; say f$replace("XYZXYZ XYZ","X","x",2)  	      !replace X by x , 
                                                      !only the first 2
   xYZxYZ XYZ

   DIX&GT; say  f$replace("axbx1111xc","*x","y",,,"STAND") !*x is used as a wildcard
   yyyc       !ax is replaced by y, and then bx by y, and then 1111x by y

  search and replace may be tables:
    
</pre>
<a name="567">
<h3 Align=center><a href="dix_help_idx_4.html#391" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$REVERSE </a> </h3>
<pre>

   outputval=F$REVERSE(inputval)

   Reverse the order of all bytes of the arguments. This may be used
   for little/bigendian conversion (see also the F$HTONS function)

   DIX&GT; SAY/HEX F$REVERSE('01020304'X) 
   04030201
   DIX&GT; SAY/HEX F$REVERSE("ABCD") 
   DCBA   
</pre>
<a name="568">
<h3 Align=center><a href="dix_help_idx_4.html#392" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$RFA </a> </h3>
<pre>

   rfa=F$RFA(integer)

  COnvert an integer (byteoffset) to an RFA (blocknumber,byteoffset)

   DIX&GT;say f$rfa(518)   !conver byteoffset 518
   (2,6)                !block 2, byte offset (in block) 6
 
</pre>
<a name="569">
<h3 Align=center><a href="dix_help_idx_4.html#393" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$RIGHT </a> </h3>
<pre>
  F$RIGHT(STRING) : Result is a right justified string

  Argument and result are character

</pre>
<a name="570">
<h3 Align=center><a href="dix_help_idx_4.html#394" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$SEARCH </a> </h3>
<pre>

   result = F$SEARCH(mask[,context][,defaultfile],[relatedname],[flags])

   mask is a (wildcard) specification of the file(s) to be searched.
    Mask can also be specified as libmask(modmask) or modmask(libmask) to
    search modules in libraries

   If flags is present if must be 
     1. A character string containing one ore more tokens
            a. ALL 
            b. NOWILD   | Signal error if a wildcard is present
            c. MULTIPLE | perform temp defaulting, see help on lib$find_file
            d. LONG     | Return long filenames (not on vax)
     2. A logical

    If flags is true or contains "ALL" dix will return one value
     containing a table of all files found. In this case context is ignored.
    
   In normal mode : context is the name of a symbol (must not exist)
                            or not present (the default symbol)
   In DCL mode    : context is an integer (or not present)

  Like the DCL f$search, but with a default/related file and flags

   example
 
   lp:res = f$search("*.exe",test)     ! or ("*.exe",1) in dcl mode
      if (res &LT;&GT; "")
       then
        say res
        goto lp
       endif

   The symbol test saves the context. If you want to delete this symbol
   specify x=f$search(,test)

   If no more files can be found, DIX will automatically delete test.  

 Example in ALL mode

   DIX&GT;result = F$SEARCH("*.EXE",,,true)
   DIX&GT;show symb/fu result
   RESULT(Character,Level=1.0)=table(3)
   DIX&GT;sh symb/all result
   RESULT(1)="USER50:[STUBBF.PROGRAMS.DIX]DIX_ALPHA.EXE;2504"
   RESULT(2)="USER50:[STUBBF.PROGRAMS.DIX]DIX_IA64.EXE;21"
   RESULT(3)="USER50:[STUBBF.PROGRAMS.DIX]DIX_VAX.EXE;69"
   DIX&GT;;FOR NAM IN RESULT; say nam ; end for
   USER50:[STUBBF.PROGRAMS.DIX]DIX_ALPHA.EXE;2504
   USER50:[STUBBF.PROGRAMS.DIX]DIX_IA64.EXE;21
   USER50:[STUBBF.PROGRAMS.DIX]DIX_VAX.EXE;69
   DIX&GT;
 
  Example for library support
  DIX&GT;s= f$sear("starlet(*uai*)",,,,"ALL")
  DIX&GT;sh symb/all s
  S(1)="SYS$COMMON:[SYSLIB]STARLET.MLB;1($GETUAI)"
  S(2)="SYS$COMMON:[SYSLIB]STARLET.MLB;1($GETUAIDEF)"
  S(3)="SYS$COMMON:[SYSLIB]STARLET.MLB;1($GETUAI_G)"
  S(4)="SYS$COMMON:[SYSLIB]STARLET.MLB;1($GETUAI_S)"
  S(5)="SYS$COMMON:[SYSLIB]STARLET.MLB;1($SETUAI)"
  S(6)="SYS$COMMON:[SYSLIB]STARLET.MLB;1($SETUAIDEF)"
  S(7)="SYS$COMMON:[SYSLIB]STARLET.MLB;1($SETUAI_G)"
  S(8)="SYS$COMMON:[SYSLIB]STARLET.MLB;1($SETUAI_S)"
  S(9)="SYS$COMMON:[SYSLIB]STARLET.MLB;1($UAIDEF)"


  DIX&GT;s= f$sear("*uaid*@starlet",,,,"ALL")	!and the ohter syntax
  DIX&GT;sh symb/all s
  S(1)="$GETUAIDEF@SYS$COMMON:[SYSLIB]STARLET.MLB;1"
  S(2)="$SETUAIDEF@SYS$COMMON:[SYSLIB]STARLET.MLB;1"
  S(3)="$UAIDEF@SYS$COMMON:[SYSLIB]STARLET.MLB;1"


</pre>
<a name="571">
<h3 Align=center><a href="dix_help_idx_4.html#395" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$SETPRV </a> </h3>
<pre>

   old=f$setprv(newprivs)

   Newprivs : string containing the privs names
              expression of type privilege

   Old : Old privileges of type "privilege"
</pre>
<a name="572">
<h3 Align=center><a href="dix_help_idx_4.html#396" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$SORT </a> </h3>
<pre>

   F$SORT(TABLE[,index],direction)

   Sort a table in memory, return a table of the same size

  Input : table : a table of elements, can have any type
          Index : The element to sort on (for a multidimensional table
                   Index must have any dimension less than the table itself
          Direction: char: Either Reverse or forward (default)

  Ouput : A table of the same size and type as 'table' sorted on the 
            required field in the required direction

  Examples:

  DIX&GT;say f$sort([[3,1][2,2][1,3]]) 	!sort on index 1
  [[1,3][2,2][3,1]]
  DIX&GT;say f$sort([[3,1][2,2][1,3]],2)   !sort on index 2
  [[3,1][2,2][1,3]]
  DIX&GT;say f$sort([[3,1][2,2][1,3]],1,"REV") 	!sort on index 1 (reversed)
  [[3,1][2,2][1,3]]

    
</pre>
<a name="573">
<h3 Align=center><a href="dix_help_idx_4.html#397" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$SPLIT </a> </h3>
<pre>
  
  result =  F$SPLIT(line[,separator],[option],[csvchar])

   Split a character line in substrings separated by
   Arguments

    Line : A (table of) character strings

    Separator:
     If separator is not present or contains "WHITESPACE" or is empty
                                       : whitespace (one ore more space/tab)
     If separator contains "CSV"        : Csv file with csvchar as separator 
                                         (default ,)
     If separator is present(type char) : if the length=1 : use
                                         separator as a split-character
     If separator is an integer, the line is split in 'value' size fields
     If separator is a table of integers , line is split in 'table' size fields
                  negative values are used to define fields that will not be
                  included in the result (see example)
    Option: A string
      LEFT     : Left justify the string
      RIGHT    : Right justify the string
      COMPRESS : Remove leading and trailing blanks
      KEEP     : Just leave it
     The default for option is
       COMPRESS is default for whitespace 
       KEEP     is default for all other cases.     

    csvchar: A string of 1 or 2 characters, only used if separator contains CSV 
     first character  : the character to delimit the csv fields, default is ,
     second chatacter : the string terminator , default is "


  Examples
    DIX&GT;say/quoted f$split(" a   b     c  ")	!split by whitespace
    ["a","b","c"]

    DIX&GT;say/quoted f$split("a,b,c",",")         !split by ,
    ["a","b","c"]

    DIX&GT;say/quoted f$split("1234567890",4)      !split in 4 char parts
    ["1234","5678","90"]

    DIX&GT;say/quoted f$split("1234567890",[4,2,4])  !split in 4,2,4 char parts
    ["1234","56","7890"]

    DIX&GT;say/quoted f$split("1234567890",[4,-2,4])  !split in 4,-2,4 char parts
    ["1234","7890"]                         !but do not include the second field


    DIX&GT;say/quoted f$split("12  56  90",[4,2,4])
    ["12  ","56","  90"]

    DIX&GT;say/quoted f$split("12  56  90",[4,2,4],"C")	
    ["12","56","90"]               !remove lead/trail spaces

    DIX&GT;say/quoted f$split("12  56  90",[4,2,4],"L")
    ["12  ","56","90"]             !remove lead spaces

    DIX&GT;say/quoted f$split("12  56  90",[4,2,4],"R")
    ["12","56","  90"]             !remove trail spaces
        
    DIX&GT;say/quo f$split("|ab|;4;|cd|","CSV",,";|")
    ["ab","4","cd"]

    DIX&GT; 
</pre>
<a name="574">
<h3 Align=center><a href="dix_help_idx_4.html#398" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$STRING </a> </h3>
<pre>

   value=F$STRING(anyvalue)

  Convert any type to a string

</pre>
<a name="575">
<h3 Align=center><a href="dix_help_idx_4.html#399" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$SUBTRACT </a> </h3>
<pre>
    F$SUBTRACT(str1,str2[,width])

   Str1 and str may be integer, real, string, decimal values, result is a string

  F$SUB will subtract str2 from str1 and return the result
  If width is not specified, the result will be as long as needed
  If width &GT;0, the result will be blank filled in a string of length 'width' 
  If width &LT;0, the result will be zero filled in a string of length 'width' 
  If width&LT;&GT;0 and the result does not match, result will be a string
    of 'width' *

  Example
   SAY F$SUB("123","345")    Returns "-222"
       F$SUB("123","345",6)  Returns "  -222"
       F$SUB("123","345",-6) Returns "-00222"
       F$SUB("123","345",2)  Returns "**"
       F$SUB(1,12.3)         Returns "-11.3"


</pre>
<a name="576">
<h3 Align=center><a href="dix_help_idx_4.html#400" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$SUM </a> </h3>
<pre>

   F$SUM(table)

    Return the sum of all elements
    table can be a table of int or a table of real
    result has the same type as table


</pre>
<a name="577">
<h3 Align=center><a href="dix_help_idx_4.html#401" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$SYMBOL </a> </h3>
<pre>

  F$SYMBOL(name,what,[dimidx])

  Return info about a fieldname

  Name can be specified with or without quotes, but if name contains
  dimensions, name must be enclosed in quotes

  what can be
  EXISTS    : Return true or false whether the fieldname exists
  SIZE      : Returns the size (IN BITS) of the field
  TYPE      : The type of the field
  NDIM      : Number of dimensions 

  For the next two items, a 3rd parameter can be used (the dimension index)
  F$FIELD(fieldname,what,dimidx)
 
  LOWDIM    : the low value for dimension 'dimidx'
  HIGHDIM   : The high value for dimension 'dimidx'
  INCREMENT : The increment value for dimension 'dimidx'

</pre>
<a name="578">
<h3 Align=center><a href="dix_help_idx_4.html#402" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$TABLE </a> </h3>
<pre>
    Value=f$table([TYPE],[bpos],[epos],[file])

   Return a one-dimensional table containing the element of the data record

   type : Char: the value BYTE (Default), WORD, LONGWORD
          Int : May also be specified as integer with value 1, 2 or 4
   bpos : int : starting position (default 0)
   epos : int : end position (default reclen-1)
   file : char: the file, default the current

   If bpos or epos are negative, the value  is considered to be relative
   to the end of the record, so f$table(,,-2) means the bytes 1..reclen-2
   (since we start at 0, the -1 is needed)

</pre>
<a name="579">
<h3 Align=center><a href="dix_help_idx_4.html#403" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$TIME </a> </h3>
<pre>

  The argument selects the part of the date/time to select.
  Syntax
   F$TIME([what[,time])

  Time can be either a string containing a valid OpenVMS date-time 
  or a date type symbol. It time is not specified, the current date/time
  is used.

  Return value is character for

  F$TIME()           Date/time
  F$TIME("DATE")     The date
  F$TIME("TIME")     The time
  F$TIME("MONTHASC") The name of the month

  Return value is integer for
  F$TIME("YEAR")           The year
  F$TIME("MONTH")          The month 
  F$TIME("DAY")            The day
  F$TIME("HOUR")           The hour
  F$TIME("MINUTE")         The minute
  F$TIME("SECOND")         The seconds
  F$TIME("HUNDREDTH")      The hundredth

  F$TIME("MONTHOFYEAR")    Month of the year
  F$TIME("DAYOFYEAR")      Day of the year
  F$TIME("HOUROFYEAR")     Hour of the year
  F$TIME("MINUTEOFYEAR")   Minute of the year
  F$TIME("SECONDOFYEAR")   Second of the year

  F$TIME("DAYOFMONTH")     Day of the month
  F$TIME("HOUROFMONTH")    Hour of the month
  F$TIME("MINUTEOFMONTH")  Minute of the month
  F$TIME("SECONDOFMONTH")  Second of the month

  F$TIME("DAYOFWEEK")      Day of the week
  F$TIME("HOUROFWEEK")     Hour of the week
  F$TIME("MINUTEOFWEEK")   Minute of the week
  F$TIME("SECONDOFWEEK")   Second of the week
  
  F$TIME("HOUROFDAY")      Hour of the day
  F$TIME("MINUTEOFDAY)     Minute of the day
  F$TIME("SECONDOFDAY")    Second of the day
  
  F$TIME("MINUTEOFHOUR)    Minute of the hour
  F$TIME("SECONDOFHOUR")   Second of the hour
  
  F$TIME("SECONDOFMINUTE") Second of the minute
  F$TIME("JULIANDATE")     The Julian date
 
  F$TIME("DELTAWEEKS")     Delta weeks
  F$TIME("DELTADAYS")      Delta days
  F$TIME("DELTAHOURS")     Delta hours
  F$TIME("DELTAMINUTES")   Delta minutes
  F$TIME("DELTASECONDS")   Delta seconds

</pre>
<a name="580">
<h3 Align=center><a href="dix_help_idx_4.html#404" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$TRANSLATE </a> </h3>
<pre>

    F$TRANSLATE(source,translation,match)

 All inputs are character strings
 The result is a character string

  Translate all chars in source that are found in match to the 
  corresponding char in translate. If translate is shorted than
  match, spaces are used. See the help about STR$TRANSLATE

  Example
  
   DIX&GT;say f$trans("kdjfkjasd","b","ak")
    djf jbsd
 
   All a's are replaced by "b"
   All k's are replaced by SPACE (since translate is shorted than match

</pre>
<a name="581">
<h3 Align=center><a href="dix_help_idx_4.html#405" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$TRIM </a> </h3>
<pre>
  F$TRIM(string) will remove all trailing blanks
  Argument and result are character
  
</pre>
<a name="582">
<h3 Align=center><a href="dix_help_idx_4.html#406" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$TRNLNM </a> </h3>
<pre>
   Translates a logical name and returns the equivalence name string
   or the requested attributes of the logical name specified.
   Format

     F$TRNLNM(logical-name [,table] [,index] [,mode] [,case] [,item])
   See the DCL help about this function


</pre>
<a name="583">
<h3 Align=center><a href="dix_help_idx_4.html#407" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$TYPE </a> </h3>
<pre>
  F$TYPE(name)

  Deliver the symbol type of an existing symbol

    (integer/real/character/logical/decimal/date)

  This statement looks like the DCL F$TYPE, but it's argument may also be
  a string between quotes.

</pre>
<a name="584">
<h3 Align=center><a href="dix_help_idx_4.html#408" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$UPCASE </a> </h3>
<pre>

  F$UPCASE(STRING)  Result is a string with all letters (a-z) upcased.

  argument and result is character
   
</pre>
<a name="585">
<h3 Align=center><a href="dix_help_idx_4.html#409" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$USER </a> </h3>
<pre>
   F$USER() Result is a string with the uic converted to ascii
 
    DIX&GT; say f$user()
    [BEHGROUP,STUBBF]
    DIX&GT;


</pre>
<a name="586">
<h3 Align=center><a href="dix_help_idx_4.html#410" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$VECTIM </a> </h3>
<pre>
  
  Convert an integer to a date (like the LIB$CVT_VECTIM)
 
  F$VECTIM(table)                   Use a table of 7 words for all the 
                                    fields (see the F$NUMTIM)
  F$VECTIM([year],[month],[day]...) Specify each field as integer
                                    The default is today 00:00:00.00

  examples

  DIX&GT; A=F$NUMTIM(#DATE"1-JAN-2008")
  DIX&GT; SAY F$VECTIM(A)		!format 1, use a 7 word integer table
  DIX&GT; SHOW SYMB/FULL a
  A(Integer*4,Level=1.0)= table(7)


  DIX&GT; sh time                  !format 2 , specify normal integers
   2-APR-2008 16:18:18.02       !the default will be 2-APR-2008 00:00:00.00
  DIX&GT;say f$vectim(,,30)	!replace the day
  30-APR-2008 00:00:00.00
  DIX&GT; say f$vectim(,2,)        !replace the month
   2-FEB-2008 00:00:00.00
  DIX&GT; say f$vectim(2010,,1)    !replace year and day
  1-APR-2010 00:00:00.00





</pre>
<a name="587">
<h3 Align=center><a href="dix_help_idx_4.html#411" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS F$VERIFY </a> </h3>
<pre>
  F$VERIFY([new_setting])

  Change the verify setting and return the old value (like DCL)
  
  New_setting : Integer  or logical the new setting
                If new_setting is not specified, the VERIFY 
                setting is not changed
  Returns     : Logical the old setting

  Example

  old_setting = f$verify(true)
  ....
  ....  Statements with verify on
  ....
  k = f$verify(old_setting)

 
</pre>
<a name="588">
<h3 Align=center><a href="dix_help_idx_4.html#412" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS %BLOC </a> </h3>
<pre>
  
  %BLOC("fieldname"[,"where"])  
  Gives the offset of a field in the datarecord in bits.
  Where can be
   NORMAL : Look in the normal data
   VFC    : Look inn the VFC data
   BOTH   : Look in both (default)

  
  Example
  des record for sysuaf
    ...
    ...
    integer*2 uaf$w_logfails
    ...
  end record  
   %BLOC("UAF$W_LOGFAILS") will return 2848 (8*356)
 
</pre>
<a name="589">
<h3 Align=center><a href="dix_help_idx_4.html#413" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS %DATA </a> </h3>
<pre>
   %DATA([where],[tag])
 
   Returns a string value containing the current record.
   This value can be saved in a symbol to perform a CUT/PASTE
   function. 
   Arguments
     where : char  the part of the file DATA, SAVE, VFC, VIEW
     tag   : char  the tag of the file. Default is the current file

   Example
 
   DIX&GT;a = %DATA()	 !Save the current record contents
   DIX&GT;.. modify record  !do a log modifications
   DIX&GT;PASTE/SYMBOL=a    !Returns the record to its previous state

</pre>
<a name="590">
<h3 Align=center><a href="dix_help_idx_4.html#414" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS %EOF </a> </h3>
<pre>

   %EOF([tag])

   Return true if file is at End_of_file. Tag is default the current file.
  
   DIX&GT; open tag sysuaf
   DIX&GT; while not %eof()     Or %eof("TAG")
   DIX&GT; say uaf$t_username
   DIX&GT; next rec
   DIX&GT; end while

</pre>
<a name="591">
<h3 Align=center><a href="dix_help_idx_4.html#415" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS %LOC/%BLOC </a> </h3>
<pre>
  
  %LOC("fieldnamemask"[,"where"])  
  Gives the offset of a field in the datarecord in bytes.

  %BLOC does the same, but now returns the value in bits, this may be needed
        for fields in bitmode. 

  Where can be
   NORMAL : Look in the normal data
   VFC    : Look inn the VFC data
   BOTH   : Look in both (default)

  
  Example
  des record for sysuaf
    ...
    ...
    integer*2 uaf$w_logfails
    ...
  end record  
   %LOC("UAF$W_LOGFAILS")  will return 356
   %BLOC("UAF$W_LOGFAILS") will return 2848

</pre>
<a name="592">
<h3 Align=center><a href="dix_help_idx_4.html#416" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS %RECORDNUMBER </a> </h3>
<pre>
  
  %RECORDNUMBER([tag])

  Return the current record number of a file

  tag is the optional filetag, default is the current file
 
  The recordnumber is unknown after a keyed read, DIX will return a -1.
 
</pre>
<a name="593">
<h3 Align=center><a href="dix_help_idx_4.html#417" target="index">DIX INTERACTIVE_COMMANDS FUNCTIONS %RECORDSIZE </a> </h3>
<pre>
  
  %RECORDSIZE([what],[tag])
 
  Return the recordsize of the data in what
  If what is
    "DATA"  Databuffer
    "SAVE"  Save buffer
    "VFC"   VFC buffer
    "VIEW"  View buffer

    Default is databuffer if the file has no views
            or view_buffer if the file has views
  tag is the optional filetag, default is the current file

</pre>
<a name="594">
<h3 Align=center><a href="dix_help_idx_3.html#166" target="index">DIX INTERACTIVE_COMMANDS GOMARK </a> </h3>
<pre>
 
  GOMARK markname

  Return to a previous mark set by MARK.

</pre>
<a name="595">
<h3 Align=center><a href="dix_help_idx_3.html#167" target="index">DIX INTERACTIVE_COMMANDS GREP </a> </h3>
<pre>
  
    GREP[/qualifiers] MASK "command"
  Execute command and display only those lines that match 'mask'

  Qualifier can be 
   /WILDCARD=value
     This qualifier decides how 'mask' should match the output line
     /WILDCARD=none     
     /WILDCARD=standard
     /WILDCARD=extended
     If you only specify /wildcard, the /wild=standard is default
     If you do not specify /wildcard, 'mask' must occur in the line

   /REVERSE           Print only the line that do not match 'mask'

   /HIGHLIGHT=(flag[,flag...)
   /CASE_SENSITIVE    'mask' is matched in a case sensitive way
 

   The /highlight flags are used only when /wildcard=none and can be 
     BLINK
     UNDERLINE
     BOLD
     REVERSE
  

  This is a one line "set output_filter" command

 Examples
  Suppose we have a sysuaf record present
  DIX&GT;grep acco examine                !display lines that have acco 
  52.0 |UAF$T_ACCOUNT     |AP_HTTPD    !in them
  576.0|UAF$W_ACCOUNT_LIM |0
  578.0|UAF$W_ACCOUNTS    |0

  DIX&GT; grep *user* examine             !display lines that have *user* in them
                                       !no match
  DIX&GT; grep/wild *user* examine        !display lines that match *user* 
  4.0|UAF$T_USERNAME      |APACHE$WWW  !this matches

</pre>
<a name="596">
<h3 Align=center><a href="dix_help_idx_3.html#168" target="index">DIX INTERACTIVE_COMMANDS HELP </a> </h3>
<pre>

  HELP[/QUALIFIERS] [HELPTOPIC[/QUALIFIERS] [HELPTOPIC..]]

  Display help, you are doing it now.
   This will the commands available in interactive mode.

  The following qualifiers are supported with the HELP command

   /TOP   Display help about all DIX functionality , not
           just the interactive commands.
   /DCL   Display the contents of SYS$HELP:HELPLIB.HLB
           instead of the DIX help library.
   /DECW  Display the help in  a decwindow window. 
           This requires the availability of DECWINDOWS 
           and a freeware package FSHELP (see below) 

  DIX will use the LBR$OUTPUT_HELP routine. If you also have the 
  FSHELP freeware package installed (available on the same website), 
  DIX will use the FSHELP_SHR inclusive a DECWINDINDOWS interface.


</pre>
<a name="597">
<h3 Align=center><a href="dix_help_idx_3.html#169" target="index">DIX INTERACTIVE_COMMANDS IF </a> </h3>
<pre>
  Syntax
  The IF command is present in the following formats

  1. IF logical_expression command
        If the expression evaluates to true, execute command.
  2. IF logical expression THEN command
        If the expression evaluates to true, execute command.
  3. IF logical expression THEN
     [ELSE] [command]
     ENDIF
       If the expression evaluates to true, execute the IF part
       else execute the (optional) ELSE part
  4. IF logical expression 
     THEN   [command]
     [ELSE] [command]
     ENDIF
       If the expression evaluates to true, execute the IF part
       else execute the (optional) ELSE part

  If you type the command format 3 or 4  from the terminal 
  (instead from a command file) DIX will prompt you for more lines 
  until the ENDIF command is found, and then will execute the commands.
 

  See the help about [DIX/help] interact expressions
![DIX inter expression]help about expressions
  See also the help about the LEAVE command


</pre>
<a name="598">
<h3 Align=center><a href="dix_help_idx_3.html#170" target="index">DIX INTERACTIVE_COMMANDS INQUIRE </a> </h3>
<pre>
  INQUIRE symbol [prompt] [qualifiers]

   Read a value from the terminal, and assign it to the symbol.
   The value of the expression determines the type of the symbol.

   Prompt is the (optional) prompt string, default "Data"

   Qualifiers can be
   /[NO]PUNCTUATION (default) : add a ": " to the prompt string. 

   /EXPRESSION : the input will be evaluated as an expression
                 Default the input will be returned as a string
      
</pre>
<a name="599">
<h3 Align=center><a href="dix_help_idx_3.html#171" target="index">DIX INTERACTIVE_COMMANDS INTEGER-UINTEGER </a> </h3>
<pre>
   INTEGER[*size] [/type=enum_type][/level=n][/global] name[dimensions][=value]
   UINTEGER[*size] [/type=enum_type][/level=n][/global] name[dimensions][=value]

   Declare a new symbol of type "[U]INTEGER" and optionally give a value.
   The value must be of type "integer"
   See the help about [dix/int] interact declaration for the enum_type

   If size is specified (in the format bytes[.bits]), the symbol is 
    limited to this size, the default size=4[.0]

  Example
   INTEGER  counter=10
  See the help about  [DIX/help] interactive declaration

   DIX&GT; INTEGER*0.4 count    !declare a 4 bits integer. 
                             !It can only have values 7..-8
                             !an uinteger*0.4 may have values 0..15
   DIX&GT; count=7              !this fits
   DIX&GT; count=17             !this does not fit
   %DIX-E-TOOBIG, Data   does not fit in 4 bits(signed)

   

</pre>
<a name="600">
<h3 Align=center><a href="dix_help_idx_3.html#172" target="index">DIX INTERACTIVE_COMMANDS LEAVE </a> </h3>
<pre>
  
  Leave the current block (IF,FOR,REPEAT, WHILE) and
  start with the statement just after this block.
  The LEAVE command can only be executed within a block.

</pre>
<a name="601">
<h3 Align=center><a href="dix_help_idx_3.html#173" target="index">DIX INTERACTIVE_COMMANDS LIBRARY </a> </h3>
<pre>

  LIBRARY/LIST[=filename]/[/ONLY=(mask[,mask...])]  [libnam] List topics
  LIBRARY/EXTRACT[=(modname[,modname...])]  [libnam]         Extract topic

  The libraryname can either be specified in the libnam parameter (p1)
  or via the qualifiers. 
  /MACRO   Libraryname = SYS$LIBRARY:STARLET.MLB 
  /OBJECT  Libraryname = SYS$LIBRARY:IMAGELIB.OLB 
  /TEXT    Libraryname = SYS$LIBRARY:SYS$STARLET_C.TLB
  /HELP    Libraryname = SYS$HELP:HELPLIB.HLB

</pre>
<a name="602">
<h3 Align=center><a href="dix_help_idx_4.html#426" target="index">DIX INTERACTIVE_COMMANDS LIBRARY Qualifiers </a> </h3>
<pre>
</pre>
<a name="603">
<h3 Align=center><a href="dix_help_idx_5.html#589" target="index">DIX INTERACTIVE_COMMANDS LIBRARY Qualifiers /date </a> </h3>
<pre>

  For the /LIST only. 
 
  Print the insertion date after the name.
</pre>
<a name="604">
<h3 Align=center><a href="dix_help_idx_5.html#590" target="index">DIX INTERACTIVE_COMMANDS LIBRARY Qualifiers /size </a> </h3>
<pre>

  /SIZE
  /SIZE=bytes
  For the /LIST only. 
 
  Print the module size after the name.
  If /SIZE=bytes printy eht size in bytes, els in blocks

</pre>
<a name="605">
<h3 Align=center><a href="dix_help_idx_5.html#591" target="index">DIX INTERACTIVE_COMMANDS LIBRARY Qualifiers /full </a> </h3>
<pre>

  For the /LIST only. 
  Print the size and insertion date after the name
  If you want the size in bytes, add the /size=bytes
</pre>
<a name="606">
<h3 Align=center><a href="dix_help_idx_5.html#592" target="index">DIX INTERACTIVE_COMMANDS LIBRARY Qualifiers /output </a> </h3>
<pre>

  /output=filename
  /output=sys$output (default)

  Redirect the output to file 'filename'
  If you have and .OLB library, this qualifier should be present.

</pre>
<a name="607">
<h3 Align=center><a href="dix_help_idx_5.html#593" target="index">DIX INTERACTIVE_COMMANDS LIBRARY Qualifiers /header </a> </h3>
<pre>

 If you specify the /header, DIX will add extra info to the output
 For the /list command extra info about the library itself will be printed
   (like the DCL library/list) and a total count.
 For the /extract each module will be preceeded by a line taht contains 
   the modulename, and a total count.

</pre>
<a name="608">
<h3 Align=center><a href="dix_help_idx_5.html#594" target="index">DIX INTERACTIVE_COMMANDS LIBRARY Qualifiers /paged </a> </h3>
<pre>

  If output to screen, do it by page

</pre>
<a name="609">
<h3 Align=center><a href="dix_help_idx_5.html#595" target="index">DIX INTERACTIVE_COMMANDS LIBRARY Qualifiers /screen </a> </h3>
<pre>

  Display the data in screen mode

</pre>
<a name="610">
<h3 Align=center><a href="dix_help_idx_5.html#596" target="index">DIX INTERACTIVE_COMMANDS LIBRARY Qualifiers /width </a> </h3>
<pre>

 Set the wisth of the output. Default the size of the terminal (sys$output)
  or 80.
</pre>
<a name="611">
<h3 Align=center><a href="dix_help_idx_3.html#174" target="index">DIX INTERACTIVE_COMMANDS LOAD </a> </h3>
<pre>

   LOAD filename [/log]
   LOAD library /module=modulename [/log]

   LOAD/MESSAGE [leadin]
   LOAD/FUNCTION filename[/module=name]
   LOAD/DESCRIPTION description[/log]
   LOAD/STRUCTURE description[/log]

  If no qualifier is specified (or only the /module)

   
    Load all parameter definitions from a file or a module in a .tlb/.mlb 
    file. DIX recognises 3 formats in the file or module

     a. The fortran type : PARAMETER name=value
     b. the macro type   : $EQU name value
     c. The C type       : #define name value

   Filename may also be specified as
    module@[library] or as [library](module)
    In this case do not specify the /module qualifier

    The default for the filename is :
                     [].txt
    The default for the library is :
           first try using a default file 
              SYS$LIBRARY:STARLET.MLB and 
           then try using a default file 
              SYS$LIBRARY:FORSYSDEF.TLB
  
    Example
    DIX&GT; LOAD FORSYSDEF/MODULE=$SYIDEF     !load all (fortran) defs from SYIDEF
    DIX&GT; LOAD SYS$STARLET_C/MODULE=$ACCDEF !the same from the C def's file
    DIX&GT; Load mydefs                       !load the file mydefs.txt
    DIX&GT; load /module=$SYIDEF              !load from STARLET.MLB

    /LOG will report the number of symbols loaded from each module
    /LOG=FULL will report all symbols loaded

</pre>
<a name="612">
<h3 Align=center><a href="dix_help_idx_4.html#428" target="index">DIX INTERACTIVE_COMMANDS LOAD LOAD_MESSAGE </a> </h3>
<pre>

   LOAD/MESSAGE [leadin]

   If the /message is given, DIX will create parameters for
   all the dix_messages. You can use the parameter names
   with a F$MATCH_COND to determine the actual error
   The name of the message is used, prefixed by leadin (default to DIX$_)

   IF the /message is not given


    DIX&GT; LOAD/MESSAGE
    DIX&GT; some illegel command
    DIX&GT; if F$MATCH_COND($STATUS,DIX$_FILNOTF ) goto someplace

   The messages are loaded with a severity of 0(warning). You may also use
    the messagecodes in an exit statement, and add the severity

   Example (after a LOAD/MESSAGE is executed)

     DIX&GT;exit DIX$_CLINOCMND	!will return the warning severity
     %DIX-W-CLINOCMND, No command on line - reenter with alphabetical first character
     DIX&GT;exit DIX$_CLINOCMND +4  !will return the fatal severity
     %DIX-F-CLINOCMND, No command on line - reenter with alphabetical first character
     DIX&GT;exit DIX$_CLINOCMND +1  !will return the success severity
     %DIX-S-CLINOCMND, No command on line - reenter with alphabetical first character


</pre>
<a name="613">
<h3 Align=center><a href="dix_help_idx_4.html#429" target="index">DIX INTERACTIVE_COMMANDS LOAD LOAD_FUNCTION </a> </h3>
<pre>
 
  LOAD/FUNCTION filename[/module=name] [/log][/level=n][/global]

   If /module is not present, filename must be a file (default .DIX)
   If /module is present will lookup a text module in filename(.tlb)

   Load (user-written) function definitions. They can be used in
    expression in the same way as the built-in functions (F$...)

   Functions are defined at the current command_file level, unless
    /global   : define at level 0 (global)
    /level=n  : Define at level n (if n positive) or level+n (if n negative)
   If a level is closed (exit statement), DIX will delete all functions
    for that level.

  The file/module must have the following contents
  All comments (after the !) are ignored
  Empty lines are ignored
 
  FUNCTION name[/type] [argument[/type]...
  statements
  END FUNCTION
  
  There may be more than one function in a file/module
  
  The first line must contain the function definition
 
  name     : The name of the function, with optionally the type
  argument : A list of argument names, split by , or space
              and optionally followed by a type

   If the arguments are typed, DIX will check if the 
    calling parameter has the same type. If the argument is not
    typed, DIX will accept all types, and the function can 
    ask the type of the argument via F$TYPE() and act on it.

  Somewhere in the function there must be an assigment to the
  function name

  Example

   DIX&GT;LOAD/FUNC SYS$INPUT		!load the func
   DECK
   !Comment
   FUNCTION MYFUNC/INTEGER arg1/INT arg2/CHAR    !name/args
   if arg2 = "-" then                            !start of code
     myfunc = arg1 - 10                          !assign value (of type integer)
   else
     myfunc = arg1 + 10
   endif
   end function  				 !end of function
   EOD
   DIX&GT; SHOW function myfunc/fu/source           !display it
   MYFUNC/INTEGER (Level 1, 2 parameters, 5 lines, used 0 times)
    Parameters
     ARG1/INTEGER
     ARG2/CHARACTER
    Source file SYS$COMMAND:.;
        !Comment
        FUNCTION MYFUNC/INTEGER arg1/INT arg2/CHAR
        if arg2 = "-" then
          myfunc = arg1 - 10
        else
          myfunc = arg1 + 10
        endif
        end function
   DIX&GT; say myfunc(10,"+")                       !and use it
   20
   DIX&GT; say myfunc(10,"-")
   0
   DIX&GT; say myfunc(10,true)
   %DIX-E-WRARGTYP, Wrong argument type for function MYFUNC, argument 2
   %DIX-E-INVELEM, Invalid element "MYFUNC(10,TRUE"
   DIX&GT;

</pre>
<a name="614">
<h3 Align=center><a href="dix_help_idx_4.html#430" target="index">DIX INTERACTIVE_COMMANDS LOAD LOAD_DESCRIPTION </a> </h3>
<pre>

   Load/description descriptname

   Normally a description is loaded as soon as a file needs it.
   You can also load a description explicitly. This might be useful
   if you want to declare a  description type symbol. For more info
   see the help about symbols

</pre>
<a name="615">
<h3 Align=center><a href="dix_help_idx_4.html#431" target="index">DIX INTERACTIVE_COMMANDS LOAD LOAD_STRUCTURE </a> </h3>
<pre>
   LOAD/STRUCTURE [/quals] name[,name...]

   Load one or more structures into memory. These structures can be used to
   declare symbols (of the structured type).
 
   Name is a (mask of ) filenames or modules in one of the dix_des.tlb files
        or any .MLB or .TLB file.

   Quals can be
      /PARAMETERS  : All parameter statements in the structure file/module
                     Will be stored in the parameter table.
      /LOG         : Log the addition of the structures (and the paramters)
      /LEVEL=n     : Load parameter at the command level n.
                     n&GT;0 is aboloute level, n&LT;0 relative to the current
                     n=0 the global level
      /GLOBAL      : Load at global level is the same as /level=0
      /INTEGER_SIZE: For fortran files, the default integer size
                       4,8,32,64, default is 4 on vax, 8 on alpha,ia64
      /REAL_SIZE   : For fortran files, the default real size
                       4,8,16,32,64,128 default is 4
    
   In the .tlb files the modulename is STRU#name
   For filenames the default filename is .STRUCT
   All text after a ! is een as comment, and completely blank lines are ignored.

   A structure file/module has 2 formats

   1. Contains only the following statements
      a. datadefintions (including dimensions)
      b. RECORD /struct_name/ prefix
         Include an already loaded structure "struct_name"
   2. Each structure is enclosed between
        STRUCTURE /NAME/          NAME is used as structure name
        END STRUCTURE
      In this case all lines before the first STRUCTURE
      and between ENDSTRUCTURE en the following STRUCTURE are ignored.
      In this format you can define multiple structures in one file
   
   Example for format 1
    $type mystruct.struct : The structurename will be mystruct
!
      integer*4 index
      character*40 mystr
      real*16 real16val
      integer extra_int 
      integer*4 extra2(2,3)
!
   Example for format 2
   $type multstructs.struct
!
    structure /def_main/    !define structure def_main
     integer*4 index
     character*40 mystr
     real*16 real16val
     integer extra_int 
     integer*4 extra2(2,3)
!
    end structure
!
    structure /def_deep/   !define structrue deep_deep
      integer*4 i4val
      record /def_main/ mystruct !it includes a reference to def_main
      real*4 real4val
    end structure


</pre>
<a name="616">
<h3 Align=center><a href="dix_help_idx_3.html#175" target="index">DIX INTERACTIVE_COMMANDS LOGICAL </a> </h3>
<pre>
   LOGICAL[/level=n][/global] name[=value]

   Declare a new symbol of type "LOGICAL" and optionally give a value.
   The value must be of type "logical"

  Example
   LOGICAL debug=false

  See the help about  [DIX/help] interactive declaration
</pre>
<a name="617">
<h3 Align=center><a href="dix_help_idx_4.html#433" target="index">DIX INTERACTIVE_COMMANDS LOGICAL LOOP_TESTLOOP_ENDLOOP </a> </h3>
<pre>
 
  The more general form of the while/endwhile and the repeat/until.
  This allows the test to occur at any place in the repeat loop.

  LOOP
    [statement1(s) ]
  TESTLOOP logical_expression
    [statement2(s) ]
  ENDLOOP

  The loop/endloop is a block of statements. The TESTLOOP decides
  whether the loop will be exited. If the logical_expression evaluates 
  to false, the loop is exited.

  Example
   
  $DIX/INT SYSUAF
  SET NOON
  NREC=0
  LOOP
    NEXT RECORD
  TESTLOOP LOGICAL($STATUS)
    SAY "Username = ",uaf$t_username
    NREC = NREC + 1
  ENDLOOP
  SAY "#Records = ",nrec
  EXIT

  See also the help about the LEAVE and the CYCLE command 
  If you type the command from the terminal (instead from a command file)
  DIX will prompt you for more lines until the ENDLOOP command is found,
  and then will execute the commands.
 

</pre>
<a name="618">
<h3 Align=center><a href="dix_help_idx_3.html#176" target="index">DIX INTERACTIVE_COMMANDS MARK </a> </h3>
<pre>

  MARK [markname]

  Place a marker on this record. You can return to this record via the 
  GOMARK command. THe default markname is DIXMARK 

  example

  MARK this_rec

  command
  command
  ...
 
  GOMARK this_rec		!return to the record of the MARK
</pre>
<a name="619">
<h3 Align=center><a href="dix_help_idx_3.html#177" target="index">DIX INTERACTIVE_COMMANDS MOVE </a> </h3>
<pre>

   MOVE file1[\descr_tag] file2[\descr_tag] [/field=mask] [/log]

   Move the contents of fields in file1 to fields with the same name
   in file2. file1 and file2 are file tags. By default the current
   description is used, but you may override it with the \descr_tag.

   If the fields have the same type and size, this is a binary move,
   else the data will be converted to ascii and back to binary
   this allows you to move a text field (with digits) tio a binary integer

   Default all fields from the file1 with a matching name in file2 arwe
   copied, but you may restrict it using the /field=mask.
   If you specify /LOG, DIX will display the fields moved.

  Example

   Suppose file1 has a current dscription like

    CHARACTER*10 name
    CHARACTER*2  tag
    INTEGER*4    field1
    INTEGER*4    field2

  And file2 has a description of
    CHARACTER*20 name
    INTEGER*4    field2
    CHARACTER*2  tag
    INTEGER*8    rest

   the command "MOVE file1 file2"
 
  Will result in
    file2\name   will be filled with file1\name   via conversion
    file2\field2 will be filled with file1\field2 Binary copy
    file2\tag    will be filled with file1\tag    Binary copy
    file2\rest   Will be inited to 0

   So you could write a conversion script

      open file1 [/des=des1]   !open source
      open file2/create/modify [/des=des2]   !create target
      cnt=0                     !init counter
  lp: crea/ record file2         !create new empty record
      move file1 file2          !move the common fields
      cnt=cnt+1                 !update count
      file2\rest = cnt		!fill the count field 
      update file2              !write to file2 (target)
      read file1/end=done       !read the next record from source
      goto lp                   !keep going
  done:
      close file2               !close both files
      close file1
 
</pre>
<a name="620">
<h3 Align=center><a href="dix_help_idx_3.html#178" target="index">DIX INTERACTIVE_COMMANDS NEXT </a> </h3>
<pre>

  Syntax : NEXT [what]
  Via the NEXT command you can select the NEXT record, file or description.

  NEXT [RECORD]        :  Read the next record of the current file
  NEXT FILE            :  Select next file
  NEXT DESCRIPTION     :  Select next description of the current file.
  NEXT RECORD Tag      :  Read the next record of file with tag 'tag'
  NEXT RECORD /[NO]FAST:  Read the next record using fastio. This overrides
                          the default FASTIO mode for the file
                          See the set file/fast/default=fast

  If you use the next [record] command, and the file has an associated
  search pattern, DIX will find the next record matching this searchpattern


</pre>
<a name="621">
<h3 Align=center><a href="dix_help_idx_3.html#179" target="index">DIX INTERACTIVE_COMMANDS OPEN </a> </h3>
<pre>
 
  Open more files.
  The open command has two syntaxes
  
  1.  OPEN[/qualifiers] file[/qualifiers]
  2.  OPEN[/qualifiers] tag file[/qualifiers]

  Tag is a symbol that can be used to reference the file to.
  Most file commands use the current file, but if you specify a tag
  you can execute the command for a non-current file. DIX will append
  a sequence number to the tag if it is not unique.
  If you do not specify a tag, DIX will assume tag FILE, and append
  a sequence number to make it unique.

  In DIX mode
    Open will automatically read the first record, so there is a current
    record, unless the user specifies a record selection qualifier.
  In DCL_COMPATIBLE mode
    Open does not read the first record in case 2. 
    In case 1 DIX WILL read the first record (NOT DCL compatible anyway)
 

  example

  $DIX/INTERACTIVE
  DIX&GT; OPEN vaxdir vax.dir    	!open the file vax.dir and make it current
  DIX&GT; OPEN alphadir alpha.dir	!open the file alpha.dir, but VAX.dir will
                                !remain the current
  DIX&GT; NEXT RECORD alphadir     !read the next record of alpha.dir, but
                                !vax.dir will remain the current file
  DIX&GT; SELECT FILE alphadir     !now alpha.dir is the current
  DIX&GT; CLOSE vaxdir             !close vax.dir
  DIX&GT; CLOSE                    !close the current file (alpha.dir)

  DIX&GT; OPEN test test.dat/ge="Test"/key=1
      Open the file test.dat and (try to) read record with keyge "Test" on key 1

</pre>
<a name="622">
<h3 Align=center><a href="dix_help_idx_4.html#438" target="index">DIX INTERACTIVE_COMMANDS OPEN Qualifiers </a> </h3>
<pre>
</pre>
<a name="623">
<h3 Align=center><a href="dix_help_idx_5.html#609" target="index">DIX INTERACTIVE_COMMANDS OPEN Qualifiers /APPEND </a> </h3>
<pre>

  Opens an existing file for writing and positions the record
   pointer at the end-of-file (EOF). New records are added to the
   end of the file.

</pre>
<a name="624">
<h3 Align=center><a href="dix_help_idx_5.html#610" target="index">DIX INTERACTIVE_COMMANDS OPEN Qualifiers /BLOCKED </a> </h3>
<pre>
  /BLOCKED[=blocksize]
  /BLOCKED[=blocksize.bytesize]

  If the /BLOCK qualifier is specified, the file is accessed via BLOCK IO.
  You can either specify a number, this will interpreted as a number of
  disk blocks, or a block.byte where you can specify part of one or more 
  blocks. The total size cannot exceed 65535.

  The data transfer to and from the file is done via a blocksize bytes, and 
  no recordstructure is assumed. This method can destroy file/record
  integrity and should only be used if you know what you are doing.
  Blocksize is default 1 (=512 bytes if you specify /BLOCKED).
  It can be useful for files with undefined recordtype (as the DUMP file).

  Examples

  DIX&GT;OPEN filename/block=4	 !use a block size of 4*512 bytes
  DIX&GT;OPEN filename/block=0.32   !Use a blocksize of 32 bytes
  DIX&GT;OPEN filename/block=2.32   !Use a lblocksize of 1056 (2*512+32)
  DIX&GT;OPEN filename/block=0.1056 !the same as above


</pre>
<a name="625">
<h3 Align=center><a href="dix_help_idx_5.html#611" target="index">DIX INTERACTIVE_COMMANDS OPEN Qualifiers /CREATE </a> </h3>
<pre>
  Used to create the file. For extra security you must also specify the
  /modify qualifier. You may specify an FDL file via the /FDL=file
  qualifier. If you do not specify /FDL, a variable length sequential
  file will created.
</pre>
<a name="626">
<h3 Align=center><a href="dix_help_idx_5.html#612" target="index">DIX INTERACTIVE_COMMANDS OPEN Qualifiers /DEFAULT </a> </h3>
<pre>
  /NODEFAULT   Default
  /DEFAULT
  /DEFAULT=filename

  Use 'filename' as default name for the file to be opened
  If /default is specified without a value, the name of the 
   current file is used
  If you do not specify /default (or specify /nodefault) the default will
   be SYS$DISK:[CURRENT_DIRECTORY].DAT
</pre>
<a name="627">
<h3 Align=center><a href="dix_help_idx_5.html#613" target="index">DIX INTERACTIVE_COMMANDS OPEN Qualifiers /DESCRIPTION </a> </h3>
<pre>
  /DESCRIPTION[=name[,name]]
  Give the name of a record description file(s) or module. 
  For more help see the DIX /DESCRIPTION help
![DIX DESCRIPTION]DIX /description help
</pre>
<a name="628">
<h3 Align=center><a href="dix_help_idx_5.html#614" target="index">DIX INTERACTIVE_COMMANDS OPEN Qualifiers /ERROR </a> </h3>
<pre>
  /ERROR=label

  If the OPEN results in an error, DIX will jump to the label.
  If the /ERROR qualifier is not specified, DIX will look for the ON condition.
</pre>
<a name="629">
<h3 Align=center><a href="dix_help_idx_5.html#615" target="index">DIX INTERACTIVE_COMMANDS OPEN Qualifiers /FDL </a> </h3>
<pre>
  /FDL=filename
  Used with the /CREATE option. DIX will create the file using the FDL file
  for a specification. See the /CREATE qualifier
</pre>
<a name="630">
<h3 Align=center><a href="dix_help_idx_5.html#616" target="index">DIX INTERACTIVE_COMMANDS OPEN Qualifiers /GLOBAL </a> </h3>
<pre>
  Open the file at global level. This is the default.
  You may open the file at any (procedure) level via the /LEVEL qualifier
</pre>
<a name="631">
<h3 Align=center><a href="dix_help_idx_5.html#617" target="index">DIX INTERACTIVE_COMMANDS OPEN Qualifiers /KEY </a> </h3>
<pre>
  /KEY=nr

  Look for the keyvalue on the specified key. Default is the
  primary key (0).
  If none of the LT,LE,EQ,GE,GT options is specified, the program
  will start with the first record on the specified key.
</pre>
<a name="632">
<h3 Align=center><a href="dix_help_idx_5.html#618" target="index">DIX INTERACTIVE_COMMANDS OPEN Qualifiers /LEVEL </a> </h3>
<pre>

  /LEVEL              !open at this level
  /LEVEL=n            !open at level 0(=global) .. n (the current level)
  /LEVEL=-n           !open at level -1 (the previous level)..-n (max=depth)

   Open the file at a specific level. 
   If you open a file at a specific level, DIX will close the file if that
   level is closed. It is good programming practice to close all files
   that are opened in a procedure, but this is the easy way.

  Examples
    DIX&GT;@myproc
   
  And myproc.dix contains the following statements
   OPEN LUN FILE/LEVEL    !open at this procedure level
   EXIT                   !and exit to the previous level. At this point
                          !the file is closed.

  If the /LEVEL would not have been specified, the file would 
   have been opened at global level at thus would remain open.

</pre>
<a name="633">
<h3 Align=center><a href="dix_help_idx_5.html#619" target="index">DIX INTERACTIVE_COMMANDS OPEN Qualifiers /LT </a> </h3>
<pre>
  /LT=value

  Look for a record with keyvalue LT the specified value.
  This qualifier is valid for descending keys. Information about the
  keytypes can be obtained via the /INFO qualifier.

</pre>
<a name="634">
<h3 Align=center><a href="dix_help_idx_5.html#620" target="index">DIX INTERACTIVE_COMMANDS OPEN Qualifiers /LE </a> </h3>
<pre>
  /LE=value

  Look for a record with keyvalue LE the specified value.
  This qualifier is valid for descending keys. Information about the
  keytypes can be obtained via the /INFO qualifier.
</pre>
<a name="635">
<h3 Align=center><a href="dix_help_idx_5.html#621" target="index">DIX INTERACTIVE_COMMANDS OPEN Qualifiers /EQ </a> </h3>
<pre>
  /EQ=value

  Look for a record with keyvalue EQ the specified value.
</pre>
<a name="636">
<h3 Align=center><a href="dix_help_idx_5.html#622" target="index">DIX INTERACTIVE_COMMANDS OPEN Qualifiers /GE </a> </h3>
<pre>
  /GE=value

  Look for a record with keyvalue GE the specified value.
  This qualifier is valid for ascending keys. Information about the
  keytypes can be obtained via the /INFO qualifier.
</pre>
<a name="637">
<h3 Align=center><a href="dix_help_idx_5.html#623" target="index">DIX INTERACTIVE_COMMANDS OPEN Qualifiers /GT </a> </h3>
<pre>
  /GT=value

  Look for a record with keyvalue GT the specified value.
  This qualifier is valid for ascending keys. Information about the
  keytypes can be obtained via the /INFO qualifier.

</pre>
<a name="638">
<h3 Align=center><a href="dix_help_idx_5.html#624" target="index">DIX INTERACTIVE_COMMANDS OPEN Qualifiers /LOG </a> </h3>
<pre>

  Display a message when opening the file.

</pre>
<a name="639">
<h3 Align=center><a href="dix_help_idx_5.html#625" target="index">DIX INTERACTIVE_COMMANDS OPEN Qualifiers /LOCKING </a> </h3>
<pre>
  /LOCKING=(val,val...)

  Val can be
  RRL      : Read all record with the RAB$M_RRL option. This means that even
             if the record is locked by another stream, DIX can read it.
             The usage is at your own risk, since any other user can
             modify the data you are looking at (and possibly change).

 OPTIMISTIC: DIX will read the record with the RAB$M_NLK option. The record
             is read, but not locked. Other streams can read the data.
             When you want to update a modified record, DIX will check if
             the record still contains the original data, and if not
             warn you, and give you the option to not modify the record.
</pre>
<a name="640">
<h3 Align=center><a href="dix_help_idx_5.html#626" target="index">DIX INTERACTIVE_COMMANDS OPEN Qualifiers /MEMORY </a> </h3>
<pre>

  Load the file in a memory table (readonly)
  You can still read all records as if it a normal file

</pre>
<a name="641">
<h3 Align=center><a href="dix_help_idx_5.html#627" target="index">DIX INTERACTIVE_COMMANDS OPEN Qualifiers /MODIFY </a> </h3>
<pre>

  If the /MODIFY qualifier is specified, you are allowed to modify
  /delete/insert records, Either in raw mode (BYTE_OFFSET=VALUE) or
  in interpreted mode (file_name=value). If /MODIFY is present
  /INTERACTIVE is assumed.


</pre>
<a name="642">
<h3 Align=center><a href="dix_help_idx_5.html#628" target="index">DIX INTERACTIVE_COMMANDS OPEN Qualifiers /RECORD </a> </h3>
<pre>
  /RECORD=number

  Give the record number to read.
  If the number is negative, start at 'number' before EOF.
  
</pre>
<a name="643">
<h3 Align=center><a href="dix_help_idx_3.html#180" target="index">DIX INTERACTIVE_COMMANDS Overflow_detection-signalling </a> </h3>
<pre>

  If DIX encounters an arithmetic overflow, DIX will output the
  message %DIX-E-AROVERFL, Arithmetic overflow occurred
  and stops processing the command. So if you were multiplying
  a table with a scalar, and one of the elements overflowed, 
  DIX will not process the following elements, and return the error
  and not the result.

  You may en- or disable the overflow detection via the
   "set overflow en|disabled" command

  If you have overflow disabled, and you are processing a table a
  table, DIX will continue after one of the elements overflowed,
  but is unpredictable which element overflowed

  You can also set a trap on overflow detection with the
   "ON OVERFLOW 'command' "

  You can also test if the previous command had an overflow via
  the %OVERFLOW  special symbol

  examples
  DIX&GT;say 1000000*1000000		!overflow detection on
  %DIX-E-AROVERFL, Arithmetic overflow occurred
  DIX&GT;say %overflow
  True
  DIX&GT;set over disabled
  DIX&GT;say 1000000*1000000  	!overflow detection off
  -727379968                    !DIX return an answer (but it overflowed)
  DIX&GT;say %overflow
  True
  
  DIX&GT;ON OVERFLOW goto ov_detected
  DIX&GT;a=100000*100000
  DIX&GT;say "No overflow dectected , value=",a
  DIX&GT;exit
  DIX&GT;ov_detected:
  DIX&GT;say "Overflow was detected"

</pre>
<a name="644">
<h3 Align=center><a href="dix_help_idx_3.html#181" target="index">DIX INTERACTIVE_COMMANDS PARAMETER </a> </h3>
<pre>
  
   PARAMETER[/log] name=value
   PARAMETER[/log][/delete] mask

   Define (or delete) a global parameter.
   Since the value can contain /'s the qualifiers must be specified
   before the name or mask

   See also the help about LOAD (load the parameters from a .tlb/.MLB file)
</pre>
<a name="645">
<h3 Align=center><a href="dix_help_idx_3.html#182" target="index">DIX INTERACTIVE_COMMANDS PARSE </a> </h3>
<pre>

  Parse a line using a cldtable. This is the CLI$DCL_PARSE function.

  PARSE[/symbol=symbolname][/strict]/[address=number] Command

  Parse a command according a cld_table.
  You can specify the cld table in 3 ways:

   /symbol[=symbol]: This symbol must be filled by a compile[/table=symbol]
                     command first. Symbol defaults to DEFAULT_CLDTABLE.
   /address=nnnn   : Give the (memory-)address of a cld table. You can specify
                     the DCLTables in p1 space. You can find the address using
                     $ANA/SYS
                     SDA&GT; show symb CTL$AG_CLITABLE        !find DCLtables in P1 space
                     CTL$AG_CLITABLE = 00000000.7FFCD810 :  7AEF35FF.7AE40000
                     $DIX
                     DIX&GT; PARSE/ADDRESS=%X7AE40000 COPY    !Parse the copy command
    /dix           : Use the DIX command tables.


   If you specify /strict, DIX will complain if you inquire about tokens that
    are not defined in this command via the F$DCL_PRESENT or the F$DCL_GET_VALUE 
    function.
   If you do not specify /strict, DIX will return false / empty string and
    not signal an error.
 
</pre>
<a name="646">
<h3 Align=center><a href="dix_help_idx_3.html#183" target="index">DIX INTERACTIVE_COMMANDS PASTE </a> </h3>
<pre>
  PASTE[/qualifiers] [TAG][/symbol=symbolvalue]

  Restore current record values from save area(clipboard) or from a 
  symbol, where it is placed with the CUT or COPY command.

  Qualifiers can be
  /SYMBOL=expression  Read the data from an expression. This expression
                      must return a value of the type char.
  /DCL The symbol name is a dcl symbol. There are limitations on DCL
     symbols, and it you exceed them, you will see an error
  /GLOBAL THe dcl symbol is a global.

  If the file is a VFC file, and the /symbol is present, 2 symbols are used
  1. symbolname     : containing the record data value
  2. symbolname_VFC : containing the VFC data
  If either of them is not present, the command will fail

  Normally you would use this command with
  PASTE/SYMBOL=symbolname, where the symbol was previously filled with
  CUT/SYMBOL=symbolname.

  TAG is optional. If not specified the current file is used, otherwise
  the file specified by 'TAG' is used.
 
  Be careful : the value of /symbol is an expression, and all qualifiers
               in the string after the /symbol are considered a part
               of the expression. 
     so : paste/symbol=symbol/dcl  Will not work.
    and : paste/dcl/symbol=symbol  Will work.
</pre>
<a name="647">
<h3 Align=center><a href="dix_help_idx_3.html#184" target="index">DIX INTERACTIVE_COMMANDS PLOT </a> </h3>
<pre>

   PLOT[/qualifiers]     yvalue[/qualifiers][,yvalue[/qualifiers...]
   PLOT/PIE[/qualifiers] yvalue[/qualifiers][,yvalue]/qualifiers...] 
   PLOT/T4[/qualifiers]  filenamemask[,filenamemask]/qualifiers...] 
   PLOT/CSV[/qualifiers] filenamemask[,filenamemask]/qualifiers...] 

  PLOT can display data in a decwindows display(this requires decwindows),
       and also output to a POSTSCRIPT file, that can be printed.

  yvalue(s) must be a expression of type integer or real or deltatimes/dates
   IF there are more than one, they all must have the same number of 
   values in the first dimension. If they are multidimensional, 
   DIX will process this as more than one plot dataline.
    So if y=table(10,3), plot y will result is 3 datalines of 10 points each.

   You can mix real and integers, but not deltatimes. All expressions must
   be EITHER a mix of real and integer OR deltatimes.
   A datatype of date is also allowed as long as all elements are deltatimes.

  yvalue can also be a filename, preceeded by an @. In this case
   DIX will open the file (defaultfile .csv) and process the contents
   See the help about file_format for the syntax.
  
  For the PLOT/PIE all values must be integer or real (and not negative).
   DIX will plot a pie chart using the /legend expression to specify the
   data labels. The 9 largest items will be plotted, all others will be
   totalled in a total pie. You can specify more than one pie chart in a
   window, DIX will choose the distribution in the screen depending on the
   size of the window.

  If you specify the /CSV qualifier, DIX will assume that the data file(s)
   is a CSV file. You can use the /FLAG qualifier to specify some CSV
   specific values.Filenamemask can result in multiple files, DIX will 
   read and process them all.

  If you specify the /T4 qualifier, DIX will read the (t4-)filenamemask and
   plot that data (like TLVIZ on windows). Filenamemask can result in multiple
   files, DIX will read and process them all.

  DIX will plot all values (or t4 or csv files) in the same Decwindows display
   unless you specify /new_window or /separate.

  In each window upto 32 data windows can be displayed in upto 4 columns, 
   although the reasonable limit is also defined by the screen height/width. 
   See the /data_windows qualifier. 
   In each datawindow you can display any number of data-items.

  The following qualifiers are supported

</pre>
<a name="648">
<h3 Align=center><a href="dix_help_idx_4.html#444" target="index">DIX INTERACTIVE_COMMANDS PLOT examples </a> </h3>
<pre>

  DIX&GT; y=[10,20,30,40,50,10,20]   !create a table of 7 values
  DIX&GT; plot y                     !draw a decwindow plot with equidistant
                                  ! x values
  DIX&GT; x=[2,5,7,8,10,30,60]       !make an x table
  DIX&GT; plot y/x=symbol=x          !draw a plot with x as the x values, and
                                  ! y as the y values (they must have an equal number
                                  ! of values
  DIX&GT; PLOT @filename             !open filename[.csv] and read the contents


  DIX&GT; y=[[2,5,7,8,10,30,60][2,5,7,8,10,30,60]]  !create a 2-dimensional value
  DIX&GT; plot y                     !plot y (this will generate 2 lines)

  DIX&GT; y=[2,5,7,8,10,30,60]       !create a table
  DIX&GT; y2=[10,20,30,40,50,10,20]  !create a table
  DIX&GT; plot y/attr=label=val1,y2/attr=label=val2
                                  !plot 2 lines, and the legend now displays val1/val2
                                  !instead of y,y2
  DIX&GT; plot y/attr=(label=val1,colour=gray20),y2/attr=(label=val2,colour=gray10)
                                  !plot 2 lines, and set the colours explicitly
  DIX&GT; PLOT/T4 t4filemask         !Plot a t4 file

  DIX&GT; PLOT/PIE [10,20,30,5,10]   !Plot a pie chart of 5 values, Val 1..Val 5
  DIX&GT; PLOT/PIE [10,20,30,5,10]/legend=["v10","v20"] !the same plot, but now
                                  !the first two values (10 and 20) are named
                                  !v10 and v20
  DIX&GT; PLOT/PIE [[10,20,30,5,10][76,43,23,12,34]]/label=(p1,p2)
                                  !plot two pie charts in one window, named
                                  !p1 and p2. THe values have the name
                                  !value_1..value_5
  DIX&GT; PLOT/PIE @filename         !open filename[.csv] and read the contents
          
</pre>
<a name="649">
<h3 Align=center><a href="dix_help_idx_4.html#445" target="index">DIX INTERACTIVE_COMMANDS PLOT file_format </a> </h3>
<pre>

  DIX can open a file to read the data instead of the commandline
  The default filename is .CSV  

  DIX/plot @filename
  DIX/PLOT/PIE @filename

  In the file DIX supports the following lines
  
  :WMy Title               !Start a new window, and name it "My Title"
  :Xxval1,xval2,xval3...   !Give the x-values. Valn can be date, int or real
                           !not supported in PLOT/PIE
  :Llabel1,label2,label3.. !Give the label names for the PIE's in the PIE chart
                           !not supported in PLOT [/NOPIE]
  [label],val1,val2...     !Add a data line containg values valn. Valn can be
                           !integer or real. If the first element is not a
                           !valid number, DIX will assume it to be a label.

  In a file you can have multiple windows, xvalues,labels, dataline
  The default separator is ",", but may be overruled by the /FLAG=SEP=nn

  If there is no :W line, DIX will name the plot "Pie Plot" or "Data Plot"
  If there is no :X line, DIX will assume an equidistant x value e.g.
                          !X1,2,3,4,5...
  If there are more values than x-values, DIX will
    in pie mode     : add extra tags value_n
    in non pie mode : give a warning and skip extra data values
  If there are less values than x-values, DIX will
    in pie mode     : Ignore it
    in non pie mode : add 0 values

  Example (not pie plot)

  :WFirst window		!declare new window
  :X1.0,2.0,5.0,20.0            !set x values
  34,23,89,12                   !add a dataline
  -20,-49,49,20                 !add another dataline 
  :WSecond window               !make a second window
  12,34,67,89,76                !add a dataline

  Pie plot

  :WPie window		        !declare new window
  :LCust1,cust2,cust3,cust4     !set pie labels
  34,23,89,12                   !add a pie

  34,23,89,12                   !Make a pie plot of 4 values. The title
                                !is Pie Plot, and the PIE's are named
				!value_1..value_4

  
</pre>
<a name="650">
<h3 Align=center><a href="dix_help_idx_4.html#446" target="index">DIX INTERACTIVE_COMMANDS PLOT usage </a> </h3>
<pre>

  In decwindows mode, click on of the HELP buttons for more info.
  If you are entering a string the pf2/help key will display a help
  window about inputting strings.

</pre>
<a name="651">
<h3 Align=center><a href="dix_help_idx_4.html#447" target="index">DIX INTERACTIVE_COMMANDS PLOT qualifiers </a> </h3>
<pre>
</pre>
<a name="652">
<h3 Align=center><a href="dix_help_idx_5.html#638" target="index">DIX INTERACTIVE_COMMANDS PLOT qualifiers /ALL </a> </h3>
<pre>
  /ALL
  /ALL=progress

  Only in postscript output mode.

  DIX will plot the first "n_datawindow" datalines in the first page.
  If there are more datalines , DIX will continue on the next page,
  until all datalines are plotted.
  Note : For a t4 file there can be hunderds of datalines, so be
  careful, this can generate a lot of plotpages.
  You may reduce the number of datalines using the /FIELDS qualifier.
 
  If you specify the "progress" value, DIX will print the progress
  on the terminal.

</pre>
<a name="653">
<h3 Align=center><a href="dix_help_idx_5.html#639" target="index">DIX INTERACTIVE_COMMANDS PLOT qualifiers /ANGLE </a> </h3>
<pre>
  /ANGLE=degrees

 Set de aspect angle of the PIE chart. Default is 0 degrees (vertical)
 degrees must be &GT;=0 and &LT;=80 (almost horizontal) 

</pre>
<a name="654">
<h3 Align=center><a href="dix_help_idx_5.html#640" target="index">DIX INTERACTIVE_COMMANDS PLOT qualifiers /BACKGROUND </a> </h3>
<pre>

   /BACKGROUND=(colourname[,colourname2])

  Define the colour for the background using decwindows. THis is ignored for
  the postscript output.
  The default background colour is gray60
  The optional colourname2 is the background of the button/axis part of the display
</pre>
<a name="655">
<h3 Align=center><a href="dix_help_idx_5.html#641" target="index">DIX INTERACTIVE_COMMANDS PLOT qualifiers /BEFORE </a> </h3>
<pre>
  /BEFORE=date

   T4 files only. Select only files from date&LT;=date
   The selection is done via the day part in the filename 
      T4_NODE_DAY_TIMB_TIME.CSV

</pre>
<a name="656">
<h3 Align=center><a href="dix_help_idx_5.html#642" target="index">DIX INTERACTIVE_COMMANDS PLOT qualifiers /COLOUR </a> </h3>
<pre>

 /colour=(colourname[,colourname...])

  The colour for each drawing. Default DIX will generate 
  unique colours. If a datavalue contains more than one dateitem, 
  you can specify a colour for each dataitem
  
 Example :
  DIX&GT; y=[[1,2,3,4,5,6,7][11,12,13,14,15,16,17]] !Make a two dim table
                                                 !each with 7 elements

  DIX&GT; Plot y  !two lines will be draw with dix generated colours
  DIX&GT; Plot y/colour=(red,blue) !colour red is used for 1,2,3,4,5,6,7
                                !  and blue for 11,12,13,14,15,16,17
 

</pre>
<a name="657">
<h3 Align=center><a href="dix_help_idx_5.html#643" target="index">DIX INTERACTIVE_COMMANDS PLOT qualifiers /COMMON_x </a> </h3>
<pre>

  In a t4 file data lines can have (slightly) different x values (times).
  If you plot 2 data lines with different x values in different data windows
   each datawindow will have it's own x labels (and they may be differen).
  If you specify /COMMON_X, all datawindows will have the same x-axis values.
  Also if you enable a cursor (by clicking in a datawindow) , the cursoe 
   line will be drawn over all datawindows. 

</pre>
<a name="658">
<h3 Align=center><a href="dix_help_idx_5.html#644" target="index">DIX INTERACTIVE_COMMANDS PLOT qualifiers /CONFIRM </a> </h3>
<pre>
  For t4 files. If you specify a filename that matches multiple files ,or
  a .zip file, you can select specific files to be loaded
  DIX will prompt you with (f.e.)
  Process file t4_node_22feb2015_0000_2359_comp.csv ([Y]/N/A/Q):
 
  You can answer with
  Y : select the file
  N : do not select the file
  A : Select this file , and all subsequent matches will be processed
  Q : Do not select the file , and all subsequent matches will not be processed
  ^Z is the same as Q
</pre>
<a name="659">
<h3 Align=center><a href="dix_help_idx_5.html#645" target="index">DIX INTERACTIVE_COMMANDS PLOT qualifiers /DATA_WINDOWS </a> </h3>
<pre>

  /DATA_WINDOWS=number      one column
  /DATA_WINDOWS=ncol*nrow   #datawindows is nrow*ncol
 

  The number of datawindows in a plot-window. Number must be between 1 and 32.
  The default is 1.
  The number of columns must be between 1 and 8. Default is 1

</pre>
<a name="660">
<h3 Align=center><a href="dix_help_idx_5.html#646" target="index">DIX INTERACTIVE_COMMANDS PLOT qualifiers /FLAG </a> </h3>
<pre>
  /FLAG=(flag_topic[,flag_topic...])

  Specify CSV specific topics. This qualifier is only used for csv plotting
   and ignored for normal or t4 plots.

  flag_topic can be
  HEADER      : The first line is a header line, and will be uses to identify
                 the data streams.
  REVERSE     : The data is in the file in reverse order. 
  X_VALUE=val : THe first row is the x-value. If X_VALUE is not specified DIX
                 will assume an equidistant x-value (1..n)
                Val can be
                 date   : the x_value must be a valid date
                 time   : the x_value must be a valid time
                 number : the x_value is a (readl or integer) number
  SEPARATE=val: Set the separating character.
                  val can be:
                   SEPARATOR=BAR      : Use | as separator 
                   SEPARATOR=COMMA    : Use COMMA as separator	  
                   SEPARATOR=TAB      : Use TAB char as separator
                   SEPARATOR=COLON    : Use COLON (:) a separator
                   SEPARATOR=SEMICOLON: Use SEMICOLON (;) as separator
                   SEPARATOR=CHARACTER=%Xdd:  Use %Xdd as separator
                   SEPARATOR=AUTO     : Dix will try to find the separator
                                        this is not foolproof, but may work.
                 AUTO is the default

</pre>
<a name="661">
<h3 Align=center><a href="dix_help_idx_5.html#647" target="index">DIX INTERACTIVE_COMMANDS PLOT qualifiers /FIELDS </a> </h3>
<pre>
  
  /FIELDS=(pattern[,pattern...)
  /FIELDS="@filename"

  Used in the t4 plots to select a subset of all datalines matching 
  the pattern(s). A pattern can be preceeded by a -, signalling that
  the fields matching 'mask' will not be selected.

  Instead of listing all fields, youc can specify a filename. In this file
  you can specify the patterns. The defaultfilename is .LST

 Examples:

  DIX&GT;plot /t4 file /fields=*MON*
    Will select only the datalines with names matching *MON*
  DIX&GT;plot /t4 file /fields=([MON.SYST]*,-*BUFFER*)
    Select all fields matching [MON.SYST]*, but excludes the
    *BUFFER* fields. 

  DIX&GT;plot /t4 file /fields="@FIELDLIST"
   Open the file FIELDLIST.LST to get the fieldlist to be
    enabled/disabled.

  The selection can be changed in the decwindows mode in the
  options button.

</pre>
<a name="662">
<h3 Align=center><a href="dix_help_idx_5.html#648" target="index">DIX INTERACTIVE_COMMANDS PLOT qualifiers /FONT </a> </h3>
<pre>

  /FONT=fontname 

  Change the font DIX uses for the decwindows display
  DIX has partial support for proportional fonts.

  See also the /small_font qualifier

</pre>
<a name="663">
<h3 Align=center><a href="dix_help_idx_5.html#649" target="index">DIX INTERACTIVE_COMMANDS PLOT qualifiers /FOREGROUND </a> </h3>
<pre>

   /FOREGROUND=colourname

   The colour used as foreground in the message window
</pre>
<a name="664">
<h3 Align=center><a href="dix_help_idx_5.html#650" target="index">DIX INTERACTIVE_COMMANDS PLOT qualifiers /GRID </a> </h3>
<pre>

  /grid=(token[,token..)

  Draw a grid over the plotted area.
  Token can be:
   x=n               : draw n vertical lines.
   y=n               : draw n horizontal lines
   colour=colourname : Use colourname for the grid. Default is the x-axis colour
                       for the x lines, and the y-axis colour for the y lines.
</pre>
<a name="665">
<h3 Align=center><a href="dix_help_idx_5.html#651" target="index">DIX INTERACTIVE_COMMANDS PLOT qualifiers /INFO </a> </h3>
<pre>

  In the plot/pie mode. 
  SHow all data values (labels and values) in the top left/right part of the 
   plot. THis feature can also be ena/disabled in the options menu

</pre>
<a name="666">
<h3 Align=center><a href="dix_help_idx_5.html#652" target="index">DIX INTERACTIVE_COMMANDS PLOT qualifiers /LABEL </a> </h3>
<pre>

 /label=(labelname[,labelname...])

  The text to identify the drawing. Default is the symbolname
  If a datavalue contains more than one dateitem, you
  can specify a label for each dataitem

  In a PIE plot, the labelname will be printed under the PIE.
    
 Example :
  DIX&GT; y=[[1,2,3,4,5,6,7][11,12,13,14,15,16,17]] !Make a two dim table
                                                 !each with 7 elements

  DIX&GT; Plot y  !two lines will be draw with labels y and y_1
  DIX&GT; Plot y/label=(l1,l2) !label l1 is used for 1,2,3,4,5,6,7
                            !  and l2 for 11,12,13,14,15,16,17
 
</pre>
<a name="667">
<h3 Align=center><a href="dix_help_idx_5.html#653" target="index">DIX INTERACTIVE_COMMANDS PLOT qualifiers /LANDSCAPE </a> </h3>
<pre>
  If you want output to a postscript file, the default page-orientation is
  portrait. If you specify /landscape, DIX will plot the data in landsacpe mode.
  This qualifier is ignored in decwindows mode.
</pre>
<a name="668">
<h3 Align=center><a href="dix_help_idx_5.html#654" target="index">DIX INTERACTIVE_COMMANDS PLOT qualifiers /LEGEND </a> </h3>
<pre>

  /legend="character table"

  You can specify a list of texts to be used on as labels for the data.
  
  suppose you have a table y(100,2)

  you can do :
  DIX&GT; plot y/legend=["lab1","lab2"]
   and two datalines will be processe, labelled lab1 and lab2, each containing
   100 datapoints.
 
  If you specify a /y_axis=label=value, this overrides the legend qualifier

   In a PIE plot, legend will give a name to each datapoint. You do not need
   to specify a lengend namd for all values, DIX will append he list with
   names "Val n" for miising legend names.
  
  PLOT/PIE [10,20,40,4,43]/lagend=["v10","v20","v40"]
   Will mark value "10" with name "v10"
             value "20" with name "v20"
             value "40" with name "v40"
             and value "4", and "43" with names "Val 4" and "Val 5"
</pre>
<a name="669">
<h3 Align=center><a href="dix_help_idx_5.html#655" target="index">DIX INTERACTIVE_COMMANDS PLOT qualifiers /MARKER </a> </h3>
<pre>
  /MARKER=filenamemask  plot/t4 only
  
  In a T4 plot you can add markers to the plot. This may be useful if you
  f.e. changed a system at a certain time and want to see the effects in a
  T4 file. This filenamemask has as default filename 'datafilename'.MRK
  In this file you specify a number of lines in the following syntax
  date,text
  The date fields year,month,day are defaulted from time of the first 
  data file, and seconds, ticks are defaulted to 0, so you must specify
  hour:minutes at a minumum. The text after the comma is free format.
  the ! mark is used te signal comments, and blank lines are ignored.
  
  Example
  Suppose at 11:13 you changed the setting of fastpath for the PE driver,
  and at 14:25 you changed it back. You could then create a file 
  pechanged.mrk with the following contents

  !effects of changing pe driver
  11:13, PE to CPU5 !test to see if it works
  14:25, PE to CPU3

  and plot the te t4 file with plot/t4 t4file/mark=pechanged
  Dix will plot the contents an two marker lines at the 11:13 an 14:25
  time point. This will help you to see the effect of the change.
  You can also readin .mrk files in the display under the file menu.
  You can also specify a single marker in the file menu.
  
</pre>
<a name="670">
<h3 Align=center><a href="dix_help_idx_5.html#656" target="index">DIX INTERACTIVE_COMMANDS PLOT qualifiers /MERGE </a> </h3>
<pre>
  /MERGE   (default)
  /NOMERGE

  T4 files only. If you specify more than one file (or the filename mask
   results in more than one file), DIX will combine all datalines with
   the same name as a single entity. So moving to and from the datawindows
   will be done with the datalines (with the same name) of all files together.

  If you specify /NOMERGE all datalines will be seen separately.
   The flag can also be toggled via the Options menu.   

  example

   $DIX/PLOT/T4 *comp*.csv/sinc=date/bef=date/field="[mon.syst]cpu busy" 

   Will plot the cpu usage of all files in fileselection in one window.
   In combination  with the /post=file.ps, you can make a plot of
   f.e. the cpu usage of the last week

   $DIX/PLOT/T4 *comp*.csv/sinc=date/bef=date/field="[mon.syst]cpu busy" -
        /NOMERGE/DATA_WINDOW=7 
   
    Will plot each file in a separate data window
    
</pre>
<a name="671">
<h3 Align=center><a href="dix_help_idx_5.html#657" target="index">DIX INTERACTIVE_COMMANDS PLOT qualifiers /NEW_WINDOW </a> </h3>
<pre>
  
  If you specify more than one plot item, dix will display them in the 
  same window, unless you specify the /NEW_WINDOW. In this case the
  expression/filename will be displayed in a new window

  /NEW_WINDOW is a positional qualifier

  Example

  plot/t4 a.csv,b.csv,c.csv/new_window,d.csv  
 
  a and b will be displayed in the same window, and c and d in another one.

</pre>
<a name="672">
<h3 Align=center><a href="dix_help_idx_5.html#658" target="index">DIX INTERACTIVE_COMMANDS PLOT qualifiers /OFFSET </a> </h3>
<pre>
   /OFFSET=value

  You can spcify an offset to the x-values in the file. This might be
  usefull if you read two t4 files from two different OpenVMS machines
  that have a (slightly) different local time. In this way can plot
  data lines from both files at exactly the same x position.

  Examples
   Suppose we have two OpenVMS machines in different time zones. Each is
   collecting T4 files, and we want to see a correlation between events
   both machines.

   DIX/PLOT T4file_node1,t4file_node2/offset=1:00:00 or

   DIX/PLOT T4file_node1,t4file_node2/offset=-1:00:00 

   You can also set an offset to each individual data line in the
   display.  


</pre>
<a name="673">
<h3 Align=center><a href="dix_help_idx_5.html#659" target="index">DIX INTERACTIVE_COMMANDS PLOT qualifiers /PDF </a> </h3>
<pre>
  /pdf=filename
  /pdf=dix_plot.pdf  (default)

  Do not plot to a decwindows display, but make a pdf file, that
  can be printed later. Default is portrait page orientation, but you can 
  change that via the /landscape qualifier
  By default the background colour will be white, but you can change it
  with the /background=colour qualifier

</pre>
<a name="674">
<h3 Align=center><a href="dix_help_idx_5.html#660" target="index">DIX INTERACTIVE_COMMANDS PLOT qualifiers /POSTSCRIPT </a> </h3>
<pre>
  /postscript=filename
  /postscript=dix_plot.ps  (default)

  Do not plot to a decwindows display, but make a postscript file, that
  can be printed later. Default is portrait page orientation, but you can 
  change that via the /landscape qualifier
  By default the background colour will be white, but you can change it
  with the /background=colour qualifier

</pre>
<a name="675">
<h3 Align=center><a href="dix_help_idx_5.html#661" target="index">DIX INTERACTIVE_COMMANDS PLOT qualifiers /SETUP </a> </h3>
<pre>

  /setup[=filename]

  If you previously saved the plot setup via the save setup button
  you can use this file (by default sys$login:dix_plot.setup) to
  restore settings.

</pre>
<a name="676">
<h3 Align=center><a href="dix_help_idx_5.html#662" target="index">DIX INTERACTIVE_COMMANDS PLOT qualifiers /SELECT </a> </h3>
<pre>

  If you have more than one dataline, DIX will plot all lines in
  the available datawindows. If you specify /select (default for t4)
  DIX will only plot the first "n_datawindow" datalines. You can
  click in the legend display to plot more or less datalines.
</pre>
<a name="677">
<h3 Align=center><a href="dix_help_idx_5.html#663" target="index">DIX INTERACTIVE_COMMANDS PLOT qualifiers /SEGMENTS </a> </h3>
<pre>

  /SEGMENTS=nn

  For a PIE plot set the number of distinct pie's. The dafault is
  the minumum of 10 and the number of data items

</pre>
<a name="678">
<h3 Align=center><a href="dix_help_idx_5.html#664" target="index">DIX INTERACTIVE_COMMANDS PLOT qualifiers /SEPARATE </a> </h3>
<pre>

  If you specify more than one plot item, dix will display them in the 
  same window, unless you specify the /SEPARATE. In this case each 
  expression/filename(s) will be in a new window.
  This is the same as specifying /NEW_WINDOW with each parameter value.

</pre>
<a name="679">
<h3 Align=center><a href="dix_help_idx_5.html#665" target="index">DIX INTERACTIVE_COMMANDS PLOT qualifiers /SINCE </a> </h3>
<pre>
  /SINCE=date
   T4 files only. Select only files from date&GT;=date
   The selection is done via the day part in the filename 
      T4_NODE_DAY_TIMB_TIME.CSV
</pre>
<a name="680">
<h3 Align=center><a href="dix_help_idx_5.html#666" target="index">DIX INTERACTIVE_COMMANDS PLOT qualifiers /SIZE </a> </h3>
<pre>

  /SIZE=xsize[*ysize]

   The size in pixels for the decwindow display. It is ignored
   for postscript printing..If ysize is not specified, ysize will be the same
   as xsize.

</pre>
<a name="681">
<h3 Align=center><a href="dix_help_idx_5.html#667" target="index">DIX INTERACTIVE_COMMANDS PLOT qualifiers /SKIP_ZERO </a> </h3>
<pre>

  Only useful for t4 files. Skip all data lines that contain only 0 values.
  This can also be done (or undone) later via the options button.


</pre>
<a name="682">
<h3 Align=center><a href="dix_help_idx_5.html#668" target="index">DIX INTERACTIVE_COMMANDS PLOT qualifiers /SMALL_FONT </a> </h3>
<pre>

  By default DIX will use a 140 points font
        '-*-terminal-medium-*-normal--*-140-*-*-c-*-iso8859-*',

  Or if the -terminal- fonts are not installed the 
        '-*-courier-medium-*-normal--r-140-*-*-m-*-iso8859-*',

  If you specify /SMALL_FONT, DIX will use a 100 points font
        '-*-terminal-medium-*-normal--*-100-*-*-r-*-iso8859-*',

  Or if the -terminal- fonts are not installed the 
        '-*-courier-medium-*-normal--r-100-*-*-m-*-iso8859-*',

  Small font is default for dispays with less than 1024 pixels

  See also the /FONT qualifier

</pre>
<a name="683">
<h3 Align=center><a href="dix_help_idx_5.html#669" target="index">DIX INTERACTIVE_COMMANDS PLOT qualifiers /LARGE_FONT </a> </h3>
<pre>

  By default DIX will use a 140 points font
        '-*-terminal-medium-*-normal--*-140-*-*-c-*-iso8859-*',

  Or if the -terminal- fonts are not installed the 
        '-*-courier-medium-*-normal--r-140-*-*-m-*-iso8859-*',

  If you specify /SMALL_FONT, DIX will use a 100 points font
        '-*-terminal-medium-*-normal--*-180-*-*-r-*-iso8859-*',

  Or if the -terminal- fonts are not installed the 
        '-*-courier-medium-*-normal--r-180-*-*-m-*-iso8859-*',

  Small font is default for dispays with less than 1024 pixels

  See also the /FONT qualifier

</pre>
<a name="684">
<h3 Align=center><a href="dix_help_idx_5.html#670" target="index">DIX INTERACTIVE_COMMANDS PLOT qualifiers /SMOOTH </a> </h3>
<pre>
  /smooth=n

  If you specify /smooth=n, you set the default smooth points 
  for thw window to n.
  If you right click on a legend name in the datawindows,
   DIX will add a new dataline, smoothed over "n" points.

</pre>
<a name="685">
<h3 Align=center><a href="dix_help_idx_5.html#671" target="index">DIX INTERACTIVE_COMMANDS PLOT qualifiers /SORTED </a> </h3>
<pre>
  /[NO]SORTED, /SORTED is default
  For pie plot only.

  Normally DIX will sort the input value from high to low.
  If you specify /nosorted, DIX will use the order of the values
 
 Example

  DIX/PLOT/PIE [2,1,3]/sorted    Will plot the values in order 3,2,1
  DIX/PLOT/PIE [2,1,3]/nosorted  Will plot the values in order 2,1,3
 
  
</pre>
<a name="686">
<h3 Align=center><a href="dix_help_idx_5.html#672" target="index">DIX INTERACTIVE_COMMANDS PLOT qualifiers /STACKED </a> </h3>
<pre>

  If you specify /stacked, DIX will will stack the succesive y-values.
</pre>
<a name="687">
<h3 Align=center><a href="dix_help_idx_5.html#673" target="index">DIX INTERACTIVE_COMMANDS PLOT qualifiers /T4 </a> </h3>
<pre>


  The parameter must be a a filename mask that matches one ore more
  .csv files generated by T4. Dix will read the file and generate a 
   plot containing the data (like TLVIZ).
  DIX can also process the .zip files as delivered by the t4 product, 
   but you must have an UNZIP utility present and the UNZIP symbol 
   pointing to it.

  Example 

  In interactive mode

 DIX&GT; PLOT/T4 T4_CSV036_26FEB2011_0001_2359_COMP.CSV

  From the DCL-command line

  $ DIX/COMMAND PLOT/T4 *.CSV                 !all .csv files in 1 window
                                              !may be more than one

  $ DIX/COMMAND PLOT/T4 *.CSV;4,*.csv;5/new_w !*.csv;4 in one window, and
                                              !*.csv;5 in another one 

  $ dix/plot T4_NODE_20150222_0000_2359.ZIP;1/conf   !get files from .zip file
  Process file t4_node_22feb2015_0000_2359_comp.csv ([Y]/N/A/Q):y
  Process file t4_node_22feb2015_0000_2359_disk.csv ([Y]/N/A/Q):n
  Process file t4_node_22feb2015_0000_2359_fcm.csv ([Y]/N/A/Q):y

   Read files from a standard t4 .zip file. 
    To get the data from the ZIP file, DIX will spawn a subprocess
    to do the real unzip's . You must have a symbol UNZIP defined that
    points to an UNZIP utility that supports the following commands:
    $UNZIP -l zipfile     !make a listing
    $UNZIP zipfile csvfile -d tempdir
 
</pre>
<a name="688">
<h3 Align=center><a href="dix_help_idx_5.html#674" target="index">DIX INTERACTIVE_COMMANDS PLOT qualifiers /TIME_ONLY </a> </h3>
<pre>

  If the x-value is of type date, and you specify /time_only, DIX will only
  display the time and not the date on the x-axis. If you have multiple t4
  file of different dates, DIX will plot the values on the same x-axis values.
  /time_only is default for t4 plots, but may be negated. You can also change
  the flag in the options menu ites.
   
  example. 
 plot/t4 *26feb*,*27feb*        : Plot the data of the 26 and the 27feb on the
                                  same x-values, so the datalines will be above
                                  each other, and the x-axis will go 
                                  from 00:00 upto 24:00 (in total 1 day)
 
 plot/t4 *26feb*,*27feb*/notime : Plot the data of the 26-feb on the left side
                                  and the 27th on the right side of the plot,
                                  so the datalines will be next to each other,
                                  and the x-axis will be from 26-feb:00:00 upto
                                  27-feb:240:00 (in total 2 days)
                         
</pre>
<a name="689">
<h3 Align=center><a href="dix_help_idx_5.html#675" target="index">DIX INTERACTIVE_COMMANDS PLOT qualifiers /TITLE </a> </h3>
<pre>
  /TITLE=text
  
  The text plotted above the plot (the plot header).


</pre>
<a name="690">
<h3 Align=center><a href="dix_help_idx_5.html#676" target="index">DIX INTERACTIVE_COMMANDS PLOT qualifiers /TWO_Y_AXIS </a> </h3>
<pre>

  Draw the plots wtih a separate y_axis on both sides of the plot

</pre>
<a name="691">
<h3 Align=center><a href="dix_help_idx_5.html#677" target="index">DIX INTERACTIVE_COMMANDS PLOT qualifiers /TYPE=plot_type </a> </h3>
<pre>

  Define the plot_type.
  plot_type can be :
   Normal  : All points are connected via a line
   Filled  : All points are connect via a line, and DIX will fill all
             points between the line and the y=0 
             (or previous line if stacked)
   Scatter : Only the data point are drawn. In this mode DIX will only 
             accept one y-value, and the x-value symbol must be present
             DIX will also print a line on top with the correlation
             between x and y.
</pre>
<a name="692">
<h3 Align=center><a href="dix_help_idx_5.html#678" target="index">DIX INTERACTIVE_COMMANDS PLOT qualifiers /USE_DATE </a> </h3>
<pre>
  /USE_DATE Default
  /NOUSE_DATE   

   T4 files only. If you specify more than one file, DIX will append
   the named of the datalines with a #NN (filenumber) or with dd-mmm
   (date of the T4 file).
  You can also chanage this setting in the Options menu.

</pre>
<a name="693">
<h3 Align=center><a href="dix_help_idx_5.html#679" target="index">DIX INTERACTIVE_COMMANDS PLOT qualifiers /X_AXIS </a> </h3>
<pre>
   
  /X_AXIS=(token[,token...)
 
   Define x-axis attributes  
 
  Token can be:

    symbol=expression. If expression contains special characters
                       it must be enclosed in quotes

       If you do not specify symbol, DIX will
       plot the y values equidistant. the expression must be a 
       one-dimensional table with the same number of values as
       the (y-)values. The datatype of the x_symbol must be
       integer, real or date.

    label=string
       The text drawn below the x-axis.
    colour=colourname
        The colour of the x-axis fields. See the help about colournames.
    min=min_value
        Normally DIX will autoscales the x-axis, but you may overrule
        the min value. The min_value must be of the same datatype as the
        x-symbol (or integer if x_symbol is not specified)
    max=max_value
        See above, but now for the maximum x-value

</pre>
<a name="694">
<h3 Align=center><a href="dix_help_idx_5.html#680" target="index">DIX INTERACTIVE_COMMANDS PLOT qualifiers /Y_AXIS </a> </h3>
<pre>
   
  /Y_AXIS=(token[,token...)
 
   Define y-axis attributes  
 
  Token can be:
    label=string
       The text drawn left of the y-axis.
    colour=colourname
        The colour of the y-axis fields. See the help about colournames.
    min=min_value
        Normally DIX will does autoscale the y-axis, but you may overrule
        the min value. The min_value must be of the same datatype as the
        y-value(s)
    max=max_value
        See above, but now for the maximum y-value


  
</pre>
<a name="695">
<h3 Align=center><a href="dix_help_idx_3.html#185" target="index">DIX INTERACTIVE_COMMANDS PREVIOUS </a> </h3>
<pre>

  Via the PREVIOUS command you can select the PREVIOUS record,  file or description.

  PREVIOUS FILE        :  Select PREVIOUS file

  PREVIOUS DESCRIPTION :  Select PREVIOUS description of the current file.

  PREVIOUS [Record]     : Select the previous record. 
  PREVIOUS Record tag   : Select the previous record for file with tag 'tag'

  If you use the previous [record] command, abnd the file has an associated
  search pattern, DIX will find the previous record matching this searchpattern
 
   Be aware that backspacing for a large sequential (non-fixed record length) 
    file can be very time /io consuming, since it is done via 
    rewind + read n-1 records.

</pre>
<a name="696">
<h3 Align=center><a href="dix_help_idx_3.html#186" target="index">DIX INTERACTIVE_COMMANDS PUSH </a> </h3>
<pre>

  PUSH DIX_command
 
  This allows you to create (DIX-)command and let DIX execute it.

  Examples
  
  DIX&GT; k=1
  DIX&GT; command = "EXA XY_''k'"
  DIX&GT; PUSH 'command'
  And DIX will execute the command exa xy_1

  This gives exactly the same result as 

  DIX&GT; 'command'
 

</pre>
<a name="697">
<h3 Align=center><a href="dix_help_idx_3.html#187" target="index">DIX INTERACTIVE_COMMANDS QUIT </a> </h3>
<pre>

  Abort DIX. All open command levels will be closed. All changes to
  the current record will be discarded (at least if you did not yet
  save the changes with the DO command)

  AUTO mode will be disabled, unless you explicitly specify /AUTO

</pre>
<a name="698">
<h3 Align=center><a href="dix_help_idx_3.html#188" target="index">DIX INTERACTIVE_COMMANDS REAL </a> </h3>
<pre>
   REAL[*size][/level=n][/global] name[dimensions][=value]
   REAL[*size][/level=n][/global] name[=value]

   Declare a new symbol of type "REAL" and optionally give a value.
   The value must be of type "real"

   Size must be 4,8 or 16, the default is 4.

  Example
   DIX&GT; REAL limit=10.0	!declare a real with size=4
   DIX&GT; SHOW SYMBOL/FU LIMIT
   LIMIT(Fixed,Real_f*4,Level=1.0)=10.000000 !It is a real*4
   DIX&GT; limit=1.0q20                         !try to store a real*8
   LIMIT(Fixed,Real_f*4,Level=1.0)=0.999999993E20 !It is still real*4
   DIX&GT; limit=1.0q200                        !try to store a big value real*8
   %DIX-E-AROVERFL, Arithmetic overflow occurred !too big
 
   DIX&GT;real*16 test=1q2000		!declare a real*16
   DIX&GT;show symb test/fu
   TEST(Fixed*16,Real_x,Level=1.0)=0.1E2001

  See the help about  [DIX/help] interactive declaration


</pre>
<a name="699">
<h3 Align=center><a href="dix_help_idx_3.html#189" target="index">DIX INTERACTIVE_COMMANDS RECALL </a> </h3>
<pre>
   RECALL/ERASE
  Clear recall buffer

   RECALL/ALL    Mask  

   Make a list of commands that start with "mask"

   RECALL/SEARCH Mask

   Make a list of commands that match with "mask"

   RECALL Mask
 
   Recall the statement, and let you modify it.
   Mask can be 
    - a number   : recall 6  (recall the 6'th previous command)
    - A text     : Recall open (recall the last command that started with open)

</pre>
<a name="700">
<h3 Align=center><a href="dix_help_idx_3.html#190" target="index">DIX INTERACTIVE_COMMANDS READ </a> </h3>
<pre>

  READ [/qualifiers]                     read from the current file
  READ [/qualifiers] tag [/qualifiers]   Read from file tag
  READ tag symbol                        Read from file tag and create a
                                         character-type symbol with the contents
                                         of the record (like DCL)

 Via the READ command, you can read a record.
 For indexed files, the selection is via the /KEY,/EQ,/GE,/GT,/LE,/LT
 qualifiers.
 For all other files, the selection is via the /RECORDNUMBER qualifier

 If for an indexed file neither /EQ,/GE,/GT,/LE,/LT or, for 
 a sequential file /RECORD, is not given, DIX performs a sequential read.

 For unit record devices you may specify
   /prompt=Promptstring
   /timeout=n             

</pre>
<a name="701">
<h3 Align=center><a href="dix_help_idx_4.html#454" target="index">DIX INTERACTIVE_COMMANDS READ QUALIFIERS </a> </h3>
<pre>
</pre>
<a name="702">
<h3 Align=center><a href="dix_help_idx_5.html#688" target="index">DIX INTERACTIVE_COMMANDS READ QUALIFIERS /RECORDNUMBER </a> </h3>
<pre>

  /RECORDNUMBER=number
  
  Select the record to be manipulated. For direct access files or relative
  files, the record can be read direct. For sequential files, the record
  will be found by rewinding and skipping 'number'-1 records.
 
</pre>
<a name="703">
<h3 Align=center><a href="dix_help_idx_5.html#689" target="index">DIX INTERACTIVE_COMMANDS READ QUALIFIERS /KEY </a> </h3>
<pre>
  /KEY=nr

  Look for the keyvalue on the specified key. Default is the
  primary key (0).
  This qualifier is not allowed for non indexed files.
</pre>
<a name="704">
<h3 Align=center><a href="dix_help_idx_5.html#690" target="index">DIX INTERACTIVE_COMMANDS READ QUALIFIERS /LT </a> </h3>
<pre>
  /LT=value

  Look for a record with keyvalue LT the specified value.
  If none of the LT,LE,EQ,GE,GT options is specified, and the
  /KEY is given, DIX will the first record of the specified key.

</pre>
<a name="705">
<h3 Align=center><a href="dix_help_idx_5.html#691" target="index">DIX INTERACTIVE_COMMANDS READ QUALIFIERS /LE </a> </h3>
<pre>
  /LE=value

  Look for a record with keyvalue LE the specified value.
  If none of the LT,LE,EQ,GE,GT options is specified, and the
  /KEY is given, DIX will the first record of the specified key.
  This qualifier is not allowed for non indexed files.

</pre>
<a name="706">
<h3 Align=center><a href="dix_help_idx_5.html#692" target="index">DIX INTERACTIVE_COMMANDS READ QUALIFIERS /EQ </a> </h3>
<pre>
  /EQ=value

  Look for a record with keyvalue EQ the specified value.
  If none of the LT,LE,EQ,GE,GT options is specified, and the
  /KEY is given, DIX will the first record of the specified key.
  This qualifier is not allowed for non indexed files.
</pre>
<a name="707">
<h3 Align=center><a href="dix_help_idx_5.html#693" target="index">DIX INTERACTIVE_COMMANDS READ QUALIFIERS /GE </a> </h3>
<pre>
  /GE=value

  Look for a record with keyvalue GE the specified value.
  If none of the LT,LE,EQ,GE,GT options is specified, and the
  /KEY is given, DIX will the first record of the specified key.
  This qualifier is not allowed for non indexed files.
</pre>
<a name="708">
<h3 Align=center><a href="dix_help_idx_5.html#694" target="index">DIX INTERACTIVE_COMMANDS READ QUALIFIERS /GT </a> </h3>
<pre>
  /GT=value

  Look for a record with keyvalue GT the specified value.
  If none of the LT,LE,EQ,GE,GT options is specified, and the
  /KEY is given, DIX will the first record of the specified key.
  This qualifier is not allowed for non indexed files.

</pre>
<a name="709">
<h3 Align=center><a href="dix_help_idx_5.html#695" target="index">DIX INTERACTIVE_COMMANDS READ QUALIFIERS /ERROR </a> </h3>
<pre>
  /ERROR=label

  If the READ results in an error (or an EOF_OF_FILE and /END
  is not specified), DIX will jump to the label.
  If the /ERROR qualifier is not specified, DIX will look for the ON condition.

</pre>
<a name="710">
<h3 Align=center><a href="dix_help_idx_5.html#696" target="index">DIX INTERACTIVE_COMMANDS READ QUALIFIERS /END </a> </h3>
<pre>
  /END=label

  If the READ results in an EOF_OF_FILE and , DIX will jump to the label.
  If the /END is not specified, and an END_OF_FILE occurs, DIX will jump
  to the label in the /ERROR statement (if it is specified).
  If neither qualifier is specified, DIX will look for the ON condition.
</pre>
<a name="711">
<h3 Align=center><a href="dix_help_idx_5.html#697" target="index">DIX INTERACTIVE_COMMANDS READ QUALIFIERS /TRANSLATE </a> </h3>
<pre>
  /TRANSLATE   Default
  /NOTRANSLATE
  If a read is done with a /KEY=string, the string is checked for the
  occurrence of %DD where DD is a valid HEX number. In this way you
  can enter binary numbers in a string. %% is translated to one %.
  This behaviour is the default, but can be disabled by /NOTRANSLATE

</pre>
<a name="712">
<h3 Align=center><a href="dix_help_idx_5.html#698" target="index">DIX INTERACTIVE_COMMANDS READ QUALIFIERS /FAST </a> </h3>
<pre>
  Read the file using fastio (if the file is opened "fast")
  This override the default FASTIO mode for the file
  See the set file/fast/default=fast

</pre>
<a name="713">
<h3 Align=center><a href="dix_help_idx_5.html#699" target="index">DIX INTERACTIVE_COMMANDS READ QUALIFIERS /PROMPT </a> </h3>
<pre>
  For unit record devices you may specify
  
  /prompt=Promptstring default is DATA:

</pre>
<a name="714">
<h3 Align=center><a href="dix_help_idx_5.html#700" target="index">DIX INTERACTIVE_COMMANDS READ QUALIFIERS /TIMEOUT </a> </h3>
<pre>
  For unit record devices you may specify

   /timeout=n  : wait max n seconds             

</pre>
<a name="715">
<h3 Align=center><a href="dix_help_idx_5.html#701" target="index">DIX INTERACTIVE_COMMANDS READ QUALIFIERS /NOECHO </a> </h3>
<pre>

  For unit record devices you may specify

   /NOECHO  :  Do not echo the typed text
 
</pre>
<a name="716">
<h3 Align=center><a href="dix_help_idx_3.html#191" target="index">DIX INTERACTIVE_COMMANDS REMOVE </a> </h3>
<pre>

  REMOVE description mask
  REMOVE view mask

  Remove all descriptions/views that match 'mask'. 
    The descriptions/view are not deleted, only the link to the current file.

   Since you can have descriptions from multiple sources (even with the
     same name) you may limit your removal to a specific source.
      Supported qualifiers
     /SYSTEM_LIBRARY
       Remove only the description(s) that came from the system library
     /USER_LIBRARY
       Remove only the description(s) that came from the user library
     /FILE
       Remove only the description(s) that came from file(s)

  REMOVE parameter mask [/log]  Remove parameters
  REMOVE value mask     [/log]  Remove values
  REMOVE type mask      [/log]  Remove types

  For the last 3 you can also specify

  /GLOBAL  : remove item from global table
  /LEVEL=n : Remove item from a specific level table
     n can be  1..current command level
       or     -1..-n  N levels up

   Default level is the current command level
 

 
</pre>
<a name="717">
<h3 Align=center><a href="dix_help_idx_3.html#192" target="index">DIX INTERACTIVE_COMMANDS REPEAT_UNTIL </a> </h3>
<pre>

  syntax : REPEAT 
            statement
            statement
            ...
           UNTIL logicalexpression

 Repeat the statements as log as "logicalexpression" evaluates to true.
 See also the examples

  If you type the command from the terminal (instead from a command file)
  DIX will prompt you for more lines until the UNTIL command is found,
  and then will execute the commands.
 

  See also the help about the LEAVE and the CYCLE command

  Example for a repeat construct

  k = 10
  REPEAT
    say "The value of K = ''k'"
    k = k -2
  UNTIL k&LT;=1
    
  Delivers the same output as the FOR example

  K = 10
  WHILE k&LT;=1
    say "The value of K = ''k'"
    k = k -2
  ENDWHILE
   
  Delivers the same output as the FOR example

</pre>
<a name="718">
<h3 Align=center><a href="dix_help_idx_3.html#193" target="index">DIX INTERACTIVE_COMMANDS REREAD </a> </h3>
<pre>

  REREAD DESCRIPTION mask

  Force a reread of the description from the file/userlib/systemlib. 
  This may be useful if the description depends on symbolsubstitution, since
  this substitution is done only at read time of the description. 
  during the execution of the "OPEN file/des" or the "ADD des" commands.
 
  Example

   Below is an excerpt of the .audit$journal description

    ...
    structure 'full_name' (nsa$w_packet_count)
     #ifdef full_name
       integer*2 nsa$w_packet_size
       integer*2 nsa$w_packet_type [#nsa_packet_types]
     #else
       integer*2/nodisp nsa$w_packet_size
       integer*2/nodisp nsa$w_packet_type [#nsa_packet_types]
     #endif
     union
       map
        switch nsa$w_packet_type [#nsa_packet_types]
        case ACCESS_DESIRED
          bits*4 ACCESS_DESIRED [read,write,execute,delete,control]
	case ....
       end map
     end union 
     .....
    end structure
 
   If on open time of this description the symbol 'full_name' has a value
   DIX will have a name for the structure, and so deeper values will be
   prefixed with the 'full_name'(index).access_desired

   If full_name is not defined, the structure does not have a name, so
   all deeper fields will be displayed with their own name access_desired only

   If after the description is opened, you change the value of "full_name"
   DIX will not change the (fieldnames-)display, until you use the
   "REREAD DESCRIPTION AUDIT$JOURNAL. During the read the symbol-substitution
   will be executed, and the new value of "full_name" will take effect.
   
  See also the "set/show substitution" command.
</pre>
<a name="719">
<h3 Align=center><a href="dix_help_idx_3.html#194" target="index">DIX INTERACTIVE_COMMANDS REWIND </a> </h3>
<pre>
    REWIND                      current file
    REWIND /KEY=keynumber	current file, Indexed file only
    REWIND tag                  file with tag "tag"
    REWIND tag /key=keynumber   file with tab "tag", indexed file only
    REWIND /[NO]FAST            Rewind the file using fastio. This overrules
                                the default fastio access
                                See the SET FILE/FAST/default=fAST

  Rewind the file and read the first record . For indexed files you can 
  specify the key to rewind on.

</pre>
<a name="720">
<h3 Align=center><a href="dix_help_idx_3.html#195" target="index">DIX INTERACTIVE_COMMANDS SAY </a> </h3>
<pre>
   SAY is a synonym of EVALUATE.
   See the help of  [DIX/help] interactive EVALUATE

</pre>
<a name="721">
<h3 Align=center><a href="dix_help_idx_3.html#196" target="index">DIX INTERACTIVE_COMMANDS SEARCH </a> </h3>
<pre>


  In normal mode
     DIX&GT;SEARCH string[/qualifiers] [,string[/qualifiers...]] [string..]
          !Redefine a search pattern and search
     Search the current file for the first match
   or
     DIX&GT;SEARCH/file=filemask string[/qualifiers] [,string[/qualifiers...]]  -
              [string..] [/output=outputfile]
     Search a list of files for all matches

  In DCL compatible mode

     DIX&GT;SEARCH filemask string[/qualifiers] [,string[/qualifiers...]] -
                [string..] [/output=outputfile]
     Search a list of files for all matches
 
  SEARCH  !Next search 

  Search the current file (or a list of files) for a (list of) string(s). 
  The first match will stop the search. 
   See also the help about [DIX/help] record_searches

  Supported qualifiers are
   /REWIND    : If it is specified, DIX will search from the beginning 
                of the file, otherwise the next record.
   /PROGRES=n : Display the progress of search every n seconds
                The default value for n is 10 seconds
   /NAME=name : Use search pattern 'name' instead of the default 
                 search pattern
   /OUTPUT=name:For dcl_compat mode or when /files is specified
                  Set outputfile, default is SYS$OUTPUT

  If you specify a filemask (via /file or in dcl compat mode) 
  and you specify the filename as module@[library] or as [library](module),
  DIX will read the module "module" from the (.tlb or .mlb) file "library".
  Both module and library may contain wildcards.
  If no library is specified, DIX will search SYS$LIBRARY:STARLET.MLB
   and SYS$LIBRARY:FORSYSDEF.TLB (if present) by default.

  If you specify the /Statistics, DIX will report about the number of
   searched files, record, character, just like VMS search
   DIX will also define the SEARCH$ symbols
  
  Example:
   DIX&GT;sea/file=*.txt hlp/out=nl:/stat
   Files searched:                 6     Buffered I/O count:        47
   Records searched:            1111     Direct I/O count:          22
   Characters searched:        74527     Page faults:               11
   Records Matched:                3     Elapsed CPU Time :   0 00:00:00.11
   Lines printed:                 12     Elapsed Time :       0 00:00:00.12
   DIX&GT;show symbol search*
   SEARCH$CHARACTERS_SEARCHED=74527
   SEARCH$FILES_SEARCHED=6
   SEARCH$LINES_PRINTED=12
   SEARCH$RECORDS_MATCHED=3
   SEARCH$RECORDS_SEARCHED=1111

</pre>
<a name="722">
<h3 Align=center><a href="dix_help_idx_3.html#197" target="index">DIX INTERACTIVE_COMMANDS SELECT </a> </h3>
<pre>
  SELECT thing name

  SELECT FILE name
  Make the first file that matches 'name' to the filename or that has a tag
  'name' the current file
 
  SELECT DESCRIPTION name
  Make the first DESCRIPTION that matches 'name' the current description for
  the current file

</pre>
<a name="723">
<h3 Align=center><a href="dix_help_idx_3.html#198" target="index">DIX INTERACTIVE_COMMANDS SET </a> </h3>
<pre>
  
  Set some things

  syntax : set something enabled|disabled|on|off|yes|no
 
  An alternative way of setting flags is
  DIX&GT;enable something
  DIX&GT;disable something

</pre>
<a name="724">
<h3 Align=center><a href="dix_help_idx_4.html#463" target="index">DIX INTERACTIVE_COMMANDS SET AUTO </a> </h3>
<pre>

  SET AUTO enabled|disabled|on|off|yes|no

  Change the AUTO setting.
  This setting decides if you will save the current settings 
  (and open files/record and recall buffer) when you exit DIX.
  The EXIT/QUIT command also has the /[NO]AUTO to override this setting

</pre>
<a name="725">
<h3 Align=center><a href="dix_help_idx_4.html#464" target="index">DIX INTERACTIVE_COMMANDS SET CASE_SENSITIVE </a> </h3>
<pre>

  SET CASE_SENSITIVE enabled|disabled|on|off|yes|no

  IF case_sensitive mode is enabled, 
   Symbol/parameter/value/type/function/fieldnames 
     names are case sensitive. 
  If the mode is not case-sensitive, names will match in all cases.

  If you enter a name both in upper and lower case (in case sensitive mode)
  and then switch back to not case-sensitive mode, the lower case name is
  unreachable (the upper case will match). 

  If you do an direct assignment to a fieldname with the wrong case, DIX
   will create a symbol (no match in fieldnames, so it must be a symbol)

  Example
  DIX&GT; enable case
  DIX&GT; ab=10		!define 2 symbols with the same name
  DIX&GT; AB=20
  DIX&GT; xy=30            !and another one in lower case
  DIX&GT; say AB
  20
  DIX&GT; say ab
  10
  DIX&GT; say xy
  30
  DIX&GT; show symbols
  ...
  AB=20
  ab=10
  xy=30
  DIX&GT; say XY
  %DIX-E-INVELEM, Invalid element "XY"
  DIX&GT; disable case
  DIX&GT; say ab  !the lower case will be matched by the upper case first
  10
  DIX&GT; say AB  
  10
  DIX&GT; say XY  !XY=xy=Xy=xY
  30


  Examples for fieldnames 
   in this example the sysuaf.des contains a 
    uaf$t_defcli      in lower case and a 
    UAF$T_CLITABLES   in uppercase

  DIX&GT;enable case		!set to case sens
  DIX&GT;exa *cli*                 !sh lower case
  276|uaf$t_defcli|DCL          !the value
  DIX&GT;exa *CLI*			!Try the uppercase CLI
  308|UAF$T_CLITABLES|DCLTABLES !and see it's value

  DIX&GT;disa case                 !set to case insensitive
  DIX&GT;exa *cli*			!sh *cli*
  276|uaf$t_defcli   |DCL       !displays both fields
  308|UAF$T_CLITABLES|DCLTABLES

  DIX&GT;enab case
  DIX&GT;uaf$t_defCLI="DCL"    !will generate a symbol with the name uaf$t_defCLI
  DIX&GT;disab case
  DIX&GT;uaf$t_defCLI="DCL"    !will modify the field uaf$f_defcli
</pre>
<a name="726">
<h3 Align=center><a href="dix_help_idx_4.html#465" target="index">DIX INTERACTIVE_COMMANDS SET DEBUG-NODEBUG </a> </h3>
<pre>
   SET DEBUG debugitems

   SET NODEBUG

   Mainly meant as a development aid. The output may change at any new
   version.
   This allows you to print out (a lot of ) debug info
   See also the help about SETUP for the DIX_DEBUG symbol

   debugitems can be
   NONE    : All items off
   ALL     : Enable all items
   LEVEL=n : THe higher the number, the more output
   OUTPUT=filename : Output to a file, default is sys$output
   TIME    : Insert the time in the debug output line  

   All following tokens can be negated 

   fp_conversions  FLoating point conversion actions
   descriptions    Description processing
   keys            Key mapping (smg mode)
   symbols         Symbols
   command_file    Command file processing
   expand          Description expansion
   file            File related actions
   find            Character string matching
   vm              Virtual Memory actions
   fastio          Fastion file actions
   decw            Decwindow events
   rms             RMS commands
   expression      Expression evaluation
   parameter       Parameter statements
   search          Searching data
   readin          Reading description files/modules
   view            View processing
   buffers         Buffer management
   strings         String management
   sort            Sorting table elements
   functions       User defined function management
   parse           Command line parsing
   value           All events regarding to values 
   structure       debug for structures
   memtab          Debug for memory tables
   lbr             Debug for library operations
   directory       Directory (sort) operations
</pre>
<a name="727">
<h3 Align=center><a href="dix_help_idx_4.html#466" target="index">DIX INTERACTIVE_COMMANDS SET DECIMAL </a> </h3>
<pre>

   SET decimal/[qualifiers]

  Change the settings for the decimal strings

  /DIGITS=n   : the number of digits in the number
  /ROUNDED    : Set to round mode
  /TRUNCATE   : Set to truncate mode


</pre>
<a name="728">
<h3 Align=center><a href="dix_help_idx_4.html#467" target="index">DIX INTERACTIVE_COMMANDS SET DECWINDOWS </a> </h3>
<pre>

  SET DECWINDOWS [/qualifiers] 
  Change the settings for the decwindow mode
  See also the qualifier /ATTRIBUTES
 
  If you do not specify any qualifiers, DIX will switch to 
  decwindows mode
 
  /HEIGHT=n       : The height of the main display in pixels,
                    default is 80 characters, so it depends on the font
  /WIDTH=n        : The width of the main display in pixels
                    Default is 30 lines, so it depends on the font
  /FONT=name      : Name can be Small,Medium,Large,name=fontname
                    Default is medium on display with more than 1024
                    pixels, and small for smaller ones.
  /COLOUR=display=(fore=colour,back=colour,High=colour)
                  : Change the colours for the various displays
                    Default colours are 
                     backgound=gray50,foreground=white,high=red

    Display can be
         main       The main display
         offset     The offset part of the main display
         field      The field part of the main display
         value      The value part of the main display
         bar        The scroll bars
         menu       The menu
         message    The message display
         alldisplay The all-format display
         desdisplay The description display

</pre>
<a name="729">
<h3 Align=center><a href="dix_help_idx_4.html#468" target="index">DIX INTERACTIVE_COMMANDS SET DEFAULT </a> </h3>
<pre>

   Set default [device:][directory]

   Change the current default setting

</pre>
<a name="730">
<h3 Align=center><a href="dix_help_idx_4.html#469" target="index">DIX INTERACTIVE_COMMANDS SET DISPLAY </a> </h3>
<pre>
  Set default display parameters
  These setting can be overruled by qualifiers in the EXAMINE command.
 
   Syntax : SET DISPLAY par[,par...]

  Where par can be
  
  HEX           : Set HEX display mode for the data
  DECIMAL       : Set Decimal display for the data
  BINARY        : Set Binary display for the data
  OCTAL         : Set Octal display for the data
  OFFSET=HEX    : Set the offset field to HEX in the raw display
  OFFSET=DECIMAL: Set the offset field to Decmal in the raw display
  OFFSET=NONE   : Do not display the offset part in the raw display
  NOOFFSET      : Do not display the offset part in the raw display
  [NO]RAW       : Set or clear RAW mode display
  BYTE          : display raw data in byte mode
  WORD          : display raw data in word mode
  LONGWORD      : display raw data in longword mode
  UNSIGNED      : display raw data (if not in hex mode) as unsigned integers.
  [NO]TAG       : Display data from multiple files with file\desc\ tag, see
                  the help at examine/tag
  [NO]RECNR     : display the recordnumber
  [NO]RECLEN    : display the recordlength
  [NO]RFA       : display the rfa of the record
  [NO]FIELDNAME : Display the fieldnames
  [NO]EBCDIC    : Set the EBCDIC translation flag
  [NO]WRAP      : If set, DIX will wrap output to the width of the terminal.
                  If clear, DIX will not wrap. Default is WRAP
  [NO]BIT_OFFSET: Force offsets to be displayed with the bitoffset part.
                   Normally DIX displayes bit_offsets only if somewhere in the
                   record a data field is not byte aligned.
  [NO]HIGHLIGHT : Datavalues in current key (idx files) will be highlighted or not
  WHOLE_RECORD  : Do not try to format, just dump the whole record. In this case
                  all other flags are cleared, and the /FORMAT is ignored. You
                  may specify set display=(whole,[recnr],[recsize],[rfa]) to add
                  an additional record with this info.
  The separator is used in interactive mode between the offset/field/value

  SEPARATOR=NONE     : Do not use a separator
  SEPARATOR=BAR      : Use | as separator 
  SEPARATOR=COMMA    : Use COMMA as separator	  
  SEPARATOR=TAB      : Use TAB char as separator
  SEPARATOR=COLON    : Use COLON (:) a separator
  SEPARATOR=SEMICOLON: Use SEMICOLON (;) as separator
  SEPARATOR=CHARACTER=%Xdd:  Use %Xdd as separator


</pre>
<a name="731">
<h3 Align=center><a href="dix_help_idx_4.html#470" target="index">DIX INTERACTIVE_COMMANDS SET EDITOR </a> </h3>
<pre>

  SET EDITOR whichone

  Define your editor for editing description records

  Possible options are
   EDT      Use EDIT/EDT
   INTERNAL Use an internal editor (simple but fast)
   TPU      Use EDIT/TPU

</pre>
<a name="732">
<h3 Align=center><a href="dix_help_idx_4.html#471" target="index">DIX INTERACTIVE_COMMANDS SET EVALUATION_ORDER </a> </h3>
<pre>
  
   SET EVALUATION_ORDER name[,name...]

   Name can be : PARAMETER,FIELD,SYMBOLS
   
 
   When locating a name, DIX can search trough various lists.

    1. The list of symbols
    2. The list of all values/parameters
    3. The list of fieldnames (if a file is open)

   Normally DIX will search the lists in above order, but you can change
   it. The SHOW EVALUATION_ORDER will display the current order

   If you do not specify all names, the rest will ramain in the original
    order
  
  Example
   SHOW EVA
    DIX&GT;sh eva		!show the current setting
    Evaluation order set to :Symbol,Parameter,Field
    DIX&GT;set eval p,s,f !change the order
    DIX&GT;sh eval
    Evaluation order set to :Parameter,Symbol,Field
    DIX&GT;set eval f	!make sure field is in front
    DIX&GT;sh eva          !symbol and field remain in the same order
    Evaluation order set to :Field,Parameter,Symbol

</pre>
<a name="733">
<h3 Align=center><a href="dix_help_idx_4.html#472" target="index">DIX INTERACTIVE_COMMANDS SET Extra_devices </a> </h3>
<pre>
   set extra_devices [/dcl=name ] [/mem=name]

   Change the names for the Memory/dcl 'files' device names.
   This might be useful if the default (logical) names MEM: and DCL: 
   are already  in use.

   'name' is the new name of the devices. If it is not terminated with a
    colon, DIX will append one.
   The first character must be a letter, the following must be either
    letters or digits.

  Example :  Set extra/dcl=mydcl:   ! the new name is mydcl:
    
</pre>
<a name="734">
<h3 Align=center><a href="dix_help_idx_4.html#473" target="index">DIX INTERACTIVE_COMMANDS SET FILE </a> </h3>
<pre>
   SET FILE [mask] [qualifiers]
  
  Change the attributes for one or more opened files.
  If you do not specify [mask], only the attributes of the current file 
  are changed. 

  Supported qualifiers are
  /LOCKING=(value[,value...])
   And value
    [NO]RRL        : Change the RRL setting for this file
    [NO]OPTIMISTIC : Change the optimistic locking flag
    See the help about  [DIX/help] interactive /locking 

  /[NO]MODIFY      : Change the modify setting of the file,
                      The current record remains the same.
  /[NO]FAST        : Open/close the file for fastio. This can only be
                     done for files that are open for READONLY.
                     If the file is changed to /MODIFY, the file
                     is automatically closed for fastio.
  /[NO]USE_VIEW    : Toggle usage of view (if view loaded)
  /[NO]BLOCKED[=n.m]: REOpen the file in [non]blocked mode. See the help about
                     /blocked
  /DEFAULT=FAST    : Set the default file access to fastio (if the file
                     is opened for FASTIO and access was RMS)
  /DEFAULT=RMS     : Set the default file access to RMS IO (if the file
                     is opended for FASTIO and access was FASTIO)
    See also the /FAST qualifier
  /LIMIT

     /LIMIT=value=(string,key=nn) 	!limit to key value
     /LIMIT=value=(number,string)       !limit to record number

    See also the DIX/LIMIT qualifier   

  /MAX_BYTES
     /MAX_BYTES=n               !limit the recordsize
     /NOMAX_BYTES               !Clear the limit
    If the recordsize is larger than 'n' DIX will only display the bytes
     upto 'n'. 

  /SEARCH[=name]  !Attach a search pattern to a file. See also the help about
                  !set search

  Example
   Set file *TEST*/locking=RRL 
     Set all files with tag matching *TEST* to rrl locking mode.
 
   Set file /modify
     Set the current file to modify.

  Example for file search

    $ DIX /INT SYSUAF
    DIX&GT; SET SEARCH TCPIP[/NAME=MYNAME]    !Define a search pattern
    DIX&GT; SET FILE [SYSUAF]/SEARCH[=MYNAME] !attach the search pattern to the file
    DIX&GT; NEXT RECORD                       !search the next record containing TCPIP


</pre>
<a name="735">
<h3 Align=center><a href="dix_help_idx_4.html#474" target="index">DIX INTERACTIVE_COMMANDS SET FORMAT </a> </h3>
<pre>
  SET FORMAT option
  SET FORMAT DOT     (default)

  Normally all "character"-like fields will not contain unprintable data.
  These field types are CHARACTER,xSTRING.
  If the data does contain unprintables (hex 0:1f,7f,80:9f or ff) the
  /FORMAT qualifier determines how this data should be displayed.

   Option can be
    DOT   :All unprintables are replaced by a ".". This encoding is not
            reversible, after an unprintable value is replaced by a ".", 
            DIX cannot know what the original unprintable value was. This may
            be a problem in the screen mode.
    HEX   :All unprintable data is displayed as %Xdd, a hexadecimal display.
            A % in the data will be displayed as %%. This display is reversible,
            so DIX can reconstruct the original unprintable value.
            If you are in this mode, on input a % must be entered as %%
    PASSALL:DIX will not change the unprintable data. The data is displayed as
            it is. THis mode will not work in screen mode, and maybe poorly
            when the output device is a terminal.
    DUMP   :Unprintable bytes are represented by a 2 or 3 letter mnemonic
            like &LT;DEL&GT; or &LT;CR&GT;. A &LT; in the text will be displayed as &LT;&LT;.
            This display is reversible, so DIX can reconstruct the original 
            unprintable value.
            If you are in this mode, on input a &LT; must be entered as &LT;&LT;

</pre>
<a name="736">
<h3 Align=center><a href="dix_help_idx_4.html#475" target="index">DIX INTERACTIVE_COMMANDS SET INTEGER </a> </h3>
<pre>

  SET INTEGER commands

   SET INTEGER FORMAT /size=n new_format
 
    Change the conversion format for integers
    /size=n(n=4,8): for what integer size the format is changed
    new_format    : the new format string : see the fortran manual for defauls
                     but the most useful will be Inn, where nn the maximum text
                     size for conversion.
    /default      : change back to default
                     size=4 : I10
                     size=8 : I20
</pre>
<a name="737">
<h3 Align=center><a href="dix_help_idx_4.html#476" target="index">DIX INTERACTIVE_COMMANDS SET DCL_COMPATIBLE </a> </h3>
<pre>

  SET DCL_COMPATIBLE compatible|fallback

   Since the DIX syntax looks very much the same as the DCL syntax, you may
   want to use DCL procedures. But in those procedures each command starts with
   a $. If you set DCL_COMPATIBLE to compatbile, DIX will remove the first $ 
   from each line (if it is there), and replace the DCL comparison operators 
   (.eq(s)., .gt(s). .not. .and. .or. etc.) by the DIX equivalents (=,&GT; etc.)
   allowing you to use the DCL-file as (DIX-)command file. 
   Not all DCL commands are supported of course, but maybe enough.   

  If you set dcl_compatible to fallback, DIX will try all commands that
   fail to be processed by DIX via a spawn of a subprocess.
   This will not always work (f.e. if the spawned command defines logs/symbols)
   but maybe is it good enough.

  The default setting is set nodcl_compatible

              
</pre>
<a name="738">
<h3 Align=center><a href="dix_help_idx_4.html#477" target="index">DIX INTERACTIVE_COMMANDS SET KEYBOARD </a> </h3>
<pre>
  SET KEYBOARD value
   Define the input keyboard. Value can be
    Normal : the LK45X keyboard layout
    PC     : The normal pc-type keyboard. Since the PC-keyboard
             misses some keys, those keys are redefined. This is
             visible in the help.
             f13..f20 are displayed as Shift-F3..Shift-f10
             Find                      Home
             Select                    End
             Next_screen               PageDown
             Prev_screen               Pageup
    LAPTOP : The normal LAPTOP misses also the PF1-PF4 keys, they
             are redefined to ^F,^G,^K and ^L as well as the PC
             keyboard modifications.
</pre>
<a name="739">
<h3 Align=center><a href="dix_help_idx_4.html#478" target="index">DIX INTERACTIVE_COMMANDS SET LIBRARY </a> </h3>
<pre>

  SET LIBRARY libname [/write]
 
  Set (user-) library filename for the descriptions.
  The library must be a text library and exist.

</pre>
<a name="740">
<h3 Align=center><a href="dix_help_idx_4.html#479" target="index">DIX INTERACTIVE_COMMANDS SET LOW_FIRST </a> </h3>
<pre>

   SET LOW_FIRST ENABLED|YES|ON      
   SET LOW_FIRST DISABLED|NO|OFF     (default)
  
   When a table has more than one dimension, DIX will vary the
   lowest dimension first. SO if you have a symbol a(2,2), DIX will
   display A(1,1),   A(1,2),   A(2,1),   A(2,2)

   If you disable LOW_FIRST, DIX will display   
   display A(1,1),   A(2,1),   A(2,1),   A(2,2)

   More interesting, this also affects fields in records.

</pre>
<a name="741">
<h3 Align=center><a href="dix_help_idx_4.html#480" target="index">DIX INTERACTIVE_COMMANDS SET MESSAGE </a> </h3>
<pre>
 
  Change the way DIX displays error messages

</pre>
<a name="742">
<h3 Align=center><a href="dix_help_idx_5.html#728" target="index">DIX INTERACTIVE_COMMANDS SET MESSAGE qualifiers </a> </h3>
<pre>
</pre>
<a name="743">
<h3 Align=center><a href="dix_help_idx_6.html#742" target="index">DIX INTERACTIVE_COMMANDS SET MESSAGE qualifiers /FACILITY </a> </h3>
<pre>
  /FACILITY
  /NOFACILITY

  Set or clear the facility part
</pre>
<a name="744">
<h3 Align=center><a href="dix_help_idx_6.html#743" target="index">DIX INTERACTIVE_COMMANDS SET MESSAGE qualifiers /IDENT </a> </h3>
<pre>

  /IDENT
  /NOIDENT

  Set or clear the ident part
</pre>
<a name="745">
<h3 Align=center><a href="dix_help_idx_6.html#744" target="index">DIX INTERACTIVE_COMMANDS SET MESSAGE qualifiers /SEVERITY </a> </h3>
<pre>
  /SEVERITY
  /NOSEVERITY

  Set or clear the severity part

</pre>
<a name="746">
<h3 Align=center><a href="dix_help_idx_6.html#745" target="index">DIX INTERACTIVE_COMMANDS SET MESSAGE qualifiers /EXECUTABLE </a> </h3>
<pre>
  /EXECUTABLE
  /EXECUTABLE

  Set or clear the excutable part.
   If you search messages in images, DIX will append the image name if
   /executable is set. See the F$MESSAGE function

</pre>
<a name="747">
<h3 Align=center><a href="dix_help_idx_6.html#746" target="index">DIX INTERACTIVE_COMMANDS SET MESSAGE qualifiers /TEXT </a> </h3>
<pre>
  /TEXT
  /NOTEXT

  Set or clear the text part
</pre>
<a name="748">
<h3 Align=center><a href="dix_help_idx_6.html#747" target="index">DIX INTERACTIVE_COMMANDS SET MESSAGE qualifiers /NONE </a> </h3>
<pre>
  Clear all message flags
</pre>
<a name="749">
<h3 Align=center><a href="dix_help_idx_6.html#748" target="index">DIX INTERACTIVE_COMMANDS SET MESSAGE qualifiers /ALL </a> </h3>
<pre>
  Set all message flags

</pre>
<a name="750">
<h3 Align=center><a href="dix_help_idx_4.html#481" target="index">DIX INTERACTIVE_COMMANDS SET MOUSE </a> </h3>
<pre>
  SET MOUSE ON|ENABLED|YES
  SET MOUSE OFF|DISABLED|NO

  Enable or disable the MOUSE usage in screen mode
  If enabled, DIX will interpret the mouse clicks, if disabled SMG
  will not interpreted the clicks, so you can select/copy text.
  This mouse flag can also be changed in screen mode via the pf4-m command.

</pre>
<a name="751">
<h3 Align=center><a href="dix_help_idx_4.html#482" target="index">DIX INTERACTIVE_COMMANDS SET ON </a> </h3>
<pre>

  SET ON
  SET NOON
 
   Like DCL, the SET NOON ignores errors, and let the user check these
   errors by examining $STATUS.

</pre>
<a name="752">
<h3 Align=center><a href="dix_help_idx_4.html#483" target="index">DIX INTERACTIVE_COMMANDS SET OUTPUT_FILTER </a> </h3>
<pre>
  
   Set output_filter[/qualifier] text
   set nooutput_filter

  Qualifier can be 
   /WILDCARD=value
     /WILDCARD=none     
     /WILDCARD=standard
     /WILDCARD=extended
     This qualifier decides how 'mask' should match the output line
     If you only specify /wildcard, the /wild=standard is default
     If you do not specify /wildcard, 'mask' must occur in the line

   /REVERSE           Print only the line that do not match 'mask'

   /HIGHLIGHT=(flag[,flag...)
   /CASE_SENSITIVE    'mask' is matched in a case sensitive way
 

   The /highlight flags are used only when /wildcard=none and can be 
     BLINK
     UNDERLINE
     BOLD
     REVERSE
  
  If an output filter is set, only text that match "text" (or not if /reverse)
    will be printed

  See also the GREP command 
  
</pre>
<a name="753">
<h3 Align=center><a href="dix_help_idx_4.html#484" target="index">DIX INTERACTIVE_COMMANDS SET OVERFLOW </a> </h3>
<pre>
  
  Set overflow enabled|on|disabled|off

   Set or clear the overflow enable flag
   If the flag is cleared, DIX will not abort on overflow detection
   You will still be able to test for overflow via the
   %overflow special symbol, or via the ON OVERFLOW command

</pre>
<a name="754">
<h3 Align=center><a href="dix_help_idx_4.html#485" target="index">DIX INTERACTIVE_COMMANDS SET PAGED_MODE </a> </h3>
<pre>
   SET PAGED NO
   SET PAGED YES
   SET PAGED SCREEN

   Set/clear the paged mode for output. Page_mode screen will display
   the text in a window to allow easy scrolling (Uses SMG)

</pre>
<a name="755">
<h3 Align=center><a href="dix_help_idx_4.html#486" target="index">DIX INTERACTIVE_COMMANDS SET PIPE_MODE </a> </h3>
<pre>
  SET PIPE_MODE ON|ENABLED|YES
  SET PIPE_MODE OFF|DISABLED|NO

   If you start a line with a ; DIX will assume there are multiple
   commands on the command line, separated by ;.

   If you enable PIPE_MODE, you need not start the command line with
   a ;. The occurrence of a ; somewhere in the command line will
   automatically start pipeing commands.  Since ; can also occur in
   filenames, there is a bit of ambiguity. DIX will check if the next 
   character after the ; is a - or a 0..9. If that is true DIX will 
   assume the ; to be a part of the filename. Specifying a filename
   with an empty version line type a.a; will be seen as a pipe command.

</pre>
<a name="756">
<h3 Align=center><a href="dix_help_idx_4.html#487" target="index">DIX INTERACTIVE_COMMANDS SET EXPRESSION_PARSE </a> </h3>
<pre>
  SET EXPRESSION_PARSE ON|ENABLED|YES
  SET EXPRESSION_PARSE OFF|DISABLED|NO

  IF you enable expression_parse, and you type a command that does
  not have a valid syntax, DIX will try to evaluate it as an expression.

  Example
  DIX&GT;DISABLE expre   !is the default
  DIX&GT;10*10
  syntax error
  DIX&GT;ENABLE expre    !set the flag
  DIX&GT;10*20  !just type an expression, DIX will first try to parse as a 
  200        !command, and if that fails, it will evaluate the value.

</pre>
<a name="757">
<h3 Align=center><a href="dix_help_idx_4.html#488" target="index">DIX INTERACTIVE_COMMANDS SET PREFIX </a> </h3>
<pre>

  SET PREFIX Prefixstringexpression

  The prefix for the verify mode of scripts.
  See also the f$environment("verify_prefix") function

</pre>
<a name="758">
<h3 Align=center><a href="dix_help_idx_4.html#489" target="index">DIX INTERACTIVE_COMMANDS SET PROCESS </a> </h3>
<pre>

  Set process/name=Newname
     CHange the process name. THis can be useful during a long script
     to show the world how far we are.

  Set process/priority=Newprio
     Change the process priority. The original process priority will be
     restored when DIX exits.

  Set process/privileges=(name[,name...])
     Change the process privileges  
      name can be any of the normal privilege names or ALL, and may be negated
     DIX will change the "image"-privileges, so the original  privileges will
     be restored when DIX exits.
</pre>
<a name="759">
<h3 Align=center><a href="dix_help_idx_4.html#490" target="index">DIX INTERACTIVE_COMMANDS SET PROMPT </a> </h3>
<pre>
  Change the default prompt.

  SET PROMPT string
   If the string contains a # sign, this # will be replaced by _level
   if the commandfile depth is &GT;1
   The default prompt is DIX#&GT;, which will be
     DIX&GT;   at level 1
     DIX_1&GT; at level 2 etc.

</pre>
<a name="760">
<h3 Align=center><a href="dix_help_idx_4.html#491" target="index">DIX INTERACTIVE_COMMANDS SET QUOTED </a> </h3>
<pre>
   SET QUOTED ENABLED|YES|ON      
   SET QUOTED DISABLED|NO|OFF     (default)

   Sets the way DIX will output strings.
   By default DIX will only print the contents of the string, but
   if you enable the setting, DIX will put quotes around the contents

   Example
  
   DIX&GT;a="new string"			!fill a string
   DIX&GT;say a            		!evaluate it
   new string           		!no quotes
   DIX&GT;sh quo           		!show the quote setting
   Print quoted set to : No(disabled)   !it is disabled
   DIX&GT;set quoted ena                   !set to enabled
   DIX&GT;say a                            !and evaluate again
   "new string"                         !and now with quotes

   And now (a maybe more useful) example for a table of strings

   DIX&GT;DIX&GT;a=["f","b"]			!now for a table
   DIX&GT;say a				!and eval
   ["f","b"]                            !with quotes
   DIX&GT;set quoted dis                   !disable quote setting
   DIX&GT;say a                            !and again
   [f,b]                                !now only the contents


</pre>
<a name="761">
<h3 Align=center><a href="dix_help_idx_4.html#492" target="index">DIX INTERACTIVE_COMMANDS SET REAL </a> </h3>
<pre>

   SET REAL commands
   SET REAL FORMAT/SIZE=n[/default] format 
   SET REAL SKIP_TRAIL [/NOSKIP_TRAIL]
   SET REAL FIXED [/NOFIXED]
 
  SET REAL FORMAT[/size=n] [/default] format

    Set the format for conversion. This format is the normal fortran
    real format specification, (Fn.m, En.mEe, Gn.mEe).

    n is maximum field width
    m is the number of digits after the decimal.
    e is the number of digits in the exponent (default 2).
 
    See the Fortran manual for more detail.

    /SIZE=n : set the format for size=n (n=4,8,16)
    /DEFAULT: set the format back to the default

    The default formats are 
     size
      4   g20.8
      8   g25.10e3
      16  g30.15e4

  SET REAL [NO]SKIP_TRAIL /SIZE=n
    /SIZE=n : set/clear the SKIP_TRAIL flag for size=n (n=4,8,16), if you
              do not specify /size, all sizes are changed
  
   By default DIX  wil remove trailing zero's in the reals (at least
    after the decimal point) and the leading zeros in the exponent. 
    This means that the text size may be shorter than the size specified 
    by the format(but it is more readable).
   Specifying SET REAL NOSKIP_TRAIL/size=n will stop this.

  SET REAL [NO]FIXED /SIZE=n
    /SIZE=n : set/clear the FIXED flag for size=n (n=4,8,16), if you
              do not specify /size, all sizes are changed
  
   By default DIX  wil remove spaces.
    This means that the text size may be shorter than the size specified 
    by the format(but it is more readable).
   Specifying SET REAL FIXED/size=n will stop this.
 
   example
    DIX&GT;REAL*16 test=1.0q20
    DIX&GT;say test
    0.1E21
    DIX&GT;Set real noskip/size=16
    0.100000000000000E+0021

</pre>
<a name="762">
<h3 Align=center><a href="dix_help_idx_4.html#493" target="index">DIX INTERACTIVE_COMMANDS SET SCREEN_MODE </a> </h3>
<pre>

   Change mode to full-screen mode. DIX will be using SMG routines
   to display data.

</pre>
<a name="763">
<h3 Align=center><a href="dix_help_idx_4.html#494" target="index">DIX INTERACTIVE_COMMANDS SET SEARCH </a> </h3>
<pre>
  
   Set search[/name=patternname] search_options

   Change the search flags.
   You can specify more than one search_patterns. If you do not
    specify the /name, DIX will use a default search_pattern (DEFAULT).
    The name can be used in the search/name command.

   You can also attach a search pattern to a file (set file/sear=name).
    After attaching a search pattern, any record selection command like
    NEXT RECORD or PREV record or READ/KEY/REC will only find records
    matching the search pattern.

   The search flags can be set like the settings on the command line.
   See the help about  [DIX/help] Record_searches

  Example for file search

  $ DIX /INT SYSUAF
  DIX&GT; SET SEARCH TCPIP[/NAME=MYNAME]    !Define a search pattern to look for
                                         ! records containing TCPIP
  DIX&GT; SET FILE [SYSUAF]/SEARCH[=MYNAME] !attach the search pattern to the file
  DIX&GT; NEXT RECORD                       !search the next record containing TCPIP
  DIX&GT; NEXT RECORD			 !search the next record containing TCPIP
  DIX&GT; PREV RECORD			 !search the previous record containing TCPIP
   
</pre>
<a name="764">
<h3 Align=center><a href="dix_help_idx_4.html#495" target="index">DIX INTERACTIVE_COMMANDS SET STATISTICS </a> </h3>
<pre>
 
  Set statistics/[no]usage

  Set DIX to display a control_t like statistics line after each command.

  Example
    DIX&GT;set stat/usage
    ELAPSED:    0 00:00:00.00  CPU: 0:00:00.00  BUFIO: 0  DIRIO: 0  FAULTS: 0
    DIX&GT;sh symb a
    ELAPSED:    0 00:00:00.00  CPU: 0:00:00.00  BUFIO: 0  DIRIO: 0  FAULTS: 9
    DIX&GT;Set stat/nousage
  
</pre>
<a name="765">
<h3 Align=center><a href="dix_help_idx_4.html#496" target="index">DIX INTERACTIVE_COMMANDS SET STRICT </a> </h3>
<pre>

  Normally DIX is not very strict in the symbol handling.
  You can define new symbols by typing
  1. a=10 (define the symbol a , type integer, value 10)
  and then say
  2. a="SKLFG" (redefine a to type character, value "SKLFG"

  DIX has two levels of more strict behaviour
  /TYPING      : Once a symbol is created, you cannot change the type anymore
                  In the example above you can do 1. but not 2.
  /DECLARATIONS: All symbols have to be declared before usage
                 This also disallows calling subroutines or @ files
                   and not having the same number of arguments 
                   defined and declared. See the ENTRY statement. 
  /LOCAL       : Even with /DECLARATIONS, symbols from an outer level
                  can be used. With /LOCAL this is not allowed.

</pre>
<a name="766">
<h3 Align=center><a href="dix_help_idx_4.html#497" target="index">DIX INTERACTIVE_COMMANDS SET SUBSTITUTION </a> </h3>
<pre>

  Set substitution [/qualifiers]
  

  Change the way how DIX uses substitution

   /none               : disable all symbol substitutions

   /[no]VERB           : try to substitute the verb (like dcl does)

  THe /SYMBOL defines the symbol substitution in the command line

   /NOSYMBOLS          : Do not substitute 'text' to the value of symbol text
   /SYMBOLS=QUIET      : Try to substitute 'text' to the value of symbol text
                         If it fails, remove the '' part and do not signal
   /SYMBOLS=SIGNAL     : Try to substitute 'text' to the value of symbol text
                         If it fails, signal an error
   /SYMBOL=TRY         : Try to substitute 'text' to the value of symbol text
                         If it fails,do not remove the '' part and do not signal

   If you enter /SYMBOL without a value, DIX will
    use /SYMBOL=SIGNAL in DIX mode
    and /SYMBOL=QUIET  in DCL mode

  The /DESCRIPTION defines the symbol substitution in the descriptions

   /NODESCRIPTIONS     : Do not substitute 'text' to the value of symbol text
   /DESCRIPTIONS=QUIET : Try to substitute 'text' to the value of symbol text
                         If it fails, remove the '' part and do not signal
   /DECRIPTIONS=SIGNAL : Try to substitute 'text' to the value of symbol text
                         If it fails, signal an error
   /DESCRIPTIONS=TRY   : Try to substitute 'text' to the value of symbol text
                         If it fails,do not remove the '' part and do not signal

   If you enter /DESCRIPTIONS without a value DIX will use /DESCRIPTIONS=SIGNAL

  The default setting is

  /VERB/SYMBOL[=SIGNAL]/DESCRIPTIONS=QUIET in DIX mode and
  /VERB/SYMBOL=QUIET   /DESCRIPTIONS=QUIET in DCL mode

  
</pre>
<a name="767">
<h3 Align=center><a href="dix_help_idx_4.html#498" target="index">DIX INTERACTIVE_COMMANDS SET SYMBOL </a> </h3>
<pre>
    
    SET SYMBOL /scope=([no]local,[no]global)
     Set symbol scoping (like DCL)

    SET SYMBOL mask/[no]readonly	Set or Reset readonly flag
  
    SET symbol mask/type=typename

  Associate a symbol with a fieldname string
  fieldnamestring is 
    1. a string containing a valid fieldname list
    2. a string containing "#TYPENAME"
        where TYPENAME is a type containing a valid fieldnames list
  This allows you to input values with names see example


   DIX&GT; add TYPE mynames="0=NULL,255=ALL"
   DIX&GT; set symbol test/type=mynames
   DIX&GT;sh symb/fu test
   TEST(Integer*4,Level=1.0)=5
     Type : #MYNAMES (0=NULL,255=ALL)

   A more useful examples
   DIX&GT; ADD TYPE Weekdays="0=sunday,1=monday,2=tuesday,3=wednesday,"+-
                      "4=thursday,5=friday,6=saturday"
   DIX&GT; set symbol day/type=#weekdays
   DIX&GT;day = saturday
   DIX&GT;sh symb day
   DAY=saturday
   DIX&GT;say day
   6
</pre>
<a name="768">
<h3 Align=center><a href="dix_help_idx_4.html#499" target="index">DIX INTERACTIVE_COMMANDS SET SUBFIELD_SEPARATORS </a> </h3>
<pre>
   set subfield_separators xy

   Set the characters for subfield specification
   x  is the opening character, y is the closing character
   Default is {}
   x and y must be different and not be any of  a-z or , or 0-9 or /

  Example
   dix&GT; a=12
   dix&GT; say a{*}
   [0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
   dix&GT; set subfield=[]
   dix &GT; say a[*]
   [0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]

</pre>
<a name="769">
<h3 Align=center><a href="dix_help_idx_4.html#500" target="index">DIX INTERACTIVE_COMMANDS SET TABLE_SEPARATORS </a> </h3>
<pre>
   set table_separators xy

   Set the characters for table displays
   x  is the opening character, y is the closing character
   Default is []
   x and y must be different and not be any of  a-z or , or 0-9 or /


  Example
   dix&GT; a=[1,2,3]
   dix&GT; say a
   [1,2,3]
   dix&GT; set table={}
   dix &GT; say a
   {1,2,3}


</pre>
<a name="770">
<h3 Align=center><a href="dix_help_idx_4.html#501" target="index">DIX INTERACTIVE_COMMANDS SET TERMINAL </a> </h3>
<pre>
 
   SET terminal /[no]line_editing
      Enable/disable line editing. In line_editing mode the function keys
      F6-F14 cannot be used for key definitions.

   SET terminal /[no]broadcast            Set /clear the broadcast flag
   SET terminal /[no]application_keypad   Set keypad state
   SET terminal /[no]insert               Set/clear insert mode
   SET terminal /[no]overstrike           Set the default insert/overstrike flag

   SET terminal /width=nn   (nn must be between 40 and 132)
      Change the terminal width
   
   SET terminal/page=nn
      change the pagesize of the terminal

  Normally DIX will use smg$ routines to read input.
  DIX has two more enhanced input methods (on terminal input only)

  a./EXTENDED_INPUT : Allows you to edit your command line over more than
                      one line on the terminal.
  b./AUTO_INPUT     : Uses the DIX cld tables to automatically expand
                      verbs, qualifier and values.

</pre>
<a name="771">
<h3 Align=center><a href="dix_help_idx_5.html#750" target="index">DIX INTERACTIVE_COMMANDS SET TERMINAL EXTENDED_INPUT </a> </h3>
<pre>

   SET TERMINAL/[NO]EXTENDED_INPUT/[NO]ARROW_REALL

     Switch to (or from) extended input mode.
     In normal mode, DIX will use the SMG$read_composed_line routine to
      handle input. 
     In extended input mode, DIX will process input itself, and allows you
      to edit a command line even if it stretches along multiple lines
      on the screen. You may use the Up/Down arrow to move between te lines
      on the screen. If you want to use command recall you must use
      PF1-Up/Down arrow (first press pf1, and then up/down arrow).
 
      You can even search in the DIX help for the first keyword 

      If you specify /ARROW_RECALL, DIX will inverse the usage 
        of the the up/down arrows.
         Without pf1 : command line recall
         With pf1    : positioning within the current input line(s)

    Supported keys during line editing

          Right arrow/^F : Go 1 position to the right
      PF1-Right arrow/^F : Go 1 word to the right
          Left arrow/^D  : Go 1 position to the left
      PF1-Left arrow/^D  : Go 1 word to the left
          Up arrow       : If arrow_recall: recall the previous line
                           else : goto the previous line on this input
      Pf1-Up arrow       : If arrow_recall: goto the previous line on this input
                                      else: recall the previous line
          Down arrow     : If arrow_recall: goto the next line on this input
                                      else: recall the next line
      Pf1-Down arrow     : If arrow_recall: recall the next line
                                      else: goto the next line on this input
      Enter/Return       : Accept input
     ^Z/ F10             : Abort input
      PF2/HELP(F15)      : Display help about the first word on the line
      ^R/^W              : Reprint the line (f.e. after broadcast)
      ^L                 : Toggle the arrow_recall flag
      ^A/F14             : Toggle between insert/overstrike
      ^H/F12             : Goto the beginning of the line
      ^E                 : Goto the end of the line
      ^X/^U              : Erase line from cursor position to Eeginning of line
      ^J/F13             : Delete word to the left
      PF1-^J/F13         : Delete word to the right

    Note:
      PF1-xx means : First type PF1 and then the xx key
      The Fnn keys cannot be used if line_editing is disabled
        set term/noline_editing

</pre>
<a name="772">
<h3 Align=center><a href="dix_help_idx_5.html#751" target="index">DIX INTERACTIVE_COMMANDS SET TERMINAL AUTO_INPUT </a> </h3>
<pre>

  SET TERMINAL/AUTO_INPUT

  DIX will check on the typed characters to check if the build up line
  is a valid command. It makes use of the DIX_CLD CLD tables to check
  for each VERB, QUALIFIER, PARAMETER and VALUE if the string entered is
  correct and possible helps you complete it. 

  The following control_inputs are supported

  ^L : Display a list of possible inputs for the current token.
  F8   f.e. If you are entering a VERB (the first part of the command)
       DIX will display a list of all possible verbs that match the
       current part of a VERB.

       The same wil work for qualifiers.

       For parameters and values DIX has some nice enhancements
       a. If the value must be an inputfile, DIX will print a list of
          filenames matching the current string
       b. If the value must be a directory, DIX will print a list of
          directorynames matching the current string
       c. If the input is a list of privs, DIX will print a list of
          privilege names

   ^V       : Switch to extended input mode for this command. In AUTO_INPUT
               you can only enter commands, but f.e. not assignments.
               Typing ^V disables the checking for this line.

   TAB      : Replace the current string with the next match of a value
   PF1-TAB  : Replace the current string with the previous match of a value

   HELP     : DIX will show the help about the current (partial) verb
 
   DELETE   : Delete the charcter to the left of the cursor
   ^J of F13: Delete the current token
   ^U       : Delete the while command line
   ^A/F14   : Toggle insert/overstrike
   Left/Right Arrow
            : Move the cursor within the last token

  Since each qualifier or value can provoke a syntax change (see the VMS manual
   "Command definition, Librarian and Message Utilities manual" for the
   meaning of a syntax switch), you cannot move the cursor to a position
   before the current token. You can of course delete characters/tokens.
 
</pre>
<a name="773">
<h3 Align=center><a href="dix_help_idx_4.html#502" target="index">DIX INTERACTIVE_COMMANDS SET VERIFY-NOVERIFY </a> </h3>
<pre>
 
  Set verify  	Set verify mode on for image and procedure data
   set verify=([no]procedure,[no]image)
                set / clear verify settings for image/procedure 

  Set noverify  Clear verify mode (is the same as set ver=(noprocedure,noimage)

  In verify mode all (data) lines read from the command procedure are echo'd to
  the terminal.

  See also the f$environment("verify_..") function

</pre>
<a name="774">
<h3 Align=center><a href="dix_help_idx_4.html#503" target="index">DIX INTERACTIVE_COMMANDS SET WILDCARD </a> </h3>
<pre>
 
  SET WILDCARD NONE
  SET WILDCARD STANDARD
  SET WILDCARD EXTENDED

  Set the default wildcard setting.

   WILDCARD NONE     No wildcard matching is used.
   WILDCARD STANDARD The following wildcard characters can be used
            *     : matches all substrings (0 or more chars)
            %     : matches exactly 1 char
   WILDCARD EXTENDED The Following extended wildcard characters can be used
            [abc] : Matches a "a" or a "b" or a "c"
            [-abc]: Matches anything except a,b,c
            [a-z] : Matches all letters (a-z)
            [-a-z]: Matches anything except letters
            'a    : Char "a" is not longer a special char ([*%' etc)
            ~     : If in front of the searchstring , the searchstring must be in the
                    beginning of the line, if at the end of the searchstring,
                    the searchstring must be at the end of the line
            !     : Matches one or more whitespace chars

</pre>
<a name="775">
<h3 Align=center><a href="dix_help_idx_3.html#199" target="index">DIX INTERACTIVE_COMMANDS SHOW </a> </h3>
<pre>

  Show all kind of things.

  SHOW File[/all][/full][/description]
                          Show file information
  SHOW FILE/PPF           Show ppf files (sys$output, sys$input, sys$command)
  SHOW FILE/MEM[/full]    Show memory files (from /output=mem:...)
    
  SHOW All                Show a lot of things

  SHOW Description        Show current description from internal datastructure
  SHOW Description/SOURCE Show current description from source file/module
  SHOW Description/EXPAND Show current expanded description 

  SHOW View               Show current view from internal datastructure
  SHOW View/SOURCE        Show current view from source file/module
  SHOW View/EXPAND        Show current expanded view
  SHOW default            Show the current default directory
  SHOW Parameter [mask]   Show parameters

  SHOW Symbols [mask] 	  Show defined symbols
  SHOW Display            Show default display parameters (HEX,Number,raw etc)
  SHOW Terminal           Show the terminal setting inclusive /[no]extended input
  SHOW Keyboard           Show current keyboard setting
  SHOW LIBRARIES          Show the current libraries (system and user)

  SHOW DCL_COMPATIBLE     SHow the current setting of the DCL_COMPATIBLE
                          setting (see the help about SET DCL_COMPATIBLE)  
  SHOW EVALUTAION_ORDER   Show the current evalution order.
  SHOW FORMAT             SHow the current binary translation mode

  SHOW LOGICAL            Show logicals  
  SHOW SEARCH             Show the current record search string(s)
  SHOW PROCESS            Show current or other process characteristics
  SHOW SUBSTITUTION       Show the current symbol substitution flag

  SHOW STRUCTURES         Show the current loaded structures  
  SHOW Message            Show the current message settings
  SHOW Paged              Show the current paged mode
  SHOW Decimal            Show the settings for decimal arithmetic

  SHOW quoted             Show the current quote setting
  SHOW statistics         Show the current state of the statistics flag
                              (see "set statistics")
  SHOW version            Show the current version of DIX
  SHOW real               Show the size /formats for the real symbols
  SHOW integer            Show the size /formats for the integer symbols

  SHOW Release_notes      Show the release notes

  show functions          Show defined functions

  SHOW SEARCH_PATTERNS    Show the defined search patterns
  For more info also see the set 'xxx' help.

</pre>
<a name="776">
<h3 Align=center><a href="dix_help_idx_4.html#505" target="index">DIX INTERACTIVE_COMMANDS SHOW All </a> </h3>
<pre>
   Show a lot of the show's

</pre>
<a name="777">
<h3 Align=center><a href="dix_help_idx_4.html#506" target="index">DIX INTERACTIVE_COMMANDS SHOW AUTO </a> </h3>
<pre>

  SHOW the AUTO setting.
  This setting decides if you will save the current settings 
  (open files/record and recall buffer) when you exit DIX.
  The EXIT and QUIT command also has the /[NO]AUTO to override this setting
</pre>
<a name="778">
<h3 Align=center><a href="dix_help_idx_4.html#507" target="index">DIX INTERACTIVE_COMMANDS SHOW DECIMAL </a> </h3>
<pre>

   Show decimal setting

</pre>
<a name="779">
<h3 Align=center><a href="dix_help_idx_4.html#508" target="index">DIX INTERACTIVE_COMMANDS SHOW DECWINDOWS </a> </h3>
<pre>

  Show decwindow setting

</pre>
<a name="780">
<h3 Align=center><a href="dix_help_idx_4.html#509" target="index">DIX INTERACTIVE_COMMANDS SHOW description_view </a> </h3>
<pre>

  Show the description or view information

  show descr [/qualifiers]

  show view  [/qualifiers]

</pre>
<a name="781">
<h3 Align=center><a href="dix_help_idx_5.html#760" target="index">DIX INTERACTIVE_COMMANDS SHOW description_view qualifiers </a> </h3>
<pre>
</pre>
<a name="782">
<h3 Align=center><a href="dix_help_idx_6.html#781" target="index">DIX INTERACTIVE_COMMANDS SHOW description_view qualifiers /all </a> </h3>
<pre>
  show description/all [mask]
 
  Display a list of descriptions in the current library(s) (matching mask)
  If the /source is also specified, DIX will display the source of the
  module(s).

</pre>
<a name="783">
<h3 Align=center><a href="dix_help_idx_6.html#782" target="index">DIX INTERACTIVE_COMMANDS SHOW description_view qualifiers /expanded </a> </h3>
<pre>
  show description/expanded

  Show the expanded descriptors for this record.
  You can use /FULL to display more info.  
</pre>
<a name="784">
<h3 Align=center><a href="dix_help_idx_6.html#783" target="index">DIX INTERACTIVE_COMMANDS SHOW description_view qualifiers /loaded </a> </h3>
<pre>
  show description/loaded 
  
  Show all loaded descriptions. If more than one file uses the same
  description, this description is loaded only one.

</pre>
<a name="785">
<h3 Align=center><a href="dix_help_idx_6.html#784" target="index">DIX INTERACTIVE_COMMANDS SHOW description_view qualifiers /full </a> </h3>
<pre>
  show description/full
 
  Show all info about the description. See the /source qualifier.
</pre>
<a name="786">
<h3 Align=center><a href="dix_help_idx_6.html#785" target="index">DIX INTERACTIVE_COMMANDS SHOW description_view qualifiers /source </a> </h3>
<pre>

  Show the original source of the description, instead of the
  interpreted one.

</pre>
<a name="787">
<h3 Align=center><a href="dix_help_idx_6.html#786" target="index">DIX INTERACTIVE_COMMANDS SHOW description_view qualifiers /paged </a> </h3>
<pre>
  Display the data per page (on terminal only)

</pre>
<a name="788">
<h3 Align=center><a href="dix_help_idx_6.html#787" target="index">DIX INTERACTIVE_COMMANDS SHOW description_view qualifiers /output </a> </h3>
<pre>
  /output=filename
  Print the output to the file "filename"
</pre>
<a name="789">
<h3 Align=center><a href="dix_help_idx_6.html#788" target="index">DIX INTERACTIVE_COMMANDS SHOW description_view qualifiers /SCREEN </a> </h3>
<pre>
 /SCREEN
 /NOSCREEN (Default)
  Display the data in an SMG window, that allows you to scroll through it.
  See also SET PAGED SCREEN
</pre>
<a name="790">
<h3 Align=center><a href="dix_help_idx_4.html#510" target="index">DIX INTERACTIVE_COMMANDS SHOW DISPLAY_MODE </a> </h3>
<pre>

  SHOW DISPLAY_MODE

  Show the current setting of the display mode.
</pre>
<a name="791">
<h3 Align=center><a href="dix_help_idx_4.html#511" target="index">DIX INTERACTIVE_COMMANDS SHOW EDITOR </a> </h3>
<pre>

  SHOW EDITOR

  Show the current setting of the editor type.
</pre>
<a name="792">
<h3 Align=center><a href="dix_help_idx_4.html#512" target="index">DIX INTERACTIVE_COMMANDS SHOW EVALUATION_ORDER </a> </h3>
<pre>

   SHOW EVALUATION_ORDER

   Show the current setting of the evaluation order

   When locating a name, DIX can search trough various lists.

    1. The list of symbols
    2. The list of all values/parameters
    3. The list of fieldnames (if a file is open)

   Normally DIX will search the lists in above order, but you can change
   it. The SHOW EVALUATION_ORDER can change the order
 
  Example
   SHOW EVA
    DIX&GT;sh eva		!show the current setting
    Evaluation order set to :Parameter,Field,Symbol
    DIX&GT;set eval s,f,p	!change the order
    DIX&GT;sh eva
    Evaluation order set to :Symbol,Field,Parameter
    DIX&GT;set eval p	!make sure parameter is in front
    DIX&GT;sh eva          !symbol and field remain in the same order
    Evaluation order set to :Parameter,Symbol,Field

  
</pre>
<a name="793">
<h3 Align=center><a href="dix_help_idx_4.html#513" target="index">DIX INTERACTIVE_COMMANDS SHOW FILE </a> </h3>
<pre>

  Show file [/qualifiers] [mask]
 
  Show the file information

</pre>
<a name="794">
<h3 Align=center><a href="dix_help_idx_5.html#765" target="index">DIX INTERACTIVE_COMMANDS SHOW FILE qualifiers </a> </h3>
<pre>
</pre>
<a name="795">
<h3 Align=center><a href="dix_help_idx_6.html#794" target="index">DIX INTERACTIVE_COMMANDS SHOW FILE qualifiers /all </a> </h3>
<pre>
  show file/all
 
  Display a list of all opened files. The current file
  is signalled by an * in the first column.

</pre>
<a name="796">
<h3 Align=center><a href="dix_help_idx_6.html#795" target="index">DIX INTERACTIVE_COMMANDS SHOW FILE qualifiers /file </a> </h3>
<pre>
  Normally the mask is matched against the tag of the opened files.
  If you specify /file, DIX wil match the mask against the files on disk.
  Examples:

  dix/int sysuaf

  DIX&GT;show file
  C TAG    Type    Filename                                   Size
  * SYSUAF IDX     KXSYS_DISK:[VMS_COMMON.SYSEXE]SYSUAF.DAT;2   72
  * means the current file

  DIX&GT;show file sysuaf/file
  Type    Filename                                   Size
  IDX     KXSYS_DISK:[VMS_COMMON.SYSEXE]SYSUAF.DAT;2   72

  In the second example there is no tag, indicating that the file in
  not a DIX opened file, but found on via lib$find_file

</pre>
<a name="797">
<h3 Align=center><a href="dix_help_idx_6.html#796" target="index">DIX INTERACTIVE_COMMANDS SHOW FILE qualifiers /full </a> </h3>
<pre>
  show file/full
 
  Show all info about the file(s).

  Below is an example for sysuaf
 DIX&GT;sh file/fu
 C TAG    Type    Filename                                   Size
 * SYSUAF IDX     KXSYS_DISK:[VMS_COMMON.SYSEXE]SYSUAF.DAT;2   72
 Information about file KXSYS_DISK:[VMS_COMMON.SYSEXE]SYSUAF.DAT;2
 File
  Opened for       : Normal IO,Fast IO(default)
   Fast Blocksize  : 1024
   Fast Multibuffer: 4
  Organization     : Indexed
  Lock mode        : Normal
  Record format    : Variable
  Creation   date  : 25-NOV-2003 17:01:26.28
  Expiration date  :  5-FEB-2007 08:15:44.15
  Backup     date  : &LT;No backup recorded&GT;
  Revision   date  :  9-AUG-2006 08:15:44.15
  File id          : (66004,27,0)
  File owner       : [SYSTEM] = [1,4]
  File protection  : S:RWED, O:RWED, G:RE, W:
  Globalbuffercount:          0
 Record
  Record attribute : NONE
  Max record size  :       1412
  Longest record   :          0
 Allocation
  EOF block        :         72 (FFB =    0)
  Allocated blocks :         72
  Bucketsize       :          3
 Areas
  Area Allocation bucketsize  extension
     0         72          3         10
 Keyinformation
            D C I K D  N               ..INDEX. ..DATA..
   Nr Type  u h c c c  u Lvl   Pos Siz Area Bkt Area Bkt Field
            p g p p p  l                 Nr siz   Nr siz
    0 STG   N N Y Y Y NO   1     4  32    0   3    0   3 UAF$T_USERNAME
    1 BIN4  Y Y N N N NO   1    36   4    0   3    0   3 UAF$W_MEM,UAF$W_GRP,UAF
                                                         $L_UIC
    2 BIN8  Y Y N N N NO   1    36   8    0   3    0   3 UAF$W_MEM,UAF$W_GRP,UAF
                                                         $L_UIC,UAF$L_SUB_ID
    3 BIN8  Y Y N N N NO   1    44   8    0   3    0   3 UAF$Q_PARENT_ID(1),UAF$
                                                         Q_PARENT_ID(2)
 * means the current file
 
  The tags in the keyinformation are
    Nr  : the key number
    Type: the key type (Descending keys have D in front)
    Dup : This key allows duplicate
    Chg : THis key is changeable
    Icp : Key values are compressed in index buckets
    Kcp : Key values are compressed in data buckets
    Dcp : Data values are compressed (in data buckets)
    Lvl : Het tree depthe for index buckets
    Pos : the starting position of the key (multiple lines if more segments)
    Siz : the size of the key (multiple lines if more segments)
    Index:
     Area_nr : The area for the index buckets
     Bktsize : the bucket size for the index buckets
    Data:
     Area_nr : The area for the data buckets
     Bktsize : the bucket size for the data buckets

    Field : Description fieldnames that overlap with this key.

</pre>
<a name="798">
<h3 Align=center><a href="dix_help_idx_6.html#797" target="index">DIX INTERACTIVE_COMMANDS SHOW FILE qualifiers /limit </a> </h3>
<pre>
  Show the limit value/record number for this file
  See the DIX/LIMIT qualifier for more info

</pre>
<a name="799">
<h3 Align=center><a href="dix_help_idx_6.html#798" target="index">DIX INTERACTIVE_COMMANDS SHOW FILE qualifiers /paged </a> </h3>
<pre>
  Display the data per page (on terminal only)

</pre>
<a name="800">
<h3 Align=center><a href="dix_help_idx_4.html#514" target="index">DIX INTERACTIVE_COMMANDS SHOW FIND </a> </h3>
<pre>

  Show find
   Display the find/search settings
   This is an alias for show search

</pre>
<a name="801">
<h3 Align=center><a href="dix_help_idx_4.html#515" target="index">DIX INTERACTIVE_COMMANDS SHOW FORMAT </a> </h3>
<pre>

  show format

  Show the way DIX will display binary data in strings

</pre>
<a name="802">
<h3 Align=center><a href="dix_help_idx_4.html#516" target="index">DIX INTERACTIVE_COMMANDS SHOW FUNCTIONS </a> </h3>
<pre>

  Show functions [mask] [qualifiers]

  Show the defined functions matching mask

  Supported qualifiers are

   /FULL   : display more info about the function
   /SOURCE : Display the source code

</pre>
<a name="803">
<h3 Align=center><a href="dix_help_idx_4.html#517" target="index">DIX INTERACTIVE_COMMANDS SHOW DCL_COMPATIBLE </a> </h3>
<pre>

  Show the current setting for DCL_COMPATIBLE

   Since the DIX syntax looks very much the same as the DCL syntax, you may
   want to use DCL procedures. But in those procedures each command starts with
   a $. If you set DCL_COMPATIBLE to enable, DIX will remove the first $ from
   each line (if it is there), and also replace the DCL comparison operators
   by the DIX equivalents, allowing you to use the file as (DIX-)command file. 
   Also the DCL comparison operators (.eq(s)., .gt(s) etc.) are replaced by
   the DIX versions =,&GT; etc.
 
</pre>
<a name="804">
<h3 Align=center><a href="dix_help_idx_4.html#518" target="index">DIX INTERACTIVE_COMMANDS SHOW KEYBOARD </a> </h3>
<pre>

  Show the keyboard setting
    Normal/pc/laptop

</pre>
<a name="805">
<h3 Align=center><a href="dix_help_idx_4.html#519" target="index">DIX INTERACTIVE_COMMANDS SHOW KEYS </a> </h3>
<pre>

  SHOW KEYS [key] [/STATE=state]
   Display the (interactivemode) key definitions or 
           the definition for key "key"
           [with state="state"]

  SHOW KEYS/DIRECTORY
   Display all IF_STATES
</pre>
<a name="806">
<h3 Align=center><a href="dix_help_idx_4.html#520" target="index">DIX INTERACTIVE_COMMANDS SHOW LOGICAL </a> </h3>
<pre>

   show logical [name] [/qualifiers]

      

    Supported qualifiers
     which table
       /cluster
       /system
       /group
       /job
       /process
       /table=tablename

    /access_mode=(executive,supervisor,user)
   /structure
   /descendants

   /output=file
   /screen
   /width=nn
 
   If name is specified and does not contain a wildcard, and table does
   not contain a wildard and not descendants and not structure
   DIX can display the logicals. If any of the above is not valid, DIX
   will spawn a subprocess to display the logicals. In this case the
   following is true
      For now the exec mode logicals from a process private logicalname
      table cannot be displayed, since inner mode logicals are not copied 
      to the subprocess

   So : If mylog is defined in the process table with exec mode:
         DIX&GT; SHOW LOG mylog   : display the logical correctly
         DIX&GT; SHOW LOG mylog*  : DIX will spawn a subprocess and will not 
                                 display mylog

</pre>
<a name="807">
<h3 Align=center><a href="dix_help_idx_4.html#521" target="index">DIX INTERACTIVE_COMMANDS SHOW MESSAGE </a> </h3>
<pre>

  Show the message settings

</pre>
<a name="808">
<h3 Align=center><a href="dix_help_idx_4.html#522" target="index">DIX INTERACTIVE_COMMANDS SHOW MOUSE </a> </h3>
<pre>

  Show the state of the mouse for screen(SMG) displays.

  If the state is ON, DIX will interpreted the mouse, and so disallowing
   the mouse to select a piece op text on the screen.

  if the state is off, DIX(SMG) will use it to position in a window


</pre>
<a name="809">
<h3 Align=center><a href="dix_help_idx_4.html#523" target="index">DIX INTERACTIVE_COMMANDS SHOW OVERFLOW </a> </h3>
<pre>

  Show overflow
   
  Show the current setting for the overflow flag

</pre>
<a name="810">
<h3 Align=center><a href="dix_help_idx_4.html#524" target="index">DIX INTERACTIVE_COMMANDS SHOW PAGE_MODE </a> </h3>
<pre>

  SHOW PAGE_MODE

  Show the current setting of the paging mode.
  
</pre>
<a name="811">
<h3 Align=center><a href="dix_help_idx_4.html#525" target="index">DIX INTERACTIVE_COMMANDS SHOW PARAMETERS </a> </h3>
<pre>

  Show parameters [mask] [/hex] [/name_only] [/statistics]
                  [/level=n][/global][/all]

  Show all parameters of the current description.
  global  : show global parameters
  all     : show parameters for all levels
  level=n : show parameters for level n
     n can be  1..current command level
       or     -1..-n  N levels up

   Default command level is the current command level


</pre>
<a name="812">
<h3 Align=center><a href="dix_help_idx_4.html#526" target="index">DIX INTERACTIVE_COMMANDS SHOW PROCESS </a> </h3>
<pre>
   Show process [qualifiers] [/IDENT=PID] [name]
  
   Show process info. Either by PID or by name
   If neither is specified, the current process is used
   
  Qualifiers can be

   /ALL        : Show all info
   /name       : Show process name
   /privileges : Show process privileges
   /priority   : Show process priority
   /quota      : Show process quota

   /continuous : Use a smg display to continuously show a
                 lot of process information.

   In the /continuous mode you cvan specify nome of the 
   qualifiers above, but you can use the following
    /INTERVAL=nseconds : May be specified as 0 (default is 1)
    /COLOURS=ncol      : Highlight the values with a differecnt colour 
                         if changed in the last 'ncol' intervals.
                         The default is 1(bolding)

</pre>
<a name="813">
<h3 Align=center><a href="dix_help_idx_4.html#527" target="index">DIX INTERACTIVE_COMMANDS SHOW PREFIX </a> </h3>
<pre>

  Show the current prefix setting
  See also the f$environment("verify_prefix") function

</pre>
<a name="814">
<h3 Align=center><a href="dix_help_idx_4.html#528" target="index">DIX INTERACTIVE_COMMANDS SHOW REAL </a> </h3>
<pre>


  Show real size, ship_trail flag, type and format for real conversions.
  The skup_trail flag and formats can be changed via the SET REAL command.

  The datatypes depends on the architecture (see table)
         Size
   Arch   4         8     16
   Vax    REAL_F REAL_D REAL_H
   Alpha  REAL_F REAL_G REAL_X
   IA64   REAL_S REAL_T REAL_X
 
  example

  DIX&GT; show real
   Size  4 SKIP   type REAL_F format (G20.8)
   Size  8 SKIP   type REAL_G format (G25.10E3)
   Size 16 SKIP   type REAL_X format (G30.15E4)


</pre>
<a name="815">
<h3 Align=center><a href="dix_help_idx_4.html#529" target="index">DIX INTERACTIVE_COMMANDS SHOW Release_notes </a> </h3>
<pre>

  Display the release notes

  show release_notes [/page]

   Show all release notes

  show release_notes/version

   Show all versions with their release dates without the contents
  
  show release_notes/version=d.d-d

   Show the release_notes for version
   The version can be entered as d     (Only major version)
                              or d.d   (major.minor version)
                              or d.d-d (major,minor,patch release)
</pre>
<a name="816">
<h3 Align=center><a href="dix_help_idx_4.html#530" target="index">DIX INTERACTIVE_COMMANDS SHOW SEARCH </a> </h3>
<pre>

  Show search 
   Display the find/search settings
   This is an alias for show find
</pre>
<a name="817">
<h3 Align=center><a href="dix_help_idx_4.html#531" target="index">DIX INTERACTIVE_COMMANDS SHOW SKEYS </a> </h3>
<pre>

  Show the key definitions for the screen mode.
  They can be defined with the define/skey command.
  The default key setting is described in the help about key_mapping.

</pre>
<a name="818">
<h3 Align=center><a href="dix_help_idx_4.html#532" target="index">DIX INTERACTIVE_COMMANDS SHOW STRICT </a> </h3>
<pre>

  SHOW STRICT

  Show the current setting of the strictsetting.

</pre>
<a name="819">
<h3 Align=center><a href="dix_help_idx_4.html#533" target="index">DIX INTERACTIVE_COMMANDS SHOW STRUCTURES </a> </h3>
<pre>
   show structures [/quals] [mask]

  Show the loaded structure definitions.
  By default all structure definitions are shown that are reachable.
  A structure definition with the same name as a definition at a deeper level
  will not be shown (unless the /ALL qualifier is specified).

  Mask is a wildcard match (default is *)
  qualifiers are

  /GLOBAL : Only show  globally loaded structures
  /LEVEL=n: Show structures loaded at level n
            n can be 1..n   Absolute level 1..n 
                     -1..-n n levels up
  /ALL    : Show structures at all levels

  /FULL   : SHow more info: All declared fields
  /SOURCE : Show the source of the structure file/module

</pre>
<a name="820">
<h3 Align=center><a href="dix_help_idx_4.html#534" target="index">DIX INTERACTIVE_COMMANDS SHOW SUBSTITUTION </a> </h3>
<pre>

  Show the current setting of the symbol substitution

   VERB        : try to substitute the verb (like dcl does)
   SYMBOLS     : Try to substitute 'text' to the value. If the expression
                  fails, DIX will signal an error if /SYMBOL=SIGNAL, and
                  will quietly remove the '' if /SYMBOL=QUIET
   DESCRIPTION : Try to substitute 'text' to the value. If the expression
                  fails, DIX will signal an error if /DESCRIP=SIGNAL, and
                  will quietly remove the '' if /DESCRIP=QUIET
                  Symbol substitution will be done during the read of the
                  description. Future expansion of this description will not
                  change the symbolvalue. You can reread the description
                  via the REREAD DESCRIPTION MASK

</pre>
<a name="821">
<h3 Align=center><a href="dix_help_idx_4.html#535" target="index">DIX INTERACTIVE_COMMANDS SHOW symbols </a> </h3>
<pre>

  show symbol/scope  Sbhow current setting of symbol scoping
 
  Show symbols[/hex][/decimal][/octal][/binary][/all] -
      [/all_levels][/nospecials] mask

  The qualifiers must be specified before the mask

  Display all defined symbols [in hex, decimal, octal or binary]
  Default is decimal display, but the $status symbol will be displayed
   in hex by default (and may be overruled)

  If the symbol has dimensions, DIX will only display the individual
  elements if you specify /all also.

  The /nospecials will suppress the display of the build-in symbols
  
  The /all will display all symbols and is equivalent to a mask of *

  The /all_levels will display the symbol definition at all levels

  Show symbols/statistics[/full[/all]] [mask]
  Show statistical information about the symbol table

</pre>
<a name="822">
<h3 Align=center><a href="dix_help_idx_4.html#536" target="index">DIX INTERACTIVE_COMMANDS SHOW TERMINAL </a> </h3>
<pre>

  SHOW TERMINAL

  Show the current setting of the terminal settings.
</pre>
<a name="823">
<h3 Align=center><a href="dix_help_idx_4.html#537" target="index">DIX INTERACTIVE_COMMANDS SHOW TIME </a> </h3>
<pre>

   Show time                  Show date and time
   show time/date             Show date only
   show time/time             Show time only
   show time /boot            Show the boot date/tinme instead the current 
   show time/uptime           Show uptime (current-boot)

   Show the current,boot,up date and/or time 

</pre>
<a name="824">
<h3 Align=center><a href="dix_help_idx_4.html#538" target="index">DIX INTERACTIVE_COMMANDS SHOW TYPE </a> </h3>
<pre>

  Show types [mask] [/hex] [/name_only] [/statistics]

  Show all types (fieldnames for symbols)
    (description and global)

</pre>
<a name="825">
<h3 Align=center><a href="dix_help_idx_4.html#539" target="index">DIX INTERACTIVE_COMMANDS SHOW VERSION </a> </h3>
<pre>

   Show version [/all]

   Display the current DIX version
   Show the versions and creation dates of all dix modules


</pre>
<a name="826">
<h3 Align=center><a href="dix_help_idx_4.html#540" target="index">DIX INTERACTIVE_COMMANDS SHOW VALUES </a> </h3>
<pre>

  Show values [mask] [/hex] [/name_only] [/statistics]

  Show all values (modifyable parameters) 
    (description and global)

</pre>
<a name="827">
<h3 Align=center><a href="dix_help_idx_3.html#200" target="index">DIX INTERACTIVE_COMMANDS SPAWN </a> </h3>
<pre>
  SPAWN[/dix_symbol[=text][/echo][/outut=file][/page][/screen] [Commandline]

  Create a subprocess, and execute  'commandline'. If commandline is not
  present, you can enter commands interactively until you type LOGOUT.

  If /dix_symbol is present and has a value:
   If the output contains "text", the reset of the line will be 
   used for a symbol assignment. This allows you to transfer data from the
   command procedure to dix.
   the value of /dix_symbol is default #DIX#

  Suppose the procedure myproc.com contains the following commands

  $node = f$getsyi("nodename")
  $write sys$output "#DIX#node=""''node'"""
  $exit

  DIX&GT;spaw @myproc
  #DIX#node="DIXDEV"           !suppose the nodename is DIXDEV
  DIX&GT;show symb node
  %DIX-W-NOSUCHSYM, No such symbol NODE

  DIX&GT;spaw/dix_symbol @myproc
  #DIX#node="DIXDEV"            !suppose the nodename is DIXDEV
  DIX&GT;show symb node		!now the text node="DIXDEV" has been processed
  NODE="DIXDEV"                 !to define symbol node
 
  If /noecho is added, the line containing the definition is not printed

  DIX&GT;spaw/dix_symbol/noecho @myproc
  DIX&GT;show symb node		!now the text node="DIXDEV" has been processed
  NODE="DIXDEV"                 !to define symbol node

</pre>
<a name="828">
<h3 Align=center><a href="dix_help_idx_3.html#201" target="index">DIX INTERACTIVE_COMMANDS SUBSTITUTIONS </a> </h3>
<pre>

  DIX will try to do symbol-substitution.
  If a line contains a name enclosed in ''s, DIX will substitute the symbol
  by its value. If the symbol is not found, DIX will substitute an empty 
  string.

  In a String enclosed by "" the first ' must be a double one (as in DCL).
  Example

  cnt = 0
  Loop:
  examine field_'cnt'
  cnt = cnt + 1
  if (cnt &LT; 10) goto loop

  Will display field_1 up to field_10  

  Symbol substitution can be turned on or off with the 
  "set substitution /[no]verb/[no]symbols" command

</pre>
<a name="829">
<h3 Align=center><a href="dix_help_idx_3.html#202" target="index">DIX INTERACTIVE_COMMANDS SWITCH_CASE_ENDSWITCH </a> </h3>
<pre>

  This structure can be used the select a specific value
 
   SWITCH[/FALL_THROUGH] expression
     CASE value1
       statement(s)
     CASE[/FALL_THROUGH] value2
       statement
       statement
     CASE 
       statement(s)
    ENDSWITCH

  The first match is used, following matches will not be found. 
   Expression and value must be a valid (scalar) expression, and the
   types and sizes must match
  If no value is specified after the CASE (or the text
   is DEFAULT), this will be the default case.

  If /FALL_THROUGH is specified with the switch command, 
   all cases after the selected
   one are used (but not the default case). If /FALL_THROUGH
   is specified, and no case matches, the default case IS used
   and then all the following cases.
  If /FALL_THROUGH is not set (default), only the first match is
   found, so if multiple cases match the SWITCH value, only
   the first is used. This also applies to the default case

  If /FALL_THROUGH is specified on the CASE command, the next case will
   also be executed. This qualifier (on the CASE) is ignored if the 
   /FALL_THROUGH is specified with the SWITCH command.


   Example (using the ECHO command, but you could also use
            any valid command)

   SWITCH SELECTOR*2
    CASE 10
     echo "value=10"
    CASE 20
     echo "value=20"
    CASE
     echo "The default case"
    CASE 40
     echo SWITCH_SYNTAX
    ENDSWITCH

  Selectorvalue Result
   10           The text "value=20" is printed
   11           The text "The default case" is printed
 
   SWITCH/FALL SELECTOR*2
    CASE 10
     echo "value=10"
    CASE 20
     echo "value=20"
    CASE
     echo "The default case"
    CASE 40
     echo "Value=40"
   ENDSWITCH

  Selectorvalue Result
   10           The texts "value=20","value=40" are printed (not the default case)
   11           The texts "The default case" and "value=40" are printed

  If you type the command from the terminal (instead from a command file)
  DIX will prompt you for more lines until the ENDSWITCH command is found,
  and then will execute the commands.
 

  SWITCH SELECTOR
   case/fall 1    !if 1 go here, and since /fall is specifier do the next case too
    Statement1
   case/fall 2    !if 2 go here, and since /fall is specified do the next case too     
   case 3         !if 3 go here, and this is the last
    statement3
   case 20
    statement20
   case 
    statement
  ENDSWITCH
  
  If selector is 1 statement1 and statement3 are executed
  If selector is 2,3 statement3 is executed
  If selecter is 20  statement20 is executed
  In all other cases statement3 is executed
 
</pre>
<a name="830">
<h3 Align=center><a href="dix_help_idx_3.html#203" target="index">DIX INTERACTIVE_COMMANDS SYMBOLS </a> </h3>
<pre>

  You can define symbols.
  Syntax

  symbolname =[=] expression
  symbolname :=[=] stringvalue

  Symbols can have dimensions, see the help about 
      [DIX interactive] symbols tables"

  There are 4 types of symbols
  
   -normal     : Symbols of any type with upto 3 dimensions
   -indexed    : Symbols of any type with upto 3 dimensions, indexed by a 
                  key value (of any type)
   -description: Symbols that contain filedata. These symbols are described
                  by a description. The description can be variable.
   -Structures : Symbols that contain fields of possible different type.
                  described by a structure definition. The structure definition
                  is fixed.

  Symbols can be defined at all levels (@files) and at level 0 (global)

  Symbolnames can have up to 32 characters and are by default
  not case sensitive, unless DIX is set to case sensitive mode.
  See the help about "set case"
  The first must be a-z or _, and the remaining a-z 0-9 or $ .
   The name may not be TRUE, FALSE, or start with $, % or F$
 
  DIX will define a number of predefined symbols. See the help about
   predefined_symbols

  Normal symbols can have all types. 
  On a few you can do some computation

  They can be declared and used in expressions
    Logical    true/false
    Integer    signed values of 4/8 bytes long
    Character  strings up to 65535 characters
    Real       Real (native) format of 4/8/16 bytes
    Date       The OpenVMS date structure (8 bytes)
    Decimal    Fixed decimal string

  Other types can be filled from field values
   so if field_access is a field with type acl
     access=field_access		
   or can be created via the #type[*size]"value" syntax like
     access=#ACE"(id=system,acc=r)"

   Both will create symbol "access" with type ACE, and contents
     the specified acl value.
   The symbols of the "other types" can only be printed
     (or converted to string via the STRING function)
     No other operators are allowed

   If you reference a symbol (use it) DIX will use the symbol at the 
    deepest level. So if a symbol is defined at level 1 and at level 3,
    and we are at level 5, DIX wil use the value of level 3.

   If you set a symbol, and DIX is in normal (not dcl compatible) mode,
    DIX will locate the symbol of the deepest level.
    If it is not defined, DIX will define the symbol at the current level.
    So if a symbol is defined at level 3, DIX will change the value at level 3.
    If there is no symbol present, and we are at level 5, DIX will make a 
    new symbol at level 5. If you then return to level 4, the symbol will
    be deleted.
  
    But if DIX is in DCL compatible mode setting the symbol is always done
     at the current level, So in the previous example the symbol will be
     defined at level 5

   If you use the assigment with a double ==, DIX will always change/set
    the symbol at level 0 (global)

  You can declare symbols at any @file level and within any loopstructure
   (FOR/ENDFOR,WHILE/ENDWHILE etc.)
   The symbols are local to that level (and all deeper levels included) and will
   be deleted when the level (@file or loopstructure) exits.


  Symbol declaration at any level (including the current) can be done with the 
    INTEGER,REAL,CHARACTER,LOGICAL,DATE and DECIMAL command,
    or more general with the DECLARE name/type

  See the help about  [DIX/help] interactive declarations

  The setting of the STRICT mode influences the way symbols are seen.
  F.e. with strict/local, symbols from outer levels are NOT seen. This
  forces you to declare all symbols before using them.
  See the help about the  [DIX/help] interactive SET STRICT command

  Example
 
  a = 10
  k = 12
  for k=1,10		!K is also a local symbol in the for block
   integer a=40		!declare an integer local symbol a (with value 40)
   a = 20		!a(local) has the value 20
   say "a=''a'"         !a has the value 20   
   say "k=''k'"         !will have the value 1..10
  endfor
  say "a=''a'"          !a still has the value 10   
  say "k=''k'"          !k still has the value 12

</pre>
<a name="831">
<h3 Align=center><a href="dix_help_idx_4.html#545" target="index">DIX INTERACTIVE_COMMANDS SYMBOLS predefined_symbols </a> </h3>
<pre>
  $STATUS       Containing the status of the last command
  $SEVERITY     Containing the severity status of the last command
  $FILE         Containing the current file (can be empty)
  $DESCRIPTION  Containing the current description (can be empty)
  %OVERFLOW     THe last overflow result
  $DIX_VERSION  The ascii version of DIX (e.g. 8.4)
  $ARCHITECTURE The architecture VAX ALPHA or IA64

  Inside a SUBROUTINE or @'ed' file the following symbols are defined

  $NRARGS      Containing the number of arguments
  $Pn          Containing the 'n'th parameter
 
  During the evaluation of descriptions three more symbols are defined
  %OFFSET        The current byte-offset in the data record
  %BIT_OFFSET    The current bit-offset in the record
  $PREVIOUSFIELD The value of the previois converted to ascii (type=character)
  $PREVIOUSFLD   The value of the previous field(any type)

  During the execution of a DO nn statement the symbol $DOINDEX will
   contain the value of the loopindex (1..nn)

  If a file is open, you can use the
  %RECID       The current keyvalue/record number for the current file

</pre>
<a name="832">
<h3 Align=center><a href="dix_help_idx_4.html#546" target="index">DIX INTERACTIVE_COMMANDS SYMBOLS symbol_substition </a> </h3>
<pre>

  DIX will do symbol-substitutions with the ' character. (See SUBSTITUTIONS)
  DIX will also try to do symbol-substitution on the verb  (like DCL)
      so a symbol exa*mine:=exa/display
      and a later usage like 
         exa *user*             will translate into 
         exa/display *user*   

  Symbol substitution for verbs is default ON for commands entered from 
  the terminal, and default OFF for command procedures. If verb substitution
  is OFF for the command procedures, DIX  can pre-compile the commands in the
  file and make the execution much faster (up to 5 times). If verb substitution
  is ON for command procedures, DIX has to compile each command from the
  file the moment is executed, since the symbol may have changed value.

  Symbol substitution can be turned on or off with the 
  "set substitution /[no]verb/[no]symbols[=signal|quiet]/descr[=SIGNAL|QUIET]"
  command and for the command procedures with the @procedure/[no]verbs


</pre>
<a name="833">
<h3 Align=center><a href="dix_help_idx_4.html#547" target="index">DIX INTERACTIVE_COMMANDS SYMBOLS SUBFIELDS </a> </h3>
<pre>

  For all values containing multiple data, 
    RBITS,BITS,CHARACTER,xSTRING,(U)INTEGER and BYTEARRAY 
    you may use subfield addressing

  Sometimes it may be useful to specify a specific subfield of the whole
  structure. Below is a table of transformation

   RBITS              A one-bit RLOG
   BITS               A one-bit LOG
   CHARACTER,xSTRING  A byte-size character
   BYTEARRAY          A byte-size byte.
   (U)INTEGER         A one-bit integer

   syntax : expression{subfield[,subfield..]}
    Subfield can be
     a. element numbers
     b. ranges low:high:incr
     c. The * (all elements)

   Examples
    DIX&GT;say 10{*}
    [0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    DIX&GT;say "teststring"{*}
    [t,e,s,t,s,t,r,i,n,g]

  But also "TEST"{*} will deliver a table of 4 characters
      and  10{*} will deliver a table of 32 bits (if integersize=4)
    
  The syntax between the {} is
   a. *XYZ* : a mask. This only works on *BITS field with fieldnames defined
   b. *     : All elements
   c. 4-5   : Element 4..5   
   d. 4-*   : element 4..end of field
   e. *-4   : element begin_of_field..4
   d  12    : Element 12 only

  Subfields can be used on fields (you may use the fieldvalue names)  
  or on symbol  values 
  

</pre>
<a name="834">
<h3 Align=center><a href="dix_help_idx_4.html#548" target="index">DIX INTERACTIVE_COMMANDS SYMBOLS description_SYMBOLS </a> </h3>
<pre>

  You can declare a symbol to contain a structured datatype.
  You need a decription for that. The decription can be loaded via the
   OPEN statement (if the file has a description available), or via
  a specific LOAD /description NAME command

  Examples
  $DIX/INT SYSUAF  !edit sysuaf, this makes the sysuaf description available
  DIX&GT; decl/DESCR=SYSUAF symb_sysuaf !make a new symbol of type SYSUAF, but
                                     !with all data fields 0
  DIX&GT; symb_sysuaf = sysuaf          !copy data from the current record to
                                     !the symbol
  DIX&GT; say symb_sysuaf.uaf$t_Username
  VMSUSER
  DIX&GT;say symb_sysuaf.uaf$q_priv
  CMKRNL,CMEXEC,SYSNAM,GRPNAM,ALLSPOOL,IMPERSONATE,DIAGNOSE,LOG_IO,NOACNT,SETPRV,T
  MPMBX,WORLD,NETMBX,VOLPRO

  DIX&GT;sh symb/all/full symb_sysuaf
  SYMB_SYSUAF=86 descriptions,76 expanded
   SYMB_SYSUAF.UAF$B_RTYPE=0
   SYMB_SYSUAF.UAF$B_VERSION=0
   SYMB_SYSUAF.UAF$W_USRDATOFF=0
   ....
   SYMB_SYSUAF.UAF$W_ACCOUNTS=0
   SYMB_SYSUAF.UAF$R_DEF_CLASS=0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
   SYMB_SYSUAF.USER_DATA=
   DIX&GT; say symb_sysuaf.UAF$L_DFWSCNT
   2000
   DIX&GT; symb_sysuaf.UAF$L_DFWSCNT = 1000
   1000

  you can also lof a description and use that as source
   $DIX/INT
   DIX&GT; LOAD/DESCR SYSUAF          !explicit load sysuaf desciption
  And you can use the same statements as above except the
   DIX&GT; symb_sysuaf = sysuaf       !since sysuaf is not opened.

  Decription symbols may have dimensions

  $DIX/INT SYSUAF
  DIX&GT; decl/des=sysuaf mys(3)=sysuaf  !create a table of 3 elements
				      !all of them filled with the
				      !the current record of sysuaf
  DIX&GT; read/eq=SYSMAINT		!read the sysmain record
  DIX&GT; mys(1) = sysuaf          !save it in mys(1)
  DIX&GT; ne re                    !read the next record
  DIX&GT; mys(2) = sysuaf          !save if in mys(2)
  DIX&GT; ne re                    !read the next record
  DIX&GT; mys(3) = sysuaf 		!and save it in mys(3)
  DIX&GT; say mys(1).uaf$t_username
  SYSMAINT
  DIX&GT; say mys(2).uaf$t_username
  SYSTEM
  DIX&GT; say mys(3).uaf$t_username
  SYSTEST
  DIX&GT; say mys(1:3).uaf$t_username  
  [SYSMAINT                        ,SYSTEM                          ,SYSTEST                         ]


   
</pre>
<a name="835">
<h3 Align=center><a href="dix_help_idx_4.html#549" target="index">DIX INTERACTIVE_COMMANDS SYMBOLS indexed_SYMBOLS </a> </h3>
<pre>

  You can define a symbol to be indexed by ANY other type.
  You must declare the symbol first. Indexed symbols cannot have dimensions.

   DECLARE/INDEX=CHARACTER[/sort] COUNT/DATE  Or
   DECLARE/INDEX COUNT/DATE                The index is defaulted to character
   DECLARE/INDEX=ACE[/sort]       ACECOUNT/INTEGER
   DECLARE/INDEX=INTEGER[/sort]   INTCOUNT/ACE

  For the basic types you can also declare an indexed symbol via
 
   INTEGER/INDEX=CHARACTER[/sort][/case_blind] COUNT


  the /sort tells DIX to keep a sorted list, otherwise the list is
    filled in the order as new (index-)values are defined.
  The /case_blind tells DIX to upcase the key before processing

 Suppose we have declared the  following

   DECLARE/INDEX=CHARACTER COUNT/DATE

  Defines a symbol COUNT that is indexed by a string (character) and
  contains a numeric variable. After declaring the symbol has no values yet.
  
  You can assign/update values

   count("today")=1
   count("today")=count("today") + 1
   count("tomorrow") = 2
   
   THe argument must be either te correct (index-)type, or a character string
    that can be converted to the correct (index_)type

  examples for ACE association type (don't ask if it is useful)

   aclcount(#ACE"(id=system,acc=r)") = 1   !argument type is ACE
   aclcount("(id=system,acc=r)")     = 1   !argument type is character, but
                                           !can be converted to an ACE

  You can reference this value 

   show symb /fu count
   say count("today")
   x=count("*")

   show symb /fu  aclcount
   x=aclcount(*)

   Indices that have no value yet cannot be referenced, EXCEPT for the
      symbol(idx)=symbol(idx)+value 
      symbol(idx)=symbol(idx)-value 
      symbol(idx)+=1
      symbol(idx)-=1
      symbol(idx)++
      symbol(idx)--
    type of assignment
  
   So
    DIX&GT;integer/type=char count
    DIX&GT;say count("a")
    %DIX-W-NOINDEXVAL, No index values matching
    %DIX-E-INVELEM, Invalid element "COUNT("a")"
    DIX&GT; count("a")=count("a")+1
       Or DIX&GT; count("a")+=1
       or DIX&GT; count("a")++
    DIX&GT;say count("a")
    1
    DIX&GT;

   Example for counting words in a file
    DIX&GT;a=f$read("release_notes.txt",,,"White") 
                                          !read all lines and split in words
    DIX&GT;show symbol/full a
    A(Character,Level=1.0)=table(474,18)  !a table of 474 lines with 18 words
    DIX&GT;integer/index=char count          !declare an index symbol
    DIX&GT;for x in a                        !go for all elements in a
    DIXFOR&GT;count(x)++                     !update a count
    DIXFOR&GT;end for
    DIX&GT;show symb/fu/all count                !show the result
    COUNT(Fixed-Integer,Level=1.0,index=CHARACTER)=index list of 1327 values
    COUNT("")=4754
    COUNT(""")=4
    COUNT(""A":"Z"")=1
    COUNT(""ABCABC"/"C"")=1
    COUNT(""ABCD"{*}")=1
    COUNT(""DIX/help")=1
    COUNT(""FOR")=1
    COUNT(""GOTO"")=1
    COUNT(""Yes"")=1
    ....
    COUNT("wrong.")=2
    COUNT("you")=17
    COUNT("your")=1
    COUNT("|")=7
    DIX&GT;

</pre>
<a name="836">
<h3 Align=center><a href="dix_help_idx_4.html#550" target="index">DIX INTERACTIVE_COMMANDS SYMBOLS STRUCTURED_Symbols </a> </h3>
<pre>

   Structured symbols are defined by a structure definition.
   THis definition must be loaded (LOAD/STRUCT) before a symbol can be defined.
   A structure definition can contain datafields (of any datattype) and
   references to a deeper structure. Unlike description types, the whole
   structure must be fixed(in number of elements), and no control statements
   can be used (as in a description).

   Examples
    Suppose we have a file DEF_MAIN.STRUCT with the following contents
      integer*4 jan
      character*40 mystr
      real*16 real16val
      integer extra_int 
      integer*4 extra2(2,3) 

    We can load this strucuture in memory
    DIX&GT;LOAD/STRUCT DEF_MAIN
    And the declare a symbol of this type
    DIX&GT;DECL/STRUCT=DEF_MAIN myval
    DIX&GT;SHOW SYMB mystr/full/all
    MYVAL(Fixed,Struct=DEF_MAIN,Level=1.0)=10 values
    MYVAL.INDEX(INTEGER*4)=0
    MYVAL.MYSTR(CHARACTER*40)=
    MYVAL.REAL16VAL(REAL_X*16)=0.0
    MYVAL.EXTRA_INT(INTEGER*4)=0
    MYVAL.EXTRA2(1,1)(INTEGER*4)=0
    MYVAL.EXTRA2(2,1)(INTEGER*4)=0
    MYVAL.EXTRA2(1,2)(INTEGER*4)=0
    MYVAL.EXTRA2(2,2)(INTEGER*4)=0
    MYVAL.EXTRA2(1,3)(INTEGER*4)=0
    MYVAL.EXTRA2(2,3)(INTEGER*4)=0

    You can now assign/reference each (sub-)field with the fieldname,
          just like a normal symbol.
    DIX&GT;say myval.extra2
    [[0,0][0,0][0,0]]
    DIX&GT;myval.extra2(1,2)=12
    DIX&GT;say myval.extra2
    [[0,0][12,0][0,0]]
    DIX&GT;myval.extra2(1,*)=34
    DIX&GT;say myval.extra2
    [[34,0][34,0][34,0]]

    Structures may be nested, so suppose there is another file
    DEEP_DEF.STRUCT with with following
      integer*4 i4val
      record /Def_main/ mystruct
      real*4 real4val
    DIX&GT;load/struc deep_def
    DIX&GT;decl/struct=deep_def another
    DIX&GT;show symbol /all another
    ANOTHER=12 values
    ANOTHER.I4VAL=0
    ANOTHER.MYSTRUCT.INDEX=0
    ANOTHER.MYSTRUCT.MYSTR=
    ANOTHER.MYSTRUCT.REAL16VAL=0.0
    ANOTHER.MYSTRUCT.EXTRA_INT=0
    ANOTHER.MYSTRUCT.EXTRA2(1,1)=0
    ANOTHER.MYSTRUCT.EXTRA2(2,1)=0
    ANOTHER.MYSTRUCT.EXTRA2(1,2)=0
    ANOTHER.MYSTRUCT.EXTRA2(2,2)=0
    ANOTHER.MYSTRUCT.EXTRA2(1,3)=0
    ANOTHER.MYSTRUCT.EXTRA2(2,3)=0
    ANOTHER.REAL4VAL=0.0

    As above, You can now assign/reference each (sub-)field with the fieldname,
     just like a normal symbol. You can also reference/assign a complete
     deeper structure
    DIX&GT;say ANOTHER.MYSTRUCT
    [0,,0.0,0,[[0,0][0,0][0,0]]]
    DIX&GT;say/named ANOTHER.MYSTRUCT  !include the fieldnames
    [INDEX=0,MYSTR=,REAL16VAL=0.0,EXTRA_INT=0,[[EXTRA2(1,1)=0,EXTRA2(2,1)=0]
    [EXTRA2(1,2)=0,EXTRA2(2,2)=0][EXTRA2(1,3)=0,EXTRA2(2,3)=0]]]

    DIX&GT;new=another.mystruct
    DIX&GT;show symb new/fu/all
    MYVAL(Fixed,Struct=DEF_MAIN,Level=1.0)=10 values
    NEW.INDEX(INTEGER*4)=0
    NEW.MYSTR(CHARACTER*40)=
    NEW.REAL16VAL(REAL_X*16)=0.0
    NEW.EXTRA_INT(INTEGER*4)=0
    NEW.EXTRA2(1,1)(INTEGER*4)=0
    NEW.EXTRA2(2,1)(INTEGER*4)=0
    NEW.EXTRA2(1,2)(INTEGER*4)=0
    NEW.EXTRA2(2,2)(INTEGER*4)=0
    NEW.EXTRA2(1,3)(INTEGER*4)=0
    NEW.EXTRA2(2,3)(INTEGER*4)=0

    DIX&GT;NEW.MYSTR="String data"
    And assign it into the bigger structure again
    DIX&GT;another.mystruct = new
    DIX&GT;say another
    [0,String data,0.0,0,[[0,0][0,0][0,0]]]

</pre>
<a name="837">
<h3 Align=center><a href="dix_help_idx_4.html#551" target="index">DIX INTERACTIVE_COMMANDS SYMBOLS TABLES </a> </h3>
<pre>

  Symbols can have dimensions (up to 3).
  They can explicitly declared or directly assigned
  Symbols can also be indexed by any other type. See the help about
    dix symbols associative

  declare table(dim1[,dim2[,dim3]]) [/type[=initial value]]
  a=[[1,2][3,4][5,6]]             Will create a table a(3,2) of integers
  str=["test","test1"]            Will create a table str(2) of strings
  tab3=[[[0,0][0,0]][[0,0][0,0]]] Will create a table tab3(2,2,2) of integers

  dim*         : [low:]high[:increment]   e.g. 10, 1:10, 1:10:3
  type         : any supported symbol type
  initial value: The initial value (default=0 or "")

  Suppose we have done a  
  DIX&GT;declare a(10,10)
  You can assign individual elements like: a[1,2]=10
                 or ranges like:           a[1:5:2,*]=12

  If you do a "show symb a"
  DIX will respond with a= table(10,10)
  DIX will display all elements of the table if you specify the /all
   (the /all must be before the symbolname mask)

  Examples

  DIX&GT; declare a(4:6,5:10)
  DIX&GT; a(3,1) = 10
  %DIX-W-OUTRANGE, Symbol A index 2 out of range, got 1, expected 5:10:1
  DIX&GT; A(*,5) = 12
  DIX&GT;sh symb a
  A= table(4:6,5:10)
  DIX&GT;sh symb/all a
  A(4,5)=12
  A(4,6)=0
  ....
  A(4,10)=0
  A(5,5)=12
  A(5,6)=0
  ...
  A(6,5)=12
  ...
  A(6,10)=0

  Table assignment
  If we have a table a(4,4,4) we can copy the table to a new one

  x=a              Copy the whole table  to x (4,4,4)

  x=a(*,2,2)       Copy elements 1,2,2 and 2,2,2 to a one 
                   dimensional table x(4)
                   If a dimension has only contains one element,
                   it is not counted as a dimension, so you
                   will only have one dimension left, unless
                   you specify the increment with a * (see below)

  x=a(1:2,*,4)     Copy elements 1,1,4, 1,2,4 1,3,4 1,4,4 and
                             2,1,4, 2,2,4 2,3,4 2,4,4
                   to a two dimensional table x(2,4)

  x=a(1:2,*,4:4:*) If you specify a wildcard for the increment
                   with only one value, this dimension will
                   be used, even if it is only one element long
                   So this delivers a table x(2,4,1)

  Expressions can deliver tables 
  DIX&GT; say [2,2]
  [2,2]                Return the whole table

  And if an expression returns a table, you can specify which
  element you want to use
   syntax:  (expression)(dims) 
   The () around the expression are required.

  DIX&GT; say ([2,3,4])(3)
  4                    Return element 3 of table [2,3,4]
  DIX&GT; say ([[1,2][3,4]](1,*)
  [1,2]                Return (1,*) of [[1,2][3,4]]

  The +,-,* and / operator can be used with tables
   both arguments must have the same shape, or one of the arguments
   must be a scalar.

</pre>
<a name="838">
<h3 Align=center><a href="dix_help_idx_3.html#204" target="index">DIX INTERACTIVE_COMMANDS TIME </a> </h3>
<pre>

  If you prefix a command with the TIME verb , dix will output a
  ctrl_t like line after the command. This is a one-shot 
  set stat/usage. You cannot abbreviate this command.

  DIX&GT;time sh symb	   !execute the command, and then display the usage
  $ARCHITECTURE="ALPHA"
  $DESCRIPTION=""
  $FILE=""
  $NRARGS=0
  $SEVERITY=0
  $STATUS=080187C8
  %OVERFLOW=False
   ELAPSED:    0 00:00:00.00  CPU: 0:00:00.01  BUFIO: 7  DIRIO: 0  FAULTS: 0
  DIX&GT;
</pre>
<a name="839">
<h3 Align=center><a href="dix_help_idx_3.html#205" target="index">DIX INTERACTIVE_COMMANDS TYPE </a> </h3>
<pre>

   TYPE filemask[/qualifiers]

  Filemask is a mask of files to print

  If you specify the filemask as module@[library] or as [library](module), 
   DIX will read the module "module" from the (.tlb or .mlb) file "library".
   Both module and library may contain wildcards.
   If no library is specified, DIX will search SYS$LIBRARY:STARLET.MLB
   and SYS$LIBRARY:FORSYSDEF.TLB (if present) by default .

  Type one or more files/modules
   type *.txt        !type all .txt files
   type $acc*@*.tlb  !type all modules matching $acc* in all 
                     !libraries matching sys$share:*.TLB
 
  Supported qualifiers are
   The record selection criteria
     /HEAD=n            Type the first n lines
     /TAIL=n            Type the last n lines
     /records=(start=n,end=n)
      The n's can be negative, meaning n from the end of the file

   The columns selection qualifiers
     /COL=(start=n,end=n)
      The n's can be negative, meaning n from the end of the record
     /COL=(field=n[,separator=option)
      The the line in fields, and the the n' field
      Option can be 
         SLASH,COLON,SEMICOLON,SPACE,TAB,BAR,CHARACTER=number
            Split the line by the above named character
      If separator is not present, WHITESPACE is assumed, in this case
         the separator is one or more space/tab

   /FAST              Use the fastio routines. If the file is locked, DIX
                       will switch to /fast automatically.
   /screen            Use screen mode to display
   /paged             Wait after each screen full of text
   /output=filename   Type to a file
   /number            Include a line number for each printed line
   /info=start        Print a line with the filename before each printed file/module
   /info=end          Print a line at the end with #lines , #bytes printed
   /info=both         Print both of the above
   /info              Will be seen as /info=start
   
</pre>
<a name="840">
<h3 Align=center><a href="dix_help_idx_3.html#206" target="index">DIX INTERACTIVE_COMMANDS TRUNCATE </a> </h3>
<pre>

  TRUNCATE newreclength		set recl for current file
  TRUNCATE tag newreclength	set recl for file with tag "tag"

  Set new recordsize. The newreclength may be larger than the
  original one. Allowed only for Indexed and relative files, if they
  do not have the recordattribute FIXED.
  Newrecordlength must be an integer value (not an expression)
  You CAN use expressions and then let DIX convert the value to text
   example
      DIX&GT; newreclength=expression  !compute the new value (must be integer)
      DIX&GT; truncate 'newreclength'

</pre>
<a name="841">
<h3 Align=center><a href="dix_help_idx_3.html#207" target="index">DIX INTERACTIVE_COMMANDS UNDO </a> </h3>
<pre>
  UNDO [/LAST_DEPOSIT]         Undo changed for current file
  UNDO [/LAST_DEPOSIT] tag     Undo changed for file with tag "TAG"

  Undo all changes made to the current record.
  If you specify /LAST_DEPOSIT, only the changes made in the last DEPOSIT
  will be undone. See the DEPOSIT command for more detail

</pre>
<a name="842">
<h3 Align=center><a href="dix_help_idx_3.html#208" target="index">DIX INTERACTIVE_COMMANDS UPDATE </a> </h3>
<pre>

  UPDATE [tag] [/cancel] [/error=label] [/quiet]

  Save changed record to file. If no parameter is specified, the current
   file is updated, else the file with tag "tag"
  If an error occurs you may jump to label 'label', but the buffer
   will still contain changed data, so if try to read another record
   DIX will ask again if you want the buffer.
  If you specify the /cancel (and you have an error), DIX will cancel 
   the "dirty" bit, so the next read will not ask you for the update

  The /quiet suppresses the message that the record has been updated  

</pre>
<a name="843">
<h3 Align=center><a href="dix_help_idx_3.html#209" target="index">DIX INTERACTIVE_COMMANDS VERB </a> </h3>
<pre>
 
  VERB allows you to make use of CLD files in DIX.

  Verb has three variants

    VERB/COMPILE[/symbol=symbolname] cldfile 

     Parse cldfile to a symbol
      This symbol can be used later by the PARSE statement
      and the lex functions F$DCL_GET_VALUE and F$DCL_PRESENT
      and the "VERB[/symbol=symbolname] mask" statement
      "Symbolname" is used to store the compiled CLD info and has a 
       default value of DEFAULT_CLDTABLE
      
  
    VERB/DISPATCH[/SYMBOL=symbolname] parameter1,paremeter2...

     If the cld file has been parsed and the verb/syntax contains
     a routine clause, VERB/DISPATCH will execute a CALL to the
     label specified in the verb/syntax definition.
     The parameters can be specified as on the CALL command. 
     See the help there.
      "Symbolname" has a default value of DEFAULT_CLDTABLE
     If the VERB or SYNTAX does not have routine clause, or if the routine
     cannot be found, DIX will issue an error

    VERB[/SYMBOL=symbol][/ADDRESS=number][/DIX] verbmask

      Display the source of defined verb(s).

      If /DIX is specified , DIX will display the verbs of its
       own command table.

      You can als specify VERB/ADDRESS=nnnn. nnnn must be the address 
       of a cld-table in memory. If you specify the address of the 
       DCLTABLE in memory, DIX will display the verbs defined by DCL.
       You can find the address via 
         $ANA/SYSTEM
         SDA&GT; SHOW SYMBOL CLI$AG_CLITABLE
       I could have linked DIX to find this symbol, but that would
       have made DIX very OpenVMS version dependend.

      If you do not specify /address or /dix, DIX will assume a
      table has been loaded via the verb/compile. The default symbol
      is DEFAULT_CLDTABLE, but it may be changed via the /SYMBOL=symbolname
      THis symbol must have been filled via the 
        "verb/compile/symbol=symbolname cldfile" command
</pre>
<a name="844">
<h3 Align=center><a href="dix_help_idx_4.html#558" target="index">DIX INTERACTIVE_COMMANDS VERB Examples </a> </h3>
<pre>

  Example on using dcl_present/get_value

      DIX&GT; VERB/COMPILE/SYMBOL=mytable sys$update:acc.cld  !compile acc.cld
      DIX&GT; PARSE/SYMBOL=mytable ACC/FULL x.dat  !parse the command using the table
      DIX&GT; say f$dcl_present("FULL",mytable)   !see if /full is specified
      DIX&GT; say F$dcl_get_value("p1",mytable)   !get the value of the first param

 Example about showing cld definitions

      DIX&GT; VERB/DIX COMPILE            !show the syntax of the DIX command COMPILE
      DIX&GT; VERB/SYMBOL=mytable *        !show the source of the ACC.CLD file

      $ANA/SYS
      SDA&GT; show symb CTL$AG_CLITABLE        !find DCLtables in P1 space
      CTL$AG_CLITABLE = 00000000.7FFCD810 :  7AEF35FF.7AE40000
      $DIX
      DIX&GT; VERB/ADDRESS=%X7AE40000 COPY    !show the DCL copy command

  Example on VERB/DISPATCH

  VERB/COMPILE sys$input		!compile the data to DEFAULT_CLDTABLE
  DECK
      define verb test
       qualifier show, syntax=show_test
       qualifier since,syntax=since_test
       parameter p1
      Define syntax show_test
       routine show_test_routine        !the routine to be called
       parameter p1
       qualifier date
      Define syntax since_test
       routine since_test_routine	!the routine to be called
       parameter p1
       qualifier before,value(type=$datetime)
  EOD
    PARSE test/show/date p1        !parse from the table stored in DEFAULT_CLDT
    VERB/DISPATCH 23,"Today"       !will call show_test_routine with 2
                                   !arguments : integer 23 and string today
    if even($status) then SAY "Unexpected place" !should not happen
    PARSE test/since mypar/bef=1-jan-2010
    VERB/DISPATCH 45,"I want to test" !Will call the since_test_routine
                                      !with 2 arguments , integer 45 
                                      !and string "I want to test"
    EXIT
!
    SHOW_TEST_ROUTINE: SUBROUTINE arg1,arg2
    say "In show test, arg1=",arg1," arg2=",arg2
    say F$DCL_PRESENT("DATE")
    ENDSUBROUTINE
!
    SINCE_TEST_ROUTINE: SUBROUTINE arg1,arg2
    say "In since test, arg1=",arg1," arg2=",arg2
    say F$DCL_GET_VALUE("BEFORE")
    ENDSUBROUTINE

  Generates the following output

  In show test, arg1=23 arg2=Today
  134320585
  In since test, arg1=45 arg2=I want to test
   1-JAN-2010 00:00:00.00


</pre>
<a name="845">
<h3 Align=center><a href="dix_help_idx_3.html#210" target="index">DIX INTERACTIVE_COMMANDS VERIFY </a> </h3>
<pre>
  verify indexedfile [qualifiers]

  Check all buckets of an indexed file for corruption.

  Supported qualifiers are
   /verbose=n       : n=0..4 Output more info during the check  
   /output=filename : Print errors to file
  For more help see the modes verify help
![DIX MODES verify]DIX modes verify

</pre>
<a name="846">
<h3 Align=center><a href="dix_help_idx_3.html#211" target="index">DIX INTERACTIVE_COMMANDS WAIT </a> </h3>
<pre>
  
  WAIT expression

  Wait for a specific time, the expression can be integer or real
  and will be interpreted as seconds.
</pre>
<a name="847">
<h3 Align=center><a href="dix_help_idx_3.html#212" target="index">DIX INTERACTIVE_COMMANDS WHILE_ENDWHILE </a> </h3>
<pre>

  syntax : WHILE [logicalexpression]
            statement
            statement
            ...
           ENDWHILE

 Repeat the statements as log as "logicalexpression" evaluates to true.
  logicalexpression defaults to true
 See also the examples

  See also the help about the LEAVE and the CYCLE command

  If you type the command from the terminal (instead from a command file)
  DIX will prompt you for more lines until the ENDWHILE command is found,
  and then will execute the commands.

 Example for while constructs
  a = 10
  while a&GT;0
   b = 2
   repeat 
    say "a = ''a' b = ''b'"
    b = b - 1
   until b=0
   a = a-1
  endwhile
 




</pre>
<a name="848">
<h3 Align=center><a href="dix_help_idx_3.html#213" target="index">DIX INTERACTIVE_COMMANDS WRITE </a> </h3>
<pre>
 
  In DIX mode the write statement has 4 formats

   WRITE/RECORD input_file output_file
     Write the contents of the current record of 'input_file' 
     to 'output_file'
     input_file and outputfile are the tags of an opened file

   WRITE/RECORD output_file
     Write the contents of the current record of the current file
     to 'output_file'
     outputfile is the tag of an opened file

   WRITE filetag filename [/append]

   WRITE filename [/append]
     Write the current record to the file "filename". If /append is 
     given, the record will be appended to an existing file.
     In this case the outputfile will be opened/closed 

  In DCL mode, the write statement has the following format

   WRITE file expression[,expression...]
    The /record is allowed, but ignored. DIX can use long records anyway.

  Qualifiers supported are
   /ERR=label: goto label if error
   /APPEND   : see above
   /COUNT=nn : copy nn records (or eof reached)
   /ALL      : Copy all records from input file
   /format=formattype  : What to do with unprintable data
               passall : pass unchanged to the file
               dot     : replace by .
               hex     : replace by %NNX
               dump    : replace by &LT;ESC&GT; etc...

    /format=dot is default if write to terminal
    /format=passall is default if write to file

  Example  (case 1)

  DIX&GT;       open input inputfile.dat
  DIX&GT;       open output outputfile.dat/modify/create
  DIX&GT; loop: write/record input output
  DIX&GT;       read input/end=done
  DIX&GT;       goto loop
  DIX&GT; done: close input
  DIX&GT;       close output

  Example  (case 2)

  DIX&GT;       open input inputfile.dat
  DIX&GT;       open output outputfile.dat/modify/create
  DIX&GT; loop: write/record output
  DIX&GT;       read input/end=done
  DIX&GT;       goto loop
  DIX&GT; done: close inpuf
  DIX&GT;       close output

  Example  (case 3)

  DIX&GT;       open input inputfile.dat
  DIX&GT;       first = true
  DIX&GT; loop: if (first) then
  DIX&GT;         write outputfile.dat
  DIX&GT;       else
  DIX&GT;         write outputfile.dat/append
  DIX&GT;       endif
  DIX&GT;       first = false
  DIX&GT;       read input/end=done
  DIX&GT;       goto loop
  DIX&GT; done: close input
  DIX&GT;       close output


</pre>
<a name="849">
<h3 Align=center><a href="dix_help_idx_2.html#15" target="index">DIX KEY_MAPPING </a> </h3>
<pre>
  DIX uses key mapping. In the Screenmode (SMG)Keys are mapped to 
  DIX_functions. DIX has a default map, but you can override it in 
  the startup_file.

  As you can see below, this mapping is not very nice so you can adapt this
  mapping to your own needs. See the help about the  [DIX/help] "/STARTUP"

</pre>
<a name="850">
<h3 Align=center><a href="dix_help_idx_3.html#215" target="index">DIX KEY_MAPPING DIX_functions </a> </h3>
<pre>

  DIX has the following functions
  Move functions
   key_up          one line up
   key_down        one line down
   key_left        one pos left
   key_right       one pos right
   key_prev        screen up
   key_next        screen down
   key_top         first line
   key_bot         last line
   key_set_forw    set forward mode on find
   key_set_backw   set backward mode on find
   key_page        page command either forw or backward depending on mode

   key_find        search in display for text string
   key_find1       Ask search string and the key_find
   key_next_window toggle ascii/bin display in raw_mode
   key_prev_window toggle ascii/bin display in raw_mode
   key_do          save changes to record
   key_save        Save to save area
   key_restore     Restore record from save area
   key_contdis     continuously display description
   key_getfields   get data through menu for bit-fields
   key_viewvfc     View/modify vfc data
   key_help        display help

  Field modify functions
   key_enter       enter and terminate input in field input
   key_first       goto first char in line in field input
   key_last        goto last char in line
   key_erase       erase input field
   key_delete      delete character on input
   key_toggle      toggle insert/overstrike

  General
   key_cancel      cancel (search) action
   key_dispall     display all descriptions of the data
   key_editdes     edit description file
   key_prev_field  previous field on input
   key_fileinfo    file (RMS) info
   key_print       print display to file
   key_select      select a field from the (file of description) list
   key_swap_num    Toggle offset display (none/hex/decimal)
   key_byte        Display data in bytes (raw mode)
   key_word        Display data in words (raw mode)
   key_long        Display data in longwords (raw mode)
   key_compres     Toggle compress mode (do not display "empty" fields)
   key_displ_hex   HEx data display
   key_displ_oct   Octal data display
   key_displ_bin   Binary data display
   key_displ_dec   Decimal data display
   key_nexdec_offs Toggle offset display hex/decimal
   key_newreclen   Set record length
   key_viewdes     View description from file
   key_repaint     repaint screen
   key_viewdesc    View description in memory
   key_swap_dis    toggle description/raw mode
   key_swap_signed toggle signed/u sigend for decimal numbers
   key_abort       Abort changed to record
   key_remove      Delete current record (idx /rel file only)
   key_nextdes     Next description file
   key_prevdes     Prev description file
   key_dirdes      Directory description file
   key_dispsubf    Display all subfields
   key_ask_key     Ask for new key in the current file
   key_next_rec    Next record in the file
   key_prev_rec    Previous record
   key_put         Insert new record
   key_find_rec    Find data in file (search)
   key_find_rec1   find data in file , but ask for search string first
   key_next_file   next file (if in multi_file mode)
   key_prev_file   previous file(if in multi_file mode)
   key_dir_file    dir file  (if in multi_file mode)
   key_exit        Exit program
   key_rfa_restore return to previous set rfa
   key_modechange  toggle screen/interactive
   key_follow_link Follow the link to another file
   key_back_link   Return to the original file after a key_Follow_link
   key_ch_width    Toggle screen width between 80 and 132 characters
   key_menu        Display a menu and let user choose

  Editing key
   key_delete_line	Delete line
   key_delete_word      Delete word
   key_delete_char      Delete char
   key_undelete_line    Undelete line
   key_undelete_word    Undelete word
   key_undelete_char    Undelete char
   key_next_line        Goto the beginning of the next line
</pre>
<a name="851">
<h3 Align=center><a href="dix_help_idx_3.html#216" target="index">DIX KEY_MAPPING Default keymapping </a> </h3>
<pre>
  The default keymapping is : 

  define/skey pf1/set_state=GOLD ""
  define/skey pf4/set_state=BLUE ""
  define/skey pf4         key_delete_line               /context=edit
  define/skey pf4       key_undelete_line/IF_STATE=GOLD /context=edit
  define/skey up          key_up   
  define/skey down        key_down 
  define/skey left        key_left 
  define/skey right       key_right
  define/skey prev_screen key_prev 
  define/skey up          key_prev       /IF_STATE=GOLD 
  define/skey next_screen key_next 
  define/skey down        key_next       /IF_STATE=GOLD 
  define/skey prev_screen key_top        /IF_STATE=GOLD 
  define/skey next_screen key_bot        /IF_STATE=GOLD 
  define/skey kp8         key_page
  define/skey pf3         key_find 
  define/skey pf3         key_find1      /IF_STATE=GOLD 
  define/skey ht          key_next_window
  define/skey ht          key_prev_window/IF_STATE=GOLD
  define/skey f8          key_contdis
  define/skey f9          key_save
  define/skey do          key_do   
  define/skey help        key_help
  define/skey pf2         key_help
  define/skey ctrla       key_toggle
  define/skey f14         key_toggle
  define/skey f14         key_modechange /IF_STATE=GOLD 
  define/skey ctrle       key_last
  define/skey ctrlh       key_first
  define/skey f12         key_first
  define/skey cr          key_enter
  define/skey enter       key_enter
  define/skey ctrlx       key_erase
  define/skey f13         key_erase
  define/skey lf          key_erase
  define/skey ctrlc       key_cancel
  define/skey kp4         key_set_forw
  define/skey kp4         key_set_forw   /IF_STATE=GOLD 
  define/skey kp5         key_set_backw
  define/skey kp5         key_set_backw  /IF_STATE=GOLD 
  define/skey select      key_select
  define/skey delete      key_delete
  define/skey uppercase_a key_dispall    /IF_STATE=BLUE 
  define/skey uppercase_e key_editdes    /IF_STATE=GOLD 
  define/skey uppercase_f key_fileinfo   /IF_STATE=GOLD 
  define/skey uppercase_z key_follow_link/IF_STATE=GOLD 
  define/skey uppercase_z key_back_link  /IF_STATE=BLUE 
  define/skey uppercase_m key_menu       /IF_STATE=GOLD 
  define/skey ctrlr       key_repaint
  define/skey ctrlw       key_repaint
  define/skey uppercase_g key_getfields  /IF_STATE=GOLD 
  define/skey uppercase_p key_print      /IF_STATE=GOLD 
  define/skey uppercase_y key_viewvfc    /IF_STATE=GOLD 
  define/skey uppercase_o key_swap_num   /IF_STATE=GOLD 
  define/skey f20         key_swap_num
  define/skey uppercase_b key_byte       /IF_STATE=GOLD 
  define/skey uppercase_w key_word       /IF_STATE=GOLD 
  define/skey uppercase_s key_swap_signed/IF_STATE=GOLD 
  define/skey uppercase_s key_dispsubf   /IF_STATE=BLUE
  define/skey uppercase_w key_ch_width   /IF_STATE=BLUE
  define/skey uppercase_l key_long       /IF_STATE=GOLD 
  define/skey uppercase_c key_compres    /IF_STATE=GOLD 
  define/skey uppercase_h key_displ_hex  /IF_STATE=BLUE
  define/skey uppercase_o key_displ_oct  /IF_STATE=BLUE
  define/skey uppercase_b key_displ_bin  /IF_STATE=BLUE
  define/skey uppercase_d key_displ_dec  /IF_STATE=BLUE
  define/skey uppercase_h key_hexdec_offs/IF_STATE=GOLD
  define/skey uppercase_t key_newreclen  /IF_STATE=GOLD 
  define/skey uppercase_v key_viewdes    /IF_STATE=GOLD 
  define/skey uppercase_v key_viewdesc   /IF_STATE=BLUE 
  define/skey ctrlw       key_repaint    /IF_STATE=GOLD 
  define/skey ctrlr       key_repaint    /IF_STATE=GOLD 
  define/skey uppercase_a key_swap_dis   /IF_STATE=GOLD 
  define/skey f19         key_swap_dis
  define/skey do          key_abort      /IF_STATE=GOLD 
  define/skey remove      key_remove
  define/skey uppercase_r key_remove     /IF_STATE=GOLD 
  define/skey uppercase_x key_nextdes    /IF_STATE=GOLD 
  define/skey uppercase_x key_prevdes    /IF_STATE=BLUE 
  define/skey uppercase_d key_dirdes     /IF_STATE=GOLD 
  define/skey f9          key_restore    /IF_STATE=GOLD 
  define/skey f17         key_ask_key
  define/skey uppercase_k key_ask_key    /IF_STATE=GOLD 
  define/skey f18         key_next_rec
  define/skey f18         key_prev_rec   /IF_STATE=GOLD 
  define/skey uppercase_n key_next_rec   /IF_STATE=GOLD 
  define/skey uppercase_n key_prev_rec   /IF_STATE=BLUE 
  define/skey insert_here key_put
  define/skey uppercase_i key_put        /IF_STATE=GOLD 
  define/skey find        key_find_rec
  define/skey find        key_find_rec1  /IF_STATE=GOLD 
  define/skey uppercase_j key_next_file  /IF_STATE=GOLD 
  define/skey uppercase_j key_prev_file  /IF_STATE=BLUE 
  define/skey uppercase_q key_dir_file   /IF_STATE=GOLD 
  define/skey f10         key_exit
  define/skey ctrlz       key_exit
  define/skey PF4         key_delete_line
  define/skey PF4         key_delete_line/IF_STATE=GOLD
  define/skey MINUS       key_delete_word
  define/skey MINUS       key_undelete_word/IF_STATE=GOLD
  define/skey COMMA       key_delete_char
  define/skey COMMA       key_undelete_char/IF_STATE=GOLD


</pre>
<a name="852">
<h3 Align=center><a href="dix_help_idx_2.html#16" target="index">DIX DIX_parameters </a> </h3>
<pre>

  The following limits apply to DIX.

  Number of open files          : Unlimited*
  Number of descriptions/file   : Unlimited*

  Interactive mode
   Number of commmandfile levels : 65535
   Number of if/for/while levels : 32767
   Symbolnames                   : 32 characters
   Labelname length              : 32 characters
   Follow history                : 16

  Screen mode
   Number of screen key definitions : 200

  Descriptions
   Fieldnames           : 32 characters/level
   Total name length    :512
   Number of dimensions :  3 
   Structure levels     : 10
   Union levels         :  4

  *Unlimited means : limited by process quota, not DIX.

</pre>
<a name="853">
<h3 Align=center><a href="dix_help_idx_2.html#17" target="index">DIX Example scripts </a> </h3>
<pre>
 These scripts are some of the scipts used for regresssion testing on DIX
 Some of them will only work with test datafiles, so may not work
 standalone, but these scripts may give you some idea about the 
 possibilities of DIX
</pre>
<a name="854">
<h3 Align=center><a href="dix_help_idx_3.html#219" target="index">DIX Example scripts ANALYZE </a> </h3>
<pre>
  Check for the dix/analyze function

  $DIX/ANA/DISP=(DATA) SYSUAF.ORG
</pre>
<a name="855">
<h3 Align=center><a href="dix_help_idx_3.html#220" target="index">DIX Example scripts ASSIGN </a> </h3>
<pre>

  Check for assignments

  $DIX/INTER SYSUAF.WORK/MOD
  !
  !CHeck assignments
  !
  exa UAF$Q_parent_id*
  dep UAF$Q_parent_id(*)=10
  exa UAF$Q_parent_id*
  UAF$Q_parent_id = 20
  exa UAF$Q_parent_id*
  UAF$Q_parent_id = [20,30]
  exa UAF$Q_parent_id*
  UAF$Q_parent_id(2) = 21
  exa UAF$Q_parent_id*
  !
  decla/int a(3,3)
  eva/table a
  a = 20
  eva/table a
  a(1,*)=10
  eva/table a
  a(*,*)= 40
  eva/table a

</pre>
<a name="856">
<h3 Align=center><a href="dix_help_idx_3.html#221" target="index">DIX Example scripts BUCKET </a> </h3>
<pre>

  Check for the $bucket description

  $DIX/INT SYSUAF.ORG/BLOCK=3/REC=4/DES=$BUCKET
  exa
  read/rec=7
  exa
  read/rec=10
  exa
</pre>
<a name="857">
<h3 Align=center><a href="dix_help_idx_3.html#222" target="index">DIX Example scripts CALL_GOSUB </a> </h3>
<pre>
  $DIX/INTERACTIVE
  !
  ! TEsting gosub routines
  !
   examine *mem*
   echo "to gosub test "
   @gosub
   echo "return from gosub_test"
   examine *mem*
   exit
 
   And the file gosub.dix contains

   OPEN mySYSUAF PROGRAMS_TOP:[DIX.REGRES]SYSUAF.ORG
   k=0
   read/eq=stubbf mysysuaf
  lp12: k=k+1
   examine mysysuaf\UAF$Q_PWD('k')
   if (k&LT;2)goto lp12
   gosub process_1
   CLOSE mySYSUAF
   exit
  process_1:
   echo "In process_1"
   gosub process_2
   echo "back In process_1"
   return
  process_2:
   echo "In process_2"
   gosub process_3
   echo "back In process_2"
   return
  process_3:
   echo "In process_3"
   sel file mysysuaf
   exa uaf$*username
   return


</pre>
<a name="858">
<h3 Align=center><a href="dix_help_idx_3.html#223" target="index">DIX Example scripts CALL_TEST </a> </h3>
<pre>

  Testing calls

  $DIX/INTERACTIVE
  set stri/typ/decl
  integer a=10
  call jan 2,a,3*a
  set stri/notyp/nodecl
  exit
  jan: subroutine var1/int,var2/int/symbol,var3/int
  show symb/ful
  echo "normal echo"
  echo/console "Echo to console"
  endsubroutine
</pre>
<a name="859">
<h3 Align=center><a href="dix_help_idx_3.html#224" target="index">DIX Example scripts COMMANDS </a> </h3>
<pre>

  General (interactive) commands

  $DIX/INT 
  set noon
  open sysu sysuaf.org
  !
  ! Description commands
  !
  add description .dir,$line
  show file/des
  remove descr *dir*
  show file/des
  prev des
  next des
  next des
  next des
  prev des
  sel descr sysu
  sel descr $line
  sel descr xyz
  rem des *
  show des/loaded
  close /err=cls_unexp
  close/err=cls_exp
  cls_unexp: say "Unexpected close error, status=",$status
  cls_Exp:
  !
  open sysu sysuaf.org
  open pend pending.org
  next file
  next file
  prev file
  prev file
  prev file
  sel file sysu
  sel file pend
  sel file xyz
  close *
  !
  ! Try prev/next record
  !
  open sysu sysuaf.org
  find aa
  search tcp
  exa *user*
  rewind
  next rec sysu
  exa *user*
  next rec
  exa *user*
  prev rec sysu
  exa *user*
  prev rec
  exa *user*
  read/ge="VPM$SERVER"
  mark mymark
  exa *user*
  read sysu
  next rec/end=eof_exp
  say "Unexpected not EOF"
  eof_exp:
  gomark mymark
  exam *user*
  close sysu
  !
  ! try to copy to file
  !
  open sysu sysuaf.org
  show file/fdl/out=temp.fdl
  crea/ file x.x/fdl=temp.fdl
  read sysu
  read sysu
  read sysu/ge=TCP
  open out x.x/modify
  write/record sysu out/all/log
  close out
  open mytag x.x/fast
  anal mytag
  close mytag
  spawn delete x.x;/log
  spawn delete temp.fdl;/log
  close sysu
  !
  open sysu sysuaf.org
  grep user exa *
  close sysu
  !
  dire/size *.org
  character var_char="Test"
  integer var_int=10
  logical var_log=true
  date var_date=#DATE"1-JAN-2007"
  real var_real=-1.3e+12
  decimal var_dec=#DECI"12310"
  show symb/fu var*
  declare qi/int=1,qr/real=1.3,qd/date=#date"1-JAN-2007" ,ql/log=false,qde=#DECI"12"
  show symb/fu q*
  delet/symb q*
  !
  do 4 show stat
  !show time
  wait 0.5
  !show time
  wait 1
  !show time
  !
  open sysu sysuaf.work
  dump /count=2
  cut
  set file/mod
  dep uaf$w_accounts=10
  paste
  close sysu
</pre>
<a name="860">
<h3 Align=center><a href="dix_help_idx_4.html#574" target="index">DIX Example scripts COMMANDS CVT_HELP_TO_HTML </a> </h3>
<pre>
  THe following script converts a helpfile or helplibrary to a
  number of .html files that can be viewed by a webbrowser

  This script can be called from DCL and also from DIX via the
  DIX&GT;@cvt_help_to_html/dcl parameter  command. This demonstrates that
  DIX can run normal DCL files
   $	if p1 .eqs. "?"
   $	 then
   $	   typ sys$input
   
    Convert a vms help library (or a help file) to
     a .html file
    Parameters:
      p1: The name of the help library (or help file)
      p2: The name of the .html file (default p1-filename.html)
   
   $	  goto done
   $	 endif
   $!
   $! Definitions Settings
   $! 
   $	max_file_size = 500	!max size of data file
   $	def_file_type = ".HTML"
   $!
   $! Parse input, p1 : filename (.hlp or .hlb)
   $!
   $	inp_fnam = p1
   $	if inp_fnam .eqs. "" then inquire inp_fnam "Help library/file"
   $	fnam = f$parse(inp_fnam,".HLB")
   $!
   $	
   $	if f$search(fnam) .eqs. ""
   $	 then
   $	  fnam = f$parse(inp_fnam,".HLP")
   $	  if f$search(fnam) .eqs. ""
   $	   then
   $	    write sys$output "Could not find file ",fnam
   $	    goto done
   $	  endif
   $	 endif
   $	bd = f$parse(fnam,,,"NAME")
   $!
   $! PArse p2, location to store results
   $!	
   $	outnam = p2
   $	if p1 .eqs. "" .and. p2 .eqs. "" then Inquire outnam "Outputfile [''bd'.HTML]"
   $	dnam = bd + def_file_type
   $	outnam = f$parse(outnam,dnam)
   $	write sys$output "Converting ",fnam
   $!
   $	on control_y then goto abort
   $	on error     then goto abort
   $!
   $!  See if the input file is a .hlb (help library) or a .HLP file (help text)
   $!
   $	ex = f$edit(f$parse(fnam,,,"TYPE"),"UPCASE")
   $	if ex .eqs. ".HLB"
   $	 then
   $!
   $! Extract the contents to a temp file
   $!
   $	  tmpnam = f$unique() + ".TMP;0"
   $	  write sys$output "Extracting text from help library ",fnam
   $	  libr/extr=*/out='tmpnam' 'fnam'
   $	  fnam = tmpnam
   $	 else
   $	  tmpnam = ""
   $	 endif
   $!
   $!
   $	open/read lun 'fnam'
   $!
   $	max_depth      = 9	           !no more han 9 levels
   $	gosub make_main
   $!	
   $! Restart after end of wlev level
   $!
   $	seen_slash     = 0  		   !not in / mode
   $	nr             = 0  		   !topic index
   $	totline        = "" 		   !topic header line
   $	cur_len_0      = 0 		   !current header length
   $	cur_lev        = 0     		   !current level
   $	low_limit_size = max_file_size*460 !90% of size
   $	hig_limit_size = max_file_size*614 !120% of size
   $	old_outnam_dat = ""		   !previous filename
   $	fidx           = 0		   !file index
   $	max_lev        = 0
   $	old_line       = ""
   $	old_ilev       = 1
   $!
   $! Create main file (with frames) and index file
   $!
   $	gosub init_hdr
   $!
   $! Main loop : Keep reading
   $!
   $10:	read lun line/end=eof
   $	kar = f$extra(0,1,line)			!see if new topic
   $	if kar .eqs. "/" then goto slash	!found a / topic
   $	if kar .ges. "1" .and. kar .les. "9" 
   $	 then 
   $	  if f$extra(1,1,line) .eqs. " " then goto level   !found a number topic
   $	 endif
   $!
   $! Include the text as is
   $!
   $	gosub cvt_line	  
   $	write out line
   $	nbyts = nbyts +f$length(line) + 1	!one for the LF
   $	goto 10
   $!
   $! Found a slash topic, the first will increase the level
   $!
   $slash:
   $	if .not. seen_slash then ilev = ilev + 1
   $	seen_slash = 1
   $	goto gotit
   $!
   $! Found a number topic 1..9
   $!
   $level:	ilev = f$integer(kar)
   $	seen_slash = 0
   $!
   $! Skip the leading digit (and following spaces)
   $!
   $	line = f$extr(2,-1,line)
   $gotit:
   $	line = f$edit(line,"TRIM")
   $	gosub cvt_line	  
   $	if old_line .nes. "" then write out "&LT;/pre&GT;"
   $!
   $! Limit the files in size
   $! If new level 1 and size&GT; 90%, make new
   $! If new level&GT;1 and size&GT;110%, make new
   $!
   $	if nbyts .lt. low_limit_size                   then goto keep_gooing
   $	if nbyts .lt. hig_limit_size .and. ilev .gt. 1 then goto keep_gooing
   $!
   $! File has gotten too big, close and open a new one
   $!
   $	old_fidx = fidx
   $	fidx = fidx + 1
   $	old_outnam_dat = outnam_dat
   $	outnam_dat = body + "_DATA_''fidx'" + file_type
   $!
   $	gosub exit_hdr		!finish off this file
   $	gosub init_hdr          !create new file
   $!
   $keep_gooing:
   $	nr = nr + 1
   $	tag_'ilev' = nr
   $	gosub add_index
   $!
   $	if ilev .gt. max_lev then max_lev = ilev
   $	if max_lev .gt. max_depth then max_lev = max_depth
   $!
   $	write out "&LT;a name=""''nr'""&GT;"
   $	if ilev .le. cur_lev
   $	 then
   $	  idx = ilev-1
   $	  nk = cur_len_'idx'
   $         totline = f$extra(0,nk,totline)
   $	 endif
   $	totline = totline + line + " "
   $	cur_len_'ilev' = f$length(totline)
   $	cur_lev = ilev
   $	wnr = out_nr_'ilev'
   $	onam = outnam_idx_'ilev'
   $	add_line = "&LT;a href=""''onam'#''wnr'"" target=""index""&GT;''totline'&LT;/a&GT; " 
   $	write out "&LT;h3 Align=center&GT;",add_line,"&LT;/h3&GT;"
   $	write out "&LT;pre&GT;"
   $	goto 10
   $!
   $! FOund eof
   $!
   $eof:	close lun
   $!
   $!
   $	ilev = 0
   $	gosub add_index
   $!
   $	old_fidx = fidx
   $	fidx = -1
   $	gosub exit_hdr
   $!
   $	gosub make_top_idx
   $!
   $! Finish off the index file
   $!
   $	k = 1
   $lp_dep7:
   $	if k .le. max_depth
   $	 then
   $	  write out_idx_'k' "&LT;/pre&GT;"
   $	  write out_idx_'k' "&LT;/body&GT;"
   $	  write out_idx_'k' "&LT;/html&GT;"
   $	  close out_idx_'k'
   $	  fn = outnam_idx_'k'
   $	  if k .gt. max_lev then delete 'fn';
   $	  k = k+1
   $	  goto lp_dep7
   $	 endif
   $!
   $!
   $dn1:	if tmpnam .nes. "" then delete/noconfirm 'tmpnam'
   $done:	exit
   $!
   $! ^Y or error
   $!
   $abort:	set noon
   $	if f$trnlnm("out")     .nes. "" then close out
   $ 	if f$trnlnm("out_idx") .nes. "" then close out_idx
   $	k = 1
   $lp_dep5:
   $	if k .le. max_depth
   $	 then
   $ 	  if f$trnlnm("out_idx_''k'") .nes. "" then close out_idx_'k'
   $	  k = k + 1
   $	  goto lp_dep5
   $	 endif
   $ 	if f$trnlnm("lun")     .nes. "" then close lun
   $	write sys$output "Aborting"
   $	goto dn1
   $!
   $add_index:
   $!
   $	if old_line .eqs. "" then got skip_34
   $	kar = ""
   $	indent = f$fao("!#AS",(old_ilev-1)*2," ")
   $	if ilev .gt. old_ilev then kar = "+"
   $	dep = old_ilev
   $lp_dep3:
   $	if dep .le. max_depth
   $	 then
   $	  out_nr_'dep' = out_nr_'dep' + 1
   $	  wnr = out_nr_'dep'
   $	  idx_line ="&LT;a name=""''wnr'""&GT;"
   $	  if kar .eqs. "+"
   $	   then
   $	    idx1 = dep + 1
   $	    onam = outnam_idx_'idx1'
   $	    wnr = out_nr_'dep' + 1
   $	    add_line = "&LT;a href=""''onam'#''wnr'"" target=""index""&GT;+&LT;/a&GT; " 
   $	   else
   $	    if kar .eqs. "-"
   $	     then
   $	      idx1 = dep -  1
   $	      onam = outnam_idx_'idx1'
   $	      wnr = out_nr_'dep'
   $	      add_line = "&LT;a href=""''onam'#''wnr'"" target=""index""&GT;-&LT;/a&GT; " 
   $	     else
   $	      add_line = "  "
   $	     endif
   $	   endif
   $	  write out_idx_'dep' idx_line,indent,add_line,"&LT;a href=""",outnam_dat,-
                  "#''old_nr'"" target=""data""&GT;",old_line,"&LT;/a&GT;" 
   $	  if kar .nes. "" then kar = "-"
   $	  dep = dep + 1
   $	  goto lp_dep3
   $	 endif
   $skip_34:
   $	old_line = line
   $	old_ilev = ilev
   $	old_nr   = nr
   $	return
   $!
   $! Convert a text line, , make sure no special chars in line
   $!
   $cvt_line:
   $	kar1 = "&AMP;"
   $	kar2 = "&AMP;AMP;"
   $	gosub subst 	!subst &AMP; by &AMP;amp
   $	kar1 = "&LT;"
   $	kar2 = "&AMP;LT;"
   $	gosub subst 	!subst &LT; by &AMP;lt
   $	kar1 = "&GT;"
   $	kar2 = "&AMP;GT;"
   $	gosub subst     !subst &GT; by &AMP;gt
   $	return
   $!
   $! Replace all occurences of kar1 by  kar2 
   $!
   $subst:	bpos = 0
   $lp_s:	pos = f$locate(kar1,f$extra(bpos,-1,line))
   $       if pos .ne. f$length(line) - bpos
   $        then
   $         pos  = pos + bpos
   $         line = f$extra(0,pos,line) + kar2 + -
                    f$extra(pos+f$leng(kar1),-1,line)
   $         bpos  = pos + f$length(kar2)
   $         goto lp_s
   $        endif
   $	return
   $!
   $! Create the main and the index file
   $!
   $make_main:
   $	dirnam      = f$parse(outnam,,,"DEVICE") + -
                         f$parse(outnam,,,"DIRECTORY") 
   $	body        = f$parse(outnam,,,"NAME")
   $	file_type   = f$parse(outnam,,,"type")
   $	outnam_main = body           + file_type
   $	outnam_idx_top  = body + "_IDX_TOP"  + file_type
   $!
   $! Make upto 9 levels
   $!
   $	k = 1
   $lp_hd:	outnam_idx_'k'  = body + "_IDX_''k'"  + file_type
   $	k = k+1
   $	if k .le. max_depth then goto lp_hd
   $!
   $	outnam_dat      = body + "_DATA" + file_type
   $!
   $! Create the main file (containing the frames)
   $!
   $	fn = dirnam + outnam_main
   $	tag = " to"
   $	gosub create_file
   $	open/append out 'fn'
   $	write out "&LT;html&GT;"
   $	write out "&LT;head&GT;"
   $	write out "&LT;title&GT;"
   $	write out "Help about ''bd'"
   $	write out "&LT;/title&GT;"
   $	write out "&LT;frameset cols=""30%,*""&GT;"
   $	write out " &LT;frameset rows=""20,*""&GT;"
   $	write out "  &LT;frame src=""",outnam_idx_top,""" name=""index_top"" scrolling=""NO"" marginheight=0&GT;"
   $	write out "  &LT;frame src=""",outnam_idx_1,""" name=""index""&GT;"
   $	write out " &LT;/frameset&GT;"
   $	write out " &LT;frame src=""",outnam_dat,""" name=""data""&GT;"
   $	write out "&LT;/frameset&GT;"
   $	write out "&LT;/html&GT;"
   $	close out
   $!
   $! Create the index file (in the left frame) upto 9 pieces
   $!
   $	k = 1
   $lp_dep2:
   $	filename_outidx_'k' = dirnam + outnam_idx_'k'
   $	fn = filename_outidx_'k'
   $	tag = "and"
   $	gosub create_file
   $	open/append out_idx_'k' 'fn'
   $	write out_idx_'k' "&LT;html&GT;"
   $	write out_idx_'k' "&LT;body&GT;"
   $	write out_idx_'k' "&LT;pre&GT;"
   $	out_nr_'k' = 0	!each level has a link field
   $	k = k + 1
   $	if k .le. max_depth then goto lp_dep2
   $	outnam = outnam_dat
   $	return
   $!
   $make_top_idx:
   $	fn = dirnam + outnam_idx_top
   $	tag = "and"
   $	gosub create_file
   $	open/append out_idx 'fn'
   $	write out_idx "&LT;html&GT;"
   $	write out_idx "&LT;body&GT;"
   $	k = 1
   $lp_dep4:
   $	if k .le. max_lev
   $ 	 then
   $	  fn4 = outnam_idx_'k'
   $	  write out_Idx "&LT;a href=""",fn4,""" target = ""index""&GT; ''k' &LT;/a&GT;"
   $	  k = k + 1
   $	  goto lp_dep4
   $	 endif
   $	write out_idx "&LT;/html&GT;"
   $	write out_idx "&LT;/body&GT;"
   $	close out_idx
   $	say "Maximum depth = ",max_lev
   $	return
   $!
   $! Init a new output (data) file
   $!
   $init_hdr:
   $	fn = dirnam + outnam_dat
   $	gosub create_file
   $	open/append out 'fn'
   $	write out "&LT;html&GT;"
   $	write out "&LT;head&GT;"
   $	write out "&LT;title&GT;Help about ''bd'"
   $	write out "&LT;/title&GT;"
   $	write out "&LT;body&GT;"
   $       write out "&LT;a name=""top_''fidx'""&GT;"
   $	write out "&LT;center&GT;"
   $	if fidx .eq. 0
   $	 then
   $	  write out "&LT;h1&GT;",bd,"&LT;/h1&GT;"
   $	 else
   $         write out "&LT;a href=""",old_outnam_dat,-
                "#bottom_''old_fidx'""target=""data""&GT;previous&LT;/a&GT;" 
   $	 endif
   $	write out "&LT;/center&GT;"
   $	nbyts = 0
   $	return
   $!
   $! FInish a data file
   $!
   $exit_hdr:
   $	if fidx .ge. 0
   $	 then
   $	  write out "&LT;center&GT;"
   $         write out "&LT;a href=""",outnam_dat, -
              "#top_''fidx'"" target=""data""&GT;next&LT;/a&GT;" 
   $	  write out "&LT;/center&GT;"
   $         write out "&LT;a name=""bottom_''old_fidx'""&GT;"
   $	 endif
   $	write out "&LT;/body&GT;"
   $	write out "&LT;/html&GT;"
   $	close out
   $	return
   $!
   $! Create a new data file(in stream_lf format)
   $!
   $create_file:
   $	write sys$output "      ",tag," ",fn
   $	create/fdl=sys$input 'fn'
   record
     format stream_lf
   $	return
   
</pre>
<a name="861">
<h3 Align=center><a href="dix_help_idx_3.html#225" target="index">DIX Example scripts COPY_TEXT </a> </h3>
<pre>
   
  Copy fields

  $DIX/INTER
  open mysysuaf programs_top:[dix.regres]sysuaf.work/modify
  open mypend programs_top:[dix.regres]pending.org
  sel  file mysysuaf
  read/eq=stubbf
  pwd1 = UAF$Q_PWD(1)
  pwd2 = UAF$Q_PWD(2)
  read/eq=jansen/err=notf
  displ *pwd*
  dep uaf$q_pwd(1) = %D'pwd1'
  dep uaf$q_pwd(2) = %D'pwd2'
  displ *pwd*
  undo
  displ *pwd*
  next file
  read/eq=jansen/err=notf	!should deliver 
  displ *pwd*
  dep uaf$q_pwd(1) = %D'pwd1'
  dep uaf$q_pwd(2) = %D'pwd2'
  displ *pwd*
  undo
  notf:
  close mysysuaf
  close mypend
</pre>
<a name="862">
<h3 Align=center><a href="dix_help_idx_3.html#226" target="index">DIX Example scripts CSV </a> </h3>
<pre>

  Check the dix/csv command

  $DIX/FILE SYSUAF.ORG/CSV=(SEP=CHAR=124,HEADER) TCPIP
</pre>
<a name="863">
<h3 Align=center><a href="dix_help_idx_3.html#227" target="index">DIX Example scripts CVT_HELP_TO_HTML </a> </h3>
<pre>
  This procedure converts .hlp/.hlb files to a list of .html files
  that can be viewed via a webbrowser. This procedure can be run from DIX using

  DIX&GT; @CVT_HELP_TO_HTML/dcl helpfile.hlp
  DIX&GT; @CVT_HELP_TO_HTML/dcl=fall helpfile.hlb  !.hlb files needs libr/extr 
						!as a fallback command

  Of course it can also be run from DCL via @CVT_HELP_TO_HTML
  This demonstrates the DCL compatibility of DIX

  $	if p1 .eqs. "?
  $	 then
  $	   typ sys$input
  
   Convert a vms help library (or a help file) to
    a .html file
   Parameters:
     p1: The name of the help library (or help file)
     p2: The name of the .html file (default p1-filename.html)
  
  $	  goto done
  $	 endif
  $!
  $! Definitions Settings
  $! 
  $	max_file_size = 500	!max size of data file
  $	def_file_type = ".HTML"
  $!
  $! Parse input, p1 : filename (.hlp or .hlb)
  $!
  $	inp_fnam = p1
  $	if inp_fnam .eqs. "" then inquire inp_fnam "Help library/file"
  $	fnam = f$parse(inp_fnam,".HLB")
  $!
  $	
  $	if f$search(fnam) .eqs. ""
  $	 then
  $	  fnam = f$parse(inp_fnam,".HLP")
  $	  if f$search(fnam) .eqs. ""
  $	   then
  $	    write sys$output "Could not find file ",fnam
  $	    goto done
  $	  endif
  $	 endif
  $	bd = f$parse(fnam,,,"NAME")
  $!
  $! PArse p2, location to store results
  $!	
  $	outnam = p2
  $	if p1 .eqs. "" .and. p2 .eqs. "" then Inquire outnam "Outputfile [''bd'.HTML]"
  $	dnam = bd + def_file_type
  $	outnam = f$parse(outnam,dnam)
  $	write sys$output "Converting ",fnam
  $!
  $	on control_y then goto abort
  $	on error     then goto abort
  $!
  $!  See if the input file is a .hlb (help library) or a .HLP file (help text)
  $!
  $	ex = f$edit(f$parse(fnam,,,"TYPE"),"UPCASE")
  $	if ex .eqs. ".HLB"
  $	 then
  $!
  $! Extract the contents to a temp file
  $!
  $	  tmpnam = f$unique() + ".TMP;0"
  $	  write sys$output "Extracting text from help library ",fnam
  $	  libr/extr=*/out='tmpnam' 'fnam'
  $	  fnam = tmpnam
  $	 else
  $	  tmpnam = ""
  $	 endif
  $!
  $!
  $	open/read lun 'fnam'
  $!
  $	max_depth      = 9	           !no more han 9 levels
  $	gosub make_main
  $!	
  $! Restart after end of wlev level
  $!
  $	seen_slash     = 0  		   !not in / mode
  $	nr             = 0  		   !topic index
  $	totline        = "" 		   !topic header line
  $	cur_len_0      = 0 		   !current header length
  $	cur_lev        = 0     		   !current level
  $	low_limit_size = max_file_size*460 !90% of size
  $	hig_limit_size = max_file_size*614 !120% of size
  $	old_outnam_dat = ""		   !previous filename
  $	fidx           = 0		   !file index
  $	max_lev        = 0
  $!
  $! Create main file (with frames) and index file
  $!
  $	gosub init_hdr
  $!
  $! Main loop : Keep reading
  $!
  $10:	read lun line/end=eof
  $	kar = f$extra(0,1,line)			!see if new topic
  $	if kar .eqs. "/" then goto slash	!found a / topic
  $	if kar .ges. "1" .and. kar .les. "9" 
  $	 then 
  $	  if f$extra(1,1,line) .eqs. " " then goto level   !found a number topic
  $	 endif
  $!
  $! Include the text as is
  $!
  $	gosub cvt_line	  
  $	write out line
  $	nbyts = nbyts +f$length(line) + 1	!one for the LF
  $	goto 10
  $!
  $! Found a slash topic, the first will increase the level
  $!
  $slash:
  $	if .not. seen_slash then ilev = ilev + 1
  $	seen_slash = 1
  $	goto gotit
  $!
  $! Found a number topic 1..9
  $!
  $level:	ilev = f$integer(kar)
  $	seen_slash = 0
  $!
  $! Skip the leading digit (and following spaces)
  $!
  $	line = f$extr(2,-1,line)
  $gotit:
  $	line = f$edit(line,"TRIM")
  $	gosub cvt_line	  
  $	write out "&LT;/pre&GT;"
  $!
  $! Limit the files in size
  $! If new level 1 and size&GT; 90%, make new
  $! If new level&GT;1 and size&GT;110%, make new
  $!
  $	if nbyts .lt. low_limit_size                   then goto keep_gooing
  $	if nbyts .lt. hig_limit_size .and. ilev .gt. 1 then goto keep_gooing
  $!
  $! File has gotten too big, close and open a new one
  $!
  $	old_fidx = fidx
  $	fidx = fidx + 1
  $	old_outnam_dat = outnam_dat
  $	outnam_dat = body + "_DATA_''fidx'" + file_type
  $!
  $	gosub exit_hdr		!finish off this file
  $	gosub init_hdr          !create new file
  $!
  $keep_gooing:
  $	nr = nr + 1
  $	tag_'ilev' = nr
  $	if old_line .nes. ""
  $	 then
  $	  gosub add_index
  $	 endif
  $!
  $	if ilev .gt. max_lev then max_lev = ilev
  $	if max_lev .gt. max_depth then max_lev = max_depth
  $!
  $	write out "&LT;a name=""''nr'""&GT;"
  $	if ilev .le. cur_lev
  $	 then
  $	  idx = ilev-1
  $	  nk = cur_len_'idx'
  $         totline = f$extra(0,nk,totline)
  $	 endif
  $	totline = totline + line + " "
  $	cur_len_'ilev' = f$length(totline)
  $	cur_lev = ilev
  $	write out "&LT;h3 Align=center&GT;",totline,"&LT;/h3&GT;"
  $	write out "&LT;pre&GT;"
  $	goto 10
  $!
  $! FOund eof
  $!
  $eof:	close lun
  $!
  $!
  $	ilev = 0
  $	gosub add_index
  $!
  $	old_fidx = fidx
  $	fidx = -1
  $	gosub exit_hdr
  $!
  $! Finish off the index file
  $!
  $	k = 1
  $lp_dep7:
  $	if k .le. max_depth
  $	 then
  $	  write out_idx_'k' "&LT;/pre&GT;"
  $	  write out_idx_'k' "&LT;/body&GT;"
  $	  write out_idx_'k' "&LT;/html&GT;"
  $	  close out_idx_'k'
  $	  fn = outnam_idx_'k'
  $	  if k .gt. max_lev then delete 'fn'
  $	  k = k+1
  $	  goto lp_dep7
  $	 endif
  $!
  $	gosub make_top_idx
  $!
  $dn1:	if tmpnam .nes. "" then delete/noconfirm 'tmpnam'
  $done:	exit
  $!
  $! ^Y or error
  $!
  $abort:	if f$trnlnm("out")     .nes. "" then close out
  $ 	if f$trnlnm("out_idx") .nes. "" then close out_idx
  $	k = 1
  $lp_dep5:
  $	if k .le. max_depth
  $	 then
  $ 	  if f$trnlnm("out_idx_''k'") .nes. "" then close out_idx_'k'
  $	  goto lp_dep5
  $	 endif
  $ 	if f$trnlnm("lun")     .nes. "" then close lun
  $	write sys$output "Aborting"
  $	goto dn1
  $!
  $add_index:
  $!
  $! 
  $!
  $	indent = f$fao("!#AS",(old_ilev-1)*2," ")
  $	kar = "  "
  $	if ilev .gt. old_ilev then kar = "+ "
  $	dep = 1
  $lp_dep3:
  $	if dep .le. max_depth
  $	 then
  $	  if old_ilev .le. dep
  $	   then
  $	    if old_ilev .eq. dep then kar = "- "
  $	    write out_idx_'dep' "&LT;a name=""''old_nr'""&GT;"
  $	    write out_idx_'dep' indent,kar,"&LT;a href=""",outnam_dat,-
                 "#''old_nr'"" target=""data""&GT;",old_line,"&LT;/a&GT;" 
  $	   endif
  $	  dep = dep + 1
  $	  goto lp_dep3
  $	 endif
  $	old_line = line
  $	old_ilev = ilev
  $	old_nr   = nr
  $	return
  $!
  $! Convert a text line, , make sure no special chars in line
  $!
  $cvt_line:
  $	kar1 = "&AMP;"
  $	kar2 = "&AMP;AMP;"
  $	gosub subst 	!subst &AMP; by &AMP;amp
  $	kar1 = "&LT;"
  $	kar2 = "&AMP;LT;"
  $	gosub subst 	!subst &LT; by &AMP;lt
  $	kar1 = "&GT;"
  $	kar2 = "&AMP;GT;"
  $	gosub subst     !subst &GT; by &AMP;gt
  $	return
  $!
  $! Replace all occurences of kar1 by  kar2 
  $!
  $subst:	bpos = 0
  $lp_s:	pos = f$locate(kar1,f$extra(bpos,-1,line))
  $       if pos .ne. f$length(line) - bpos
  $        then
  $         pos  = pos + bpos
  $         line = f$extra(0,pos,line) + kar2 + -
                   f$extra(pos+f$leng(kar1),-1,line)
  $         bpos  = pos + f$length(kar2)
  $         goto lp_s
  $        endif
  $	return
  $!
  $! Create the main and the index file
  $!
  $make_main:
  $	dirnam      = f$parse(outnam,,,"DEVICE") + -
                        f$parse(outnam,,,"DIRECTORY") 
  $	body        = f$parse(outnam,,,"NAME")
  $	file_type   = f$parse(outnam,,,"type")
  $	outnam_main = body           + file_type
  $	outnam_idx_top  = body + "_IDX_TOP"  + file_type
  $!
  $! Make upto 9 levels
  $!
  $	k = 1
  $lp_hd:	outnam_idx_'k'  = body + "_IDX_''k'"  + file_type
  $	k = k+1
  $	if k .le. max_depth then goto lp_hd
  $!
  $	outnam_dat      = body + "_DATA" + file_type
  $!
  $! Create the main file (containing the frames)
  $!
  $	fn = dirnam + outnam_main
  $	tag = " to"
  $	gosub create_file
  $	open/append out 'fn'
  $	write out "&LT;html&GT;"
  $	write out "&LT;head&GT;"
  $	write out "&LT;title&GT;"
  $	write out "Help about ''bd'"
  $	write out "&LT;/title&GT;"
  $	write out "&LT;frameset cols=""30%,*""&GT;"
  $	write out "  &LT;frameset rows=""20,*""&GT;"
  $	write out "  &LT;frame src=""",outnam_idx_top,""" name=""index_top"" scrolling=""NO"" marginheight=0&GT;"
  $	write out "  &LT;frame src=""",outnam_idx_1,""" name=""index""&GT;"
  $	write out " &LT;frameset&GT;
  $	write out "&LT;frame src=""",outnam_dat,""" name=""data""&GT;"
  $	write out "&LT;/frameset&GT;"
  $	write out "&LT;/html&GT;"
  $	close out
  $!
  $! Create the index file (in the left frame) upto 9 pieces
  $!
  $	k = 1
  $lp_dep2:
  $	fn = dirnam + outnam_idx_'k'
  $	tag = "and"
  $	gosub create_file
  $	open/append out_idx_'k' 'fn'
  $	write out_idx_'k' "&LT;html&GT;"
  $	write out_idx_'k' "&LT;body&GT;"
  $	write out_idx_'k' "&LT;pre&GT;"
  $	k = k + 1
  $	if k .le. max_depth then goto lp_dep2
  $	outnam = outnam_dat
  $	return
  $!
  $make_top_idx:
  $	fn = dirnam + outnam_idx_top
  $	tag = "and"
  $	gosub create_file
  $	open/append out_idx 'fn'
  $	write out_idx "&LT;html&GT;"
  $	write out_idx "&LT;body&GT;"
  $	k = 1
  $lp_dep4:
  $	if k .le. max_lev
  $ 	 then
  $	  fn4 = out_idx_'k'
  $	  write out_Idx "&LT;a href="",fn4,"" target = ""index""&GT; 1 &LT;/a&GT;"
  $	  k = k + 1
  $	  goto lp_dep4
  $	 endif
  $	write out_idx "&LT;/html&GT;"
  $	write out_idx "&LT;/body&GT;"
  $	close out_idx
  $	say "Maximum depth = ",max_lev
  $	return
  $!
  $! Init a new output (data) file
  $!
  $init_hdr:
  $	fn = dirnam + outnam_dat
  $	gosub create_file
  $	open/append out 'fn'
  $	write out "&LT;html&GT;
  $	write out "&LT;head&GT;"
  $	write out "&LT;title&GT;Help about ''bd'"
  $	write out "&LT;/title&GT;"
  $	write out "&LT;body&GT;"
  $       write out "&LT;a name=""top_''fidx'""&GT;"
  $	write out "&LT;center&GT;"
  $	if fidx .eq. 0
  $	 then
  $	  write out "&LT;h1&GT;",bd,"&LT;/h1&GT;"
  $	 else
  $         write out "&LT;a href=""",old_outnam_dat,-
               "#bottom_''old_fidx'""target=""data""&GT;previous&LT;/a&GT;" 
  $	 endif
  $	write out "&LT;/center&GT;"
  $	nbyts = 0
  $	return
  $!
  $! FInish a data file
  $!
  $exit_hdr:
  $	if fidx .ge. 0
  $	 then
  $	  write out "&LT;center&GT;"
  $         write out "&LT;a href=""",outnam_dat, -
             "#top_''fidx'"" target=""data""&GT;next&LT;/a&GT;" 
  $	  write out "&LT;/center&GT;"
  $         write out "&LT;a name=""bottom_''old_fidx'""&GT;"
  $	 endif
  $	write out "&LT;/body&GT;"
  $	write out "&LT;/html&GT;"
  $	close out
  $	return
  $!
  $! Create a new data file(in stream_lf format)
  $!
  $create_file:
  $	write sys$output "      ",tag," ",fn
  $	create/fdl=sys$input 'fn'
  record
    format stream_lf
  $	return
</pre>
<a name="864">
<h3 Align=center><a href="dix_help_idx_3.html#228" target="index">DIX Example scripts ENUM </a> </h3>
<pre>

  Check for enumeration of symbols/parameters

  $DIX/INT
  set noon
  i=1
  loop
   symb = f$enum(i,,"SYM")
  testloop symb &LT;&GT; ""
   say symb
   i=i+1
  endloop
  !
  i=1
  load forsysdef/mod=$lbrdef
  loop
   par = f$enum(i,"LBR$*","PAR")
  testloop par &LT;&GT; ""
   say par," = ",'par'
   i=i+1
  endloop
</pre>
<a name="865">
<h3 Align=center><a href="dix_help_idx_3.html#229" target="index">DIX Example scripts ERROR </a> </h3>
<pre>
  $DIX/INT
  open sysuaf.org
  echo "in error"
  on error goto verder
  read/eq="asfglkj"
  verder: 
  set on
  @file_not_present
  echo "uic c"


  And the file file_not_present.dix does not exist

</pre>
<a name="866">
<h3 Align=center><a href="dix_help_idx_3.html#230" target="index">DIX Example scripts EXTRACT_MLB </a> </h3>
<pre>

  This script can extract a module from starlet.mlb and convert it 
  to a FORTRAN (or DIX) definition file
  THis script can be run from DCL or under DIX via the
  DIX&GT;EXTRACT_MLB.COM/DCL[/output=fnam.ext] parameter

  $	debug = p2 .nes. ""
  $	leadin = "      "
  $	module = p1
  $	if module .eqs. "" then inquire Module "Modulename"
  $	if f$type($DIX_VERSION) .eqs. ""
  $	 then
  $!
  $! Not under DIX
  $!
  $       libr/extr='module'/out=x.txt sys$share:starlet.mlb
  $	  if .not. $status then goto done
  $	  open/read lun x.txt
  $	  do_delete = 1
  $	 else
  $!
  $! Under DIX we can open the moule directly
  $!
  $	  open/read/err=abort lun sys$share:starlet.mlb('module')
  $	  do_delete = 0
  $	 endif
  $	modnam = ""
  $     say:=write sys$output
  $10:	read lun line/end=done
  $	gosub split
  $	if kar .eqs. "K"
  $	 then
  $	  say leadin,"INTEGER*4  ''name'"
  $	  say leadin,"PARAMETER (''name'=''offs')"
  $	  goto 10
  $	 endif
  $	if kar .eqs. "M"
  $	 then
  $	  say leadin,"INTEGER*4  ''name'"
  $	  toffs = toffs - "&LT;" - "^X" - "&GT;"
  $	  toffs = "'" + toffs + "'X"
  $	  say leadin,"PARAMETER (''name'=''toffs')"
  $	  goto 10
  $	 endif
  $	if status .ne. 1 then goto 10
  $	if kar .eqs. "S"
  $	 then
  $	  oline = line
  $	  otag  = tag
  $	  wsize = offs
  $20:	  read lun line/end=done
  $	  gosub split
  $	  if status .ne. 1 then goto 20
  $	  if tag .eqs. otag
  $	   then
  $!
  $! We need to prcess the prev line
  $!
  $	    gosub process
  $	   else
  $	    if modnam .nes. "" then gosub finish
  $	    modnam = otag
  $	    modsize = wsize
  $	    say leadin,"STRUCTURE /''modnam'/  !size ''modsize'"
  $	    leadin = "        "
  $	    ifil = 0
  $	    offset = 0
  $	   endif
  $!	  set nover
  $	 endif
  $	wsize = 0
  $	gosub process
  $!	
  $	goto 10
  $done:  close lun
  $	if modnam .nes. "" then gosub finish
  $!
  $abort:	if do_delete then delete x.txt;
  $	exit
  $!
  $finish:
  $	if offset .ne. modsize
  $	 then
  $         nb = modsize - offset
  $	  say leadin,"BYTE FILLER_''ifil'(''nb')"
  $	 endif
  $	leadin = "      "
  $	say leadin,"END STRUCTURE"
  $	return
  $!
  $process:
  $	if debug then say "    found line ",line
  $	nsize = 0
  $	is_int=1
  $	if kar .eqs. "B" then nsize = 1
  $	if kar .eqs. "W" then nsize = 2
  $	if kar .eqs. "L" then nsize = 4
  $	if kar .eqs. "A" then nsize = 4
  $	if kar .eqs. "Q" then nsize = 8
  $	if kar .eqs. "PS" then nsize = 4
  $	if kar .eqs. "PQ" then nsize = 8
  $	if kar .eqs. "PQ" then nsize = 8
  $	if kar .eqs. "T"
  $	 then 
  $	  nsize = wsize
  $	  is_int=0
  $	 endif
  $	if nsize .ne. 0
  $	 then
  $	  
  $	  if offs .lt. offset then goto dn_pr
  $	  if offs .ne. offset
  $	   then
  $	    ifil = ifil + 1
  $	    nb = offs-offset
  $	    say leadin,"BYTE FILLER_''ifil'(''nb')"
  $	    offset = offs
  $	   endif
  $!
  $	  add_size = nsize
  $	  if is_int
  $	   then
  $	    if wsize .ne. 0
  $	     then
  $	      nrep = wsize/nsize
  $	      rep = "(''nrep')"
  $	      add_size = wsize	    
  $	     else
  $	      rep = ""
  $	     endif
  $	    if nsize .eq. 1
  $	     then
  $	      def = "BYTE "
  $	     else
  $	      def = "INTEGER*''nsize' "
  $	     endif
  $	   else
  $	    def = "CHARACTER*(''nsize')"
  $	    rep = ""
  $	   endif
  $	  def = def + name + rep
  $	  if f$length(def) .lt. 16 then def = f$fao("!16AS",def)
  $	  say leadin,def,"      !Offset ''offs'"
  $	  offset = offset + add_size
  $	 endif
  $dn_pr:	return
  $split:
  $!
  $!
  $! Split line in parts
  $!  if correct line  status=1
  $!  
  $!  $EQU    DSC64$S_DSCDEF64        16
  $!  results in
  $!	 name = DSC$S_DSCDEF64
  $!       kar  = S
  $!       size = 16  (integer)
  $!       tag =  DSCDEF64
  $!
  $	kar = ""
  $	status = 0
  $	line = f$edit(line,"UNCOMMENT,COMPRESS,TRIM,UPCASE")
  $	tag = f$element(0," ",line)
  $	if tag .nes. "$EQU" then goto dn_split
  $!
  $	name = f$element(1," ",line)
  $	pos = f$locate("$",name)
  $	if pos .eq. f$length(name) then goto dn_split
  $	if f$extract(pos+1,1,name) .eqs. "_"
  $	 then
  $	  kar = "K"
  $	 else 
  $!
  $	  if f$extract(pos+2,1,name) .eqs. "_"
  $	   then 
  $	    kar  = f$extract(pos+1,1,name)	
  $	    tag = f$extra(pos+3,-1,name)
  $	   else
  $	    if f$extract(pos+3,1,name) .nes. "_" then goto dn_split
  $	    kar  = f$extract(pos+1,2,name)	
  $	    tag = f$extra(pos+4,-1,name)
  $	   endif
  $	 endif
  $	toffs = f$element(2," ",line)
  $	offs  = f$integer(toffs)
  $!
  $	status = 1
  $dn_split: 
  $	return
  
  

</pre>
<center>
<a href="dix_help_data_2.html#top_2" target="data">next</a>
</center>
<a name="bottom_1">
</body>
</html>
